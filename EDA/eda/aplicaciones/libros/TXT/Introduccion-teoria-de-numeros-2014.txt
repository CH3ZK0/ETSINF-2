INTRODUCCIÓN a la
TEORÍA DE NÚMEROS.
Ejemplos y algoritmos.

Prof. Walter Mora F.,
Escuela de Matemática
Instituto Tecnológico de Costa Rica.
(https://tecdigital.tec.ac.cr/revistamatematica/)

Este libro se distribuye bajo la licencia Creative Commons Reconocimiento - No Comercial - Sin obra
derivada 3.0 Unported License. Esta licencia permite copiado y distribución gratuita, pero no permite venta ni modificaciones de
este material. Ver http://creativecommons.org/.
Límite de responsabilidad y exención de garantía: El autor o los autores han hecho su mejor esfuerzo en la preparación de este
material. Esta edición se proporciona“tal cual”. Se distribuye gratuitamente con la esperanza de que sea útil, pero sin ninguna
garantía expresa o implícita respecto a la exactitud o completitud del contenido.
La Revista digital Matemáticas, Educación e Internet es una publicación electrónica. El material publicado en ella expresa la
opinión de sus autores y no necesariamente la opinión de la revista ni la del Instituto Tecnológico de Costa Rica.
https://tecdigital.tec.ac.cr/revistamatematica/Libros/TeoriaNumeros/WMora_TeoriaNumeros.pdf

2

Copyright© Revista digital Matemática Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/). Primera Edición.
Correo Electrónico: wmora2@gmail.com
Escuela de Matemática
Instituto Tecnológico de Costa Rica
Apdo. 159-7050, Cartago
Teléfono (506)25502225
Fax (506)25502493

Mora Flores, Walter.
Introducción a la Teoría de Números. Ejemplos y algoritmos. 1ra ed.
– Escuela de Matemática,Instituto Tecnológico de Costa Rica. 2010.
219 pp.
ISBN Obra Independiente: 978-9968-641-11-1
1. Teoría de números. 2. Algoritmos 3. Programación.

Contenido

Prefacio

6
PARTE I

1

Fundamentos
1.1
1.2
1.3
1.4

2

Principios
Valor absoluto y la función sgn( x )
Las funciones TxU VxW y JxK
Números Poligonales y Piramidales
Ejercicios

2
2
5
5
7
11

Divisibilidad

14

2.1

15
17
18
21
22
27
29
31
32
34
36
39
43

2.2
2.3
2.4
2.5
2.6
2.7
2.8

3

INTRODUCCCION A LA TEORIA DE NUMEROS.

“Algoritmo de la división”
Ejercicios
Números Primos.
Criba de Eratóstenes: Cómo colar números primos.
2.3.1
Algoritmo e implementación.
Máximo común divisor
Algoritmo de Euclides I.
2.5.1
Algoritmo e implementación.
Algoritmo Extendido de Euclides.
2.6.1
Algoritmo e implementación.
Ecuaciones Diofánticas lineales.
Teorema fundamental de la aritmética
Ejercicios

Congruencias

47
3

4

CONTENIDO

3.1
3.2
3.3
3.4
3.5
3.6
3.7
3.8

4

Potencias mod m
4.1
4.2
4.3
4.4
4.5

5

Introducción
Raíces Primitivas
Logaritmo discreto o Indicador
Ejercicios

Residuos Cuadráticos
6.1
6.2
6.3

6.4

7

Orden de un elemento módulo m.
El Teorema “pequeño” de Fermat.
Teorema de Euler
4.3.1
Un recíproco del Teorema pequeño de Fermat
Teorema de Wilson
Teorema de Carmichael
Ejercicios

Raíces primitivas y logaritmo discreto
5.1
5.2
5.3

6

Congruencias módulo m
(*) Calendarios: ¿Qué día nació Ud?.
Trucos de divisibilidad.
(*) Cuadrados Mágicos
Clases residuales módulo m
Congruencias lineales
Teorema Chino del resto
Congruencias de Orden Superior
Ejercicios

Congruencias cuadráticas módulo m
Criterio de Euler
Símbolos de Legendre y Jacobi
6.3.1
Lema de Gauss
6.3.2
Ley de Reciprocidad Cuadrática.
Símbolo de Jacobi.
Ejercicios

47
50
52
53
56
61
63
66
67
71
71
73
75
82
83
85
88
92
92
92
97
101
104
104
106
108
112
115
121
123

Estimaciones, Estadísticas y Promedios

126

7.1
7.2
7.3
7.4

126
130
132
134
134
136
138
140
143
146

7.5

7.6

Funciones Aritméticas
A los números primos les gusta los juegos de azar.
Orden de Magnitud
Teorema de los números primos
7.4.1
Fórmula de Legendre para π ( x ).
7.4.2
Fórmula de Meisel para π ( x ).
Estimación de π ( x ). Teorema de los números primos.
7.5.1
La función Zeta de Riemann
7.5.2
Teorema de Mertens.
Números Armónicos

5

7.7

Acerca de los factores de un número grande
Ejercicios
PARTE II

8

INTRODUCCION A LA TEORIA ALGORITMICA DE NUMEROS.

Algoritmos para el mcd

153

8.1
8.2
8.3

154
155
159
160
162
163
164
165
168
169
170
170

8.4
8.5
8.6
8.7
8.8
9

148
150

Parte entera.
División con menor resto.
Algoritmo de Euclides II.
8.3.1
Algoritmo e implementación.
Algoritmo de Euclides con menor resto.
8.4.1
Implementación.
Algoritmo binario.
8.5.1
Algoritmo e Implementación.
Algoritmo LSBGCD (left-shift binary algorithm)
8.6.1
Algoritmo e Implementación.
Algoritmo Extendido de Euclides.
Inversos multiplicativos en m

Números Primos y factorización.

173

9.1
9.2
9.3
9.4

173
175
177
183
183
184
190
192
195
195
196
198
200
201
202
207

Introduccción
Criba de Eratóstenes.
Primos entre m y n.
Factorización por ensayo y error.
9.4.1
Probando con una progresión aritmética.
9.4.2
Algoritmo.
9.5
Método de factorización “rho” de Pollard.
9.5.1
Algoritmo e implementación.
Ejercicios
9.6
Pruebas de Primalidad.
9.7
Prueba de primalidad de Miller-Rabin.
9.7.1
Algoritmo e implementación.
Ejercicios
9.8
Algoritmo Chino del Resto.
9.8.1
Algoritmo e implementación.
Bibliografía
Bibliografía

207

Solución de los Ejercicios
Soluciones del Capítulo 2

208
208

Prefacio

La Teoría de Números estudia los números enteros y, en cierta medida los números racionales
y los números algebraicos. La Teoría Computacional de Números (Computational Number Theory) es sinónimo de Teoría Algorítmica de Números. Aquí se estudia los algoritmos eficientes
para cálculos en teoría de números. Este es un libro introductorio orientado hacia la teoría algorítmica de números. El interés es mostrar el valor puramente teórico de algunos teoremas y
cómo se debe hacer una variación si el propósito es cálculos rápidos y eficientes. Algunas algoritmos sencillos se implementan en VBA Excel o en LibreOffice Basic por ser lenguajes muy
amigables y por ser las hojas electrónicas muy familiares para los estudiantes. Sin emabargo estas implementaciones son muy límitadas y solo tienen fines didácticos. Otras implementaciones
se hacen en Java (para usar enteros y racionales grandes). En el capítulo final se desarrollan
algunos programas en Java que sirven de base para implementar otros algoritmos.
Agradezco a las personas que ayudaron con sus comentarios para corregir errores en el texto y
los programas y para mejorar algunos párrafos un tanto oscuros. Las actualizaciones del libro
(correcciones, nuevos programas, etc.,) estarán en https://tecdigital.tec.ac.cr/revistamatematica//Libros/.
También puede solicitar un ’machote’ LaTeX del libro.

W. MORA.
Cartago, Costa Rica
Diciembre, 2014.

Parte I

INTRODUCCCION A LA TEORIA DE
NUMEROS.

235711
131719
232931
235711

1
1.1

FUNDAMENTOS

Principios

Los números enteros son el ingrediente principal en teoría de números. En esta sección, establecemos brevemente la notación y el significado de algunos símbolos que se relacionan con los
enteros y que serán de amplio uso en el texto. Además se establecen algunos principios que se
usan ampliamente en los argumentos.
En lo que sigue, usaremos la siguiente notación

a.) N = {0, 1, 2, ...} y N+ = {1, 2, ...}.
b.) Z+ = {1, 2, ...} = N+
c.) R+ = { x ∈ R : x > 0}.

Principio del Buen Orden: Todo conjunto no vacío de números naturales contiene un elemento
mínimo.
En particular, si S ⊂ Z y si S tiene al menos un elemento positivo, entonces S tiene un entero
positivo mínimo.
Ejemplo 1.1
Probar que si a, b ∈ Z con b ≥ 1, entonces existe q ∈ Z tal que qb ≤ a < (q + 1)b.
Solución: Idea: qb sería el múltiplo de b más cercano a a en el sentido de que el
siguiente múltiplo, (q + 1)b, lo sobrepasa; por tanto a − qb ≥ 0 sería la resta no negativa
mínima. La existencia de este elemento mínimo se puede establecer usando el principio
del buen orden.
Sea S = { a − nb tal que n ∈ Z ∧ a − nb ≥ 0}. Primero probamos que S es no vacío. En
efecto, Si a ≥ 0, a = a − 0 · b ≥ 0, entonces a ∈ S. Si a < 0, a − ab = a(1 − b) ≥ 0 pues
b ≥ 1, entonces a − ab ∈ S. Por el principio del buen orden, S tiene un elemento mínimo
a − qb ≥ 0 y, por tanto a − (q + 1)b < 0. Así, qb ≤ a < (q + 1)b.

Principio del palomar: Si k es un entero positivo y k + 1 o más objetos son asignados a k cajas,
entonces hay al menos alguna caja a la que se le asignaron dos o más objetos.
Ejemplo 1.2
En un grupo de 367 personas, debe haber al menos dos que cumplen años el mismo día,
porque hay solo 366 posibles días para cumplir años.

Principio de Inclusión-Exclusión: Sean A y B dos conjuntos finitos. Entonces

| A ∪ B | = | A | + | B | − | A ∩ B |.

Ejemplo 1.3
Sea A = { a, b, c, d} y B = { a, b, c, g, h}. | A| = 4, | B| = 5, | A ∪ B| = |{ a, b, c, d, g, h}| = 6 y
| A ∩ B| = |{ a, b, c}| = 3. Luego, | A ∪ B| = 6 = | A| + | B| − | A ∩ B| = 4 + 5 − 3.

Principio de Inducción: Para probar que una proposición P(n) es verdadera para todo entero
positivo n, se deben ejecutar los dos pasos siguientes:
a.) Verificar que P(n) se cumple para n = 1,
b.) Probar que si se cumple P(k) (hipótesis de inducción), entonces se cumple P(k + 1)

Figura 1.1. Idea de inducción matemática usando un juego de domino.
3

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

4

FUNDAMENTOS

Se puede probar que el principio de inducción es un método válido de prueba si asumimos el
principio del buen orden como un axioma.

Ejemplo 1.4
Históricamente, el primer ejemplo que se conoce en el que se usó inducción matemática
aparece en el libro “Arithmeticorum Libri Duo” de Francesco Maurolico (1494-1575). En
este libro, entre otras cosas, Maurolico presenta gran variedad de propiedades de los
enteros y las pruebas de estas propiedades. Para las demostraciones, él ideo el método
de inducción matemática. La primera vez que se usa el método, es para probar que la
suma de los primeros n enteros impares es n2 . El nombre “inducción matemática”, lo
usó por primera vez el matemático inglés John Wallis.

Figura 1.2. Francesco Maurolico. “Arithmeticorum Libri Duo”, pág 7. En www.books.google.com

Probar que 1 + 3 + 5 + ... + (2n − 1) = n2
Solución: En este caso, n indica el número de sumandos.
a.) La proposición es correcta para n = 1 pues 1 = 12
b.) Hipótesis de inducción: suponemos que la proposición es cierta para n = k, es decir,
1 + 3 + 5 + ... + 2k − 1 = k2 . Ahora sumamos el siguiente impar, 2k − 1 + 2 = 2k + 1,
a ambos lados,
k2

}|
{
z
1 + 3 + 5 + ... + 2k − 1 + 2k + 1 = k2 + 2k + 1 = (k + 1)2 .
Por lo tanto, hemos demostrado que si la proposición es correcta para n = k, es
correcta para n = k + 1. Entonces, la fórmula es válida para todo n ∈ N, por el
principio de inducción.

Principio de Inducción Completa: Para probar que una proposición P(n) es verdadera para
todo entero positivo n, se deben ejecutar los dos pasos siguientes:

a.) Verificar que P(n) se cumple para n = 1,
b.) Probar que si se cumple P(1) ∧ P(2) ∧ ... ∧ P(k) (hipótesis de inducción), entonces se
cumple P(k + 1)

5

Se puede probar que el principio de inducción completa es equivalente al principio de inducción. Es decir, cada principio puede ser demostrado asumiendo el otro. La ganancia es que el
principio de inducción completa es más flexible. A el principio de inducción completa también
se le llama "principio de inducción fuerte" o "segundo principio de inducción".

Ejemplo 1.5
Si n es un entero mayor que uno, n se puede escribir como un producto de primos. La
demostración de este hecho se hace con inducción fuerte. Puede ver el teorema 2.14, que
está más adelante.

1.2

Valor absoluto y la función sgn( x )

Muchas veces es conveniente separar el número y su signo. Para esto usamos la función “signo”.
En las aplicaciones es necesario que esta función solo tome dos valores −1 y 1.

Definición 1.1 (Función signo).
Definimos sgn( x ) = 1 si x ≥ 0 y sgn( x ) = −1 si x < 0.

Teorema 1.1
Sea a ∈ Z. Entonces, | a| = a · sgn( a) = a/sgn( a).

Ejemplo 1.6
a.) | − 5| = −5 · sgn(−5) = −5 · −1 = 5

1.3

b.) |0| = 0/sgn(0) = 0/1 = 0

Las funciones TxU VxW y JxK

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

6

FUNDAMENTOS

Definición 1.2 (Parte entera).

• Función TxU. Si x ∈ R y n ∈ Z tal que n ≤ x < n + 1 entonces TxU = n.
• Función VxW. Si x ∈ R y n ∈ Z tal que n − 1 < x ≤ n entonces VxW = n.
• Función JxK.
JxK =


 TxU si

x≥0



x<0

VxW si

Ejemplo 1.7
a.) T1.4U = 1

b.) V1.4W = 2

c.) T−1.4U = −2

d.) V−1.4W = −1

e.) V−3W = T−3U = −3.

Representación gráfica. Los gráficos que siguen nos dan una idea clara del significado de cada
una de estas funciones.

y = TxU

y = VxW

3
2
1
4

3

2

1

1

1

2

3

y = JxK

4

4

3

3

2

2

1

1

4

2
3
4

4

3

2

1

1

1

2

3

4

4

3

2

1

1

2

2

3

3

1

2

Ejemplo 1.8
Probar que T− xU = −VxW.
Solución: Supongamos que T− xU = n, es decir, n ≤ − x < n + 1.
−n − 1 < x ≤ −n, es decir, VxW = −n. ∴ T− xU = −VxW.

Entonces

3

4

7

Ejemplo 1.9
Sea n ∈ Z. Entonces n = 2k o n = 2k + 1 para algún entero k, ya sea que n es par o
impar.
s
{ s
{
n−3
2k − 2
a.) Si n = 2k + 1 ≥ 3, entonces
=
=k−1
2
2
s
{ s
{ s
{
n−3
2k − 3
1
b.) Si n = 2k ≥ 3, entonces
=
= k−1−
=k−2
2
2
2
p − 1 r pz
−
= 4k − 1 − (2k − 1) = 2k
c.) Si p = 8k − 1 > 3, entonces
2
4

Ejemplo 1.10 (Conteo).
Si x > 0, el número JxK cuenta la cantidad de enteros positivos menores o iguales a x
pues, por definición, si JxK = k entonces 1, 2, ..., k son menores que x.
Sea p un entero positivo y x ≥ p. Tx/pU cuenta la cantidad de enteros ≤ x divisibles
por p. En efecto, los enteros positivos divisibles por p e inferiores a x son los k números
p < 2p < ... < k · p ≤ x. Como kp ≤ x < (k + 1) p, entonces k = Tx/pU.

1.4

Números Poligonales y Piramidales

Los números figurados son enteros positivos que pueden ser representados por patrones geométricos. Los números poligonales son números figurados que se pueden representar por medio de polígonos regulares en el plano. Los números piramidales son números que pueden ser representados
por formas piramidales. Ellos son obtenidos tomando sumas de los correspondientes números
poligonales.
Números cuadrados. Los Pitagóricos usaban la palabra gnomon (= ) para referirse a los enteros impares 1, 3, 5, 7, ... . De manera figurada, cada gnomon es una “configuración” de puntos
que se agrega a la configuración anterior, manteniendo su forma (figura 1.3). Ellos observaron
que n2 es la suma de los n primeros impares,
1

= 12 ,

1+3

= 22 ,

1+3+5

= 32 ,

1+3+5+7

= 42
..
.

8

FUNDAMENTOS

En el ejemplo (1.2) ya habíamos indicado que Francesco Maurolico (1494-1575), probó este hecho
usando por primera vez, inducción matemática. Una “prueba geométrica” se puede observar en
la figura (1.3).

Figura 1.3. Cada cuadrado es construido agregando un número impar (los círculos azules)

Los números cuadrados sn , corresponden a la cantidad de puntos en un
arreglo cuadrangular de n × n. En este caso sn = n2 . A los números
sn también se les llama cuadrados perfectos, y como acabamos de ver,
son una suma de números impares. También notamos en el ejemplo
1.2 que sn+1 = sn + 2n + 1, es decir, el siguiente cuadrado perfecto se
obtiene agregando un gnomon (la escuadra de 2n + 1 puntos azules) al
número figurado anterior.

9

8

7

6

5

7

6

5

4

4

5

4

3

3

3

3

2

2

2

2

1

1

1

1

1

Figura 1.4. Cuadrados perfectos.

Ley de la caída de los cuerpos de Galileo. En 1590 Galileo estableció, usando
relojes de agua, que un objeto inicialmente estacionario que se deja caer libremente
por gravedad (ignorando resistencia del aire y rotación de la tieraa), cae una distancia
que es proporcional al cuadrado del tiempo transcurrido. La imagen de la derecha,
que abarca medio segundo, fue capturada con un flash estroboscópico en 20 destellos
por segundo. Durante el primer 1/20 de segundo la bola cae una unidad de distancia
(aquí, una unidad es aproximadamente 12 mm); a los 3/20 de segundo llevamos 4
unidades, a los 5/20 de segundo llevamos 9 unidades, a los 7/20 de segundo llevamos
16 unidades, etc. En general, un cuerpo cae en distancias proporcionales a los tiempos
1, 1 + 3, 1 + 3 + 5 , 1 + 3 + 5 + 7, ... así que la distancia total de caída es proporcional
al cuadrado del tiempo. La constante de proporcionalidad (cerca de la superficie de la
tierra) es 0.5g y la la fórmula para la distancia recorrida en la caída es d(t) = 12 g t2 .
Números Triángulares. Los números triangulares tn corresponden a la cantidad de círculos (o
puntos u otra cosa) en un arreglo triangular con n columnas, como se ve en la figura (1.5).
2

3

4
5

3

1

2

1

1

9
4

9

3
6

4

5
7
6

10
8

2
5
1

12
8

3

14
11

7
2

15
13

10
6

1

Figura 1.5. Números triangulares t1 = 1, t2 = 3, t3 = 6, t4 = 10, ...

Como cada columna tiene un elemento más que la columna anterior, tenemos que
tn = 1 + 2 + · · · + n − 1 + n

9

Podemos tomar dos copias de tn y hacerlas encajar, de tal manera que obtengamos un rectángulo,como se ve en la figura (1.6).

Figura 1.6. 2t1 = 2 · 1, 2t2 = 3 · 2, 2t3 = 4 · 3, ...

Esto nos lleva de inmediato a la fórmula cerrada tn =

n ( n + 1)
.
2

La figura (1.7) también constituye una “prueba geométrica” (base para una conjetura) de la
relación entre números triangulares y cuadrados, tn + tn−1 = sn

Figura 1.7. tn + tn−1 = sn

Es fácil responder la pregunta ¿Cuándo un número triangular es cuadrado?. Esto sucede si
tn = sm , ahora usamos nuestras fórmulas,
tn = sm ⇐⇒

n ( n + 1)
= m2 ⇐⇒ (2n + 1)2 − 8m2 = 1
2

En general, un número poligonal es un tipo de número figurado, que cuenta la cantidad de
objetos en un arreglo en forma de cuadrado, triángulo, etc. La figura (1.8) muestra algunos de
estos arreglos,
2

3

4
7
5
3

1

3

2

9

6

6

10

2

8

4
5
1

1

1

3

6

10
6

3

13

8
3

1

1

4

1

5

9

9

1

12

2
2

15

5
8
4

2

7
9

5
3
5

1

5

4
8
5

8

3
1

1

6

1

2

4

4
4

14

9

13

6
7

6

12
10

5

2

13

3
7

15

18

4
3
2
1

6
17

2
1

5
3

12
4
6

10

13 17
20 29
19 25
31
15
27 33
23
34
22
26 32
14
30
5
18 24
7
21 28
12 16
8

15

8
1

16
14

18

14

7 12 16 23
14 19 25
11
22 27
1
8
18
28
2
10
21 26
4
13 17 24
6 9 15 20

9
1

20

5

11

11

10

12

3

7
2

22
16

7

10

21

8
2

1

19
17

12

5

15
13

3

2

3

11
9

6
1

6

4

11
7

1

3

11

4
4

2

16
14

7

11
10
9

10

FUNDAMENTOS

3

5

5

8

3
1

1

6

1

4

4
4

6

9

13

6
7

5
7

12

16

2
1

3

5

18

17

8
1

4
3
2
1

15

13
9

1

15

7 12 16 23
14 19 25
11
22 27
1
8
18
28
2
10
21 26
4
13 17 24
6 9 15 20
5

3

11

11

3

2

14

7
2

2

12
10

4
6

10

14

13 17
20 29
19 25
31
15
27 33
23
34
22
26 32
14
30
5
18 24
7
21 28
12 16
6

8

11
10
9

Figura 1.8. Números poligonales

Números tetraédricos. Denotados como Tn , son los análogos de los triangulares en 3D. Estos
números son la cantidad de puntos en una pirámide tetraédica, como se observa en la figura
(1.9),

Figura 1.9. T1 = 1, T2 = 4, T3 = 10, ...

Como la n−ésima capa es un arreglo triangular de tn puntos, entonces
Tn = t1 + t2 + ... + tn
La “prueba geométrica” es un poco más complicada. Se requiere usar cubos, en vez de puntos,
de tal manera que varias copias encajen perfectamente para formar un cuboide. Por ejemplo,
consideremos T3 = 10, en la figura (1.10) se puede observar la nueva configuración de T3 usando cubos. Las dos copias de T3 ajustan bien, pero no constituyen un cuboide.

Figura 1.10. Encajar dos copias de T3 = 10

Para lograr un cuboide necesitamos seis copias de T3 , como se ve en la en la figura (1.11)

Figura 1.11. Encajando seis copias de T3 = 10

EJERCICIOS

11

Entonces, con seis copias de T3 obtenemos un cuboide de orden 3 × (3 + 1) × (3 + 2), por tanto
T3 = 3(3 + 1)(3 + 2)/6. Generalizando, si sumamos seis copias de Tn , obtenemos es un cuboide
de orden n × (n + 1) × (n + 2), es decir,
Tn =

n(n + 1)(n + 2)
6

Números piramidales Pn de base cuadrada. Estos números corresponden a la cantidad de
objetos en una pirámide de base cuadrada y altura n. En la figura (1.12) se muestra una configuración para P4 = 30.

+

+

+

=

Figura 1.12. P4 = 30

La k−ésima capa en la pirámide es un cuadrado con sk = k2 objetos, entonces
Pn = 12 + 22 + ... + n2
Para obtener una fórmula para Pn , usamos la relación entre números cuadrados y números
triangulares, esto nos lleva a una expresión en términos de Tn .

Pn

=
=

n

n

k =1
n

k =1
n

∑ k 2 = ∑ ( t k + t k −1 )

∑ tk

k =1

=

+

∑ tk−1 = Tn + Tn−1

k =1

n(n + 1)(2n + 1)
.
6

EJERCICIOS
1.1 Verifique, usando el principio del buen orden, que el conjunto S = {2x + 3y : x, y ∈ Z}
tiene un elemento positivo mínimo y calcular este elemento.
1.2 Use un el área de un rectángulo n × (n + 1) para modlar la suma 1 + 2 + 3 + ... + n =
n ( n + 1)
2
1.3

Sea S = {1, 2, 3, ..., 1000000} . ¿Cuántos números hay en S que son divisbles por 1021 ?.

12

FUNDAMENTOS

1.4 Use el principio de Inclusión-Exclusión para establecer una fórmula, usando la función
parte entera, que cuente todos los números positivos menores que x que no son divibles por 3
ni por 5 . Luego use la fórmula para verificar que en el primer millón de naturales, hay 533333
números que no son divibles por 3 ni por 5 . (Sugerencia: Contamos los números positivos
divisibles únicamente por 3 y los divisibles únicamente por 5 y luego los excluimos. Usamos
el principio de Inclusión-Exclusión para contar porque tenemos que excluir los que simúltaneamente son divisibles por 3 y 5. )
1.5

Probar, usando el principio de inducción, las fórmulas para sn , tn , y Tn

1.6

Muestre que 8tn + 1 = s2n+1

1.7 Probar, usando inducción, que si a y n son enteros positivos, existe otro entero positivo m
tal que am > n
1.8

Use inducción para probar que 1 + 23 + 33 + ... + n3 = n2 (n + 1)2 /4

1.9

Probar la fórmula para la suma de los primeros n términos en una progresión aritmética,
a + ( a + d) + ( a + 2d) + ... + [ a + (n − l )d] = na +

1.10

Probar que si x 6= 1 es un número real fijo, entonces
1 + x + x2 + x3 + · · · + x k =

1.11
1.12

n ( n − 1)
d
2

1 − x k +1
, k∈ N
1−x

Mostrar que si x ∈
/ Z, entonces VxW = TxU + 1.

[Truncamiento y redondeo.] Sea x ∈ R. La expansión decimal de x es,

x = a.a1 a2 a3 .... = a + a1 · 10−1 + a2 · 10−2 + a3 · 10−3 + ..., con a ∈ Z y ai ∈ {0, 1, 2, ..., 9}.
Por ejemplo, 3.1415926535... = 3 + 1 · 10−1 + 4 · 10−2 + 1 · 10−3 + 5 · 10−4 + · · · .
Probar que si n ∈ N+ ,
a) T10n xU/10n es un truncamiento de x a n cifras decimales.
Por ejemplo, T1000 · 3.1415926535...U/1000 = 3.141.
b) T10n x + 0.5U/10n es un redondeo de x a n cifras decimales.
Por ejemplo, T1000 · 3.1415926535... + 0.5U/1000 = 3.142.

EJERCICIOS

13

Versión actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

2

DIVISIBILIDAD

Definición 2.1
Sean a, b enteros con b 6= 0. Decimos que b divide a a si existe un entero c tal que a = bc. Si b
divide a a escribimos b| a

Teorema 2.1
Sean a, b, d, p, q ∈ Z.
a.) Si d| a y d|b entonces d|( ax + by) para cualquier x, y ∈ Z
b.) Si d|( p + q) y d| p =⇒ d|q.
c.) Si a, b ∈ Z+ y b| a =⇒ a ≥ b
d.) Si a|b, entonces a|mb, con m ∈ Z.
e.) Si a, b ∈ Z, a|b y b| a =⇒ | a| = |b|

Prueba:
a.) Sea a = nd y b = md, entonces ax + by = (nx + my)d =⇒ d|( ax + by)
b.) Sea p = kd y p + q = k0 d, entonces q = d(k0 − k ) =⇒ d|q
c.) Como a, b ∈ Z+ , si a = kb entonces k ≥ 1 y por tanto a = bk ≥ b.
d.) Sea b = ka =⇒ mb = mka = (mk ) a =⇒ a|mb
e.) El item c.) solo aplica si a y b son positivos. Si a|b y b| a entonces, | a|||b| y |b||| a|, por el
item c.), | a| ≤ |b| y |b| ≤ | a|. ∴ | a| = |b|

Ejemplo 2.1
5| − 5

y

−5|5.

∴ |5| = | − 5|

Ejemplo 2.2
Sean a, b, d ∈ Z. Muestre que si a|d y d|b entonces a|b
Solución: Si a|d ∧ d|b =⇒ d = k1 a ∧ b = k2 d,
k2 (k1 a) =⇒ a|b

2.1

con k1 , k2 ∈ Z. Luego b = k2 d =

“Algoritmo de la división”

Si la división no es exacta, no todo está perdido: Como hacíamos en la escuela, la división de a
por b la podemos expresar como un cociente y un resto. Por ejemplo, la división de 23 por 3 es
7 y queda un resto r = 2. Es decir, 23 = 7 · 3 + 2. Gráficamente,
r=2
7·3

23

(7 + 1) · 3

Teorema 2.2 (Teorema de la división).
Sean a, b ∈ Z con b 6= 0. Existen q, r ∈ Z únicos tales que
a = bq + r con 0 ≤ r < |b|.
Prueba: Primero vamos a demostrar el teorema para a, b ∈ Z con b > 0. Consideremos la progresión aritmética
. . . , −3b, −2b, −b, 0, b, 2b, 3b, . . .
Por el principio del buen orden (ver el ejemplo 1.1) existe q ∈ Z tal que
qb ≤ a < (q + 1)b

Sea r = a − qb, entonces a = bq + r. De qb ≤ a obtenemos 0 ≤ r y de a < (q + 1)b =⇒ a − qb < b.
∴ a = bq + r con 0 ≤ r < b
Unicidad: La prueba es por contradicción. Supongamos que existe q1 , r1 ∈ Z tal que
a = bq1 + r1 con 0 ≤ r1 < b y a = bq + r con 0 ≤ r < b
15

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

16

DIVISIBILIDAD

Ahora supongamos que r 6= r1 y que r > r1 .


 a

= bq1 + r1



= bq + r

a

=⇒ bq1 + r1 − (bq + r ) = 0 =⇒ b(q1 − q) = r − r1 =⇒ b|(r − r1 ).

Como b|(r − r1 ), se tiene que r − r1 ≥ b; pero 0 < r − r1 < r < b; contradicción!.
Por lo tanto, r = r1 . De aquí: b(q1 − q) = r − r1 = 0 =⇒ q1 = q
Caso b < 0. Existen q, r ∈ Z únicos tales que a = |b|q + r con 0 ≤ r < |b| con lo que
a = b · (−q) + r con 0 ≤ r < |b|.

Nota 1: Si a, b ∈ Z+ , el ‘algoritmo de la división’ corresponde a la división usual. Si a o b es
negativo, la división usual difiere del teorema de la división.
El enunciado del teorema de la división es adecuado para fines teóricos. Para efectos de cálculo
es mejor enunciar el teorema de la división así:

Teorema 2.3
Sean a, b ∈ Z con b 6= 0. Existe un único r ∈ Z tal que
Si b > 0, a = b Ta/bU + r con 0 ≤ r < b.
Si b < 0, a = b Va/bW + r con 0 ≤ r < |b|.
En este contexto, a/b denota la división usual en R.

Prueba: Si b > 0 entonces, por el teorema de la divisón, existe q ∈ Z tal que qb ≤ a < (q + 1)b,
es decir q = Ta/bU y, por supuesto r = a − b Ta/bU.
Si b < 0 entonces a = b · (−q) + r con 0 ≤ r < |b|. Así, −q = −Ta/bU = Va/bW, por tanto
−q = Va/bW y, por supuesto r = a − b Va/bW.
Notación para restos. El resto de la división de a por b se denota “ rem ( a, b)” o también
“ rem( a, b)”. Por supuesto, a|b si rem ( a, b) = 0. Para efectos teóricos puede ser conveniente
que r > 0 pero en cálculos computacionales se puede permitir que r sea negativo. Esto es algo
que vamos a retomar más adelante.

EJERCICIOS

Ejemplo 2.3
Dividir −12 por −5 :
−12
10

−5,
2

−2

En la división ordinaria −12 = 2 · −5 − 2.
Desde el punto de vista del teorema de la división,
como −3 · 5 ≤ −12 < −2 · 5, se tiene
−12 = −3 · 5 + 3

Ejemplo 2.4
Si a = 2q + r con 0 ≤ r < 2. Si r = 0 a se dice par y si r = 1, a se dice impar.

Ejemplo 2.5
Sean n, p ∈ N con n ≥ p > 0. Mostrar que hay Tn/pU números divisibles por p en el
conjunto A = {1, 2, ..., n}.
Solución: Si p < n entonces p divide a los números { p, 2p, ..., qp} ⊆ A donde qp ≤ n <
(q + 1) p, es decir p divide a Tn/pU números en este conjunto.
Ejemplo 2.6
¿Cuántos enteros positivos ≤ 1000 000 no son divisibles por 3 ni por 5?
Solución: Contamos los númerospositivos divisibles únicamente por 3 y los divisibles
únicamente por 5 y luego los excluimos. Podemos usar el principio de InclusiónExclusión para contar porque tenemos que excluir los que simúltaneamente son
divisibles por 3 y 5.
Sea A = { x ∈ Z+ : x ≤ 1000 000 y 3| x } y B = { x ∈ Z+ : x ≤ 1000 000 y 5| x }. Los
números divisibles por 3 y por 5 son divisibles por 15. Entonces,

| A ∪ B| = | A| + | B| − | A ∩ B|
= T1000 000/3U + T1000 000/5U − T1000 000/15U
= 333333 + 200000 − 66666 = 466667

Por tanto, en el primer millón de enteros positivos, hay 1000 000 − 466667 = 533333 enteros no divisibles por 3 ni por 5.

EJERCICIOS
2.1

Dé un contraejemplo de la afirmación: a|bc y a - c entonces a|b

17

18

DIVISIBILIDAD

2.2

Mostrar que si d| a ∧ d|( a + 1) entonces |d| = 1

2.3

Sean d, n ∈ Z. Si d no divide a n entonces ningún múltiplo de d divide a n.

2.4

Si d| a y d|b y si a = bq + r entonces d|r.

2.5 Sea b 6= 0 y a = qb + r con 0 ≤ r < |b|. Muestre que en el conjunto { a, a − 1, ..., a − |b| + 1}
hay un único múltiplo de b.
2.6

Muestre que si a, b, d ∈ Z, a impar y si d| a y d|( ab + 2), entonces d = 1

2.7 ¿Cuántos enteros positivos ≤ 3000 son divisibles por 3, 5 o 7? Ayuda: | A ∪ B ∪ C | =
| A| + | B| + |C | − | A ∩ B| − | B ∩ C | − |C ∩ A| + | A ∩ B ∩ C |

2.2

Números Primos.

Definición 2.2 (Primos y compuestos).
Un entero p > 1 se dice primo si sus únicos divisores son 1 y p. Si p no es primo, se dice
compuesto.

El número 1 no se toma como primo solo por conveniencia. No perjudica en nada y obtenemos
cierta economía en la formulación de teoremas.
Ejemplo 2.7
Los primeros primos son {2, 3, 5, 7, 11, 13, 17, ...}

Ejemplo 2.8
Sea pi el i −ésimo primo. El número N = p1 · p2 · spn + 1 puede ser o no ser primo. Por
ejemplo,
N = 2 · 3 · 5 · 7 · 11 + 1 = 2311 es primo (ver ejemlo 2.9),
N = 2 · 3 · 5 · 7 · 11 · 13 + 1 = 30031 = 59 · 509 no es primo.

Teorema 2.4
Todo entero positivo n > 1 tiene un divisor primo

EJERCICIOS

19

Prueba: Si n es primo, tiene un divisor primo (él mismo). Supongamos que n es compuesto.
Por el principio del buen orden podemos suponer que existe un d > 1 que es el más pequeño
divisor positivo de n. Entonces d es primo. En efecto, si d fuera compuesto, d tendría un divisor
1 < d1 < d. Pero si d1 |d y d|n entonces d1 |n, en contradicción con la suposición de que d era el
más pequeño divisor > 1, de n.

Corolario 2.1 Sea n ∈ Z, n > 1. El más pequeño divisor positivo d > 1 de n es primo.

¿Cómo decidir si n es primo? El problema de decidir si es un número es primo no es en
general fácil. Si n es un número muy grande, probar que n no es divisible por ningún número
excepto 1 y n, nos llevaría a hacer un número nada razonable de cálculos. El siguiente teorema
nos dice que para determinar si un número n es primo o no, basta con probar con los divisores
√
√
primos inferiores a n. Aunque n es en general pequeño respecto a n, este método tiene un
alcance muy limitado.

Teorema 2.5
Sean a, b, n ∈ N, a > 1, b > 1 y n > 1.
√
√
a.) Si n = ab, entonces a ≤ n ∨ b ≤ n.
√
b.) Si n no tiene divisores primos ≤ n, entonces n es primo.

Prueba: Probamos a.) por contradicción: Si a >

√

n ∧ b>

√

n =⇒ ab > n. (⇒⇐).

Probamos b.): Si n fuera compuesto, n = ab con a > 1, b > 1. Entonces como los divisores primos de a y b son divisores de n, tendríamos que al menos uno de eso divisores es menor que
√
n en contradicción con la hipótesis.

Corolario 2.2 Si n es compuesto, n tiene un divisor primo p ≤

√

n.

Ejemplo 2.9
¿ n = 103 es compuesto?

√
Solución: 103 es primo pues no es divisible por ningún primo inferior a 103 ≈ 10.1
En efecto, los primos inferiores a 10 son 2, 3, 5 y 7. Para probar que n no es divisible
por alguno de estos números calculamos los residuos: rem (103, 2) = 1, rem (103, 3) = 1,
rem (103, 5) = 3 y rem (103, 7) = 5.
¿ n = 2311 es primo?
Solución: Si√es primo. En efecto, si no fuera primo, n = 2311 tendría un divisor primo
p con p ≤ 2311 = 48.07... . Los primos inferiores a 48 son {2, 3, 5, 7, 11, 13, 17, 19, 23, 29,

20

DIVISIBILIDAD

31, 37, 41, 43, 47} pero ninguno de ellos divide a 2311.
¿Puede un número n compuesto tener factores primos más grandes que

√

n?

√
Solución: Si n = p1 p2 con p1 √
y p2 primos distintos, no podrían ser ambos < n!.√Por
ejemplo 206 = 2 · 103 y 103 > 206 ≈ 14.35. Hay casos como 16 = 2 · 2 · 2 · 2 y 2 < 16.

¿Cuántos primos hay?. Los primos son infinitos. Es algo que se conoce desde la época de
Euclides.

Teorema 2.6 (Euclides).
Hay un número infinito de primos

Prueba: La demostración es por contradicción: Si p1 , . . . , pn fueran todos los primos, el número
N = p1 p2 · spn + 1 es un nuevo primo o tiene un divisor primo diferente de cada pi , i = 1, 2, ..., n.
Si N es primo, N > pi , i = 1, 2, ..., n y entonces sería un nuevo primo, contradicción.. Si N
no es un nuevo primo, tiene un divisor primo p j , pero entonces como p j |( p1 p2 · spn + 1) y
p j |( p1 p2 · spn ) =⇒ p j |1 lo cual es imposible pues p j > 1.
¿Cuántos primos hay ≤ x ?. Ahora esta es la pregunta correcta. π ( x ) denota la cantidad de
primos inferiores o iguales x. Por ejemplo, π (5) = π (6) = 3. Hasta el 2008, se conocen todos los
primos inferiores a x = 100 000 000 000 000 000 000 000 = 1023 . Se tiene
π (1023 ) = 1 925 320 391 606 803 968 923.
También se conocen algunos primos fuera de éstos, por ejemplo 19249 · 213018586 + 1 es un primo
con 3918990 dígitos; fue encontrado en el 2007 por Samuel Yates.
Una fórmula (no muy eficiente) para π (n) es la fórmula de Legendre (ver la sección 7.4.1),

Teorema 2.7 (Legendre).
Sean p1 , p2 , ..., ps los primos ≤

√
π (n) = n − 1 + π ( n) −

√

n, entonces

∑

1≤ i ≤ s

Tn/pi U +

−

∑Tn/( pi p j )U

i< j

∑

i < j<k

Tn/( pi p j pk )U + · · · + (−1)s Tn/( p1 p2 · sps )U.

EJERCICIOS

21

Ejemplo 2.10
Calcular π (100) con la fórmula de Legendre.
Solución:
Los ingredientes son: n = 100,
√
π ( 100) = 4. Por tanto,
π (100)

2.3

√

100 = 10, los primos ≤ 10 son {2, 3, 5, 7} y

=

100 − 1 + 4 − (T100/2U + T100/3U + T100/5U + T100/7U)

+

(T100/(2 · 3)U + T100/(2 · 5)U + T100/(2 · 7)U + T100/(3 · 5)U + T100/(3 · 7)U

+

T100/(5 · 7)U)

−

(T100/(2 · 3 · 5)U + T100/(2 · 3 · 7)U + T100/(2 · 5 · 7)U + T100/(3 · 5 · 7)U)

+

T100/(2 · 3 · 5 · 7)U = 25.

Criba de Eratóstenes: Cómo colar números primos.

Como vimos en el ejemplo 2.9, se requiere conocer una lista de primos para decidir si un número
es primo o no. Este método para determinar la primalidad de un número es conocido como
‘ensayo y error’ (‘trial division’). Es efectivo para números pequeños pero no para números
√
muy grandes. El problema es que la cantidad de números primos inferiores a n es aproxi√
√
un
madamente n/ ln( n) (Teorema de los Números Primos), así por ejemplo
√ si tenemos
√
número a ≈ 1020 , para establecer si es primo o no, habría que probar con 1020 / ln( 1020 ) ≈
4.34294 × 108 números primos..., es decir unos 434 millones de números. Aunque tuvieramos los
números primos y un computador muy veloz, al sumar los tiempos que requiere cada división
obtendríamos meses o años de cálculo. Más adelante veremos otras pruebas de primalidad.
Actualmente, la manera más eficiente de colar “primos pequeños”, es usar la criba1 de Eratóstenes.
Este es un algoritmo que permite “colar” todos los números primos menores que un número
natural dado n, eliminando los números compuestos de la lista {2, ..., n}. Es simple y razonablemente eficiente mientras no haya problemas de almacenamiento (este es su punto débil).
Primero tomamos una lista de números {2, 3, ..., n} y eliminamos de la lista los múltiplos de 2.
Luego tomamos el primer entero después de 2 que no fue borrado (el 3 ) y eliminamos de la
lista sus múltiplos, y así sucesivamente. Los números que permanecen en la lista son los primos
{2, 3, 5, 7, ...}.

1 Criba,

tamiz y zaranda son sinónimos. Una criba es un herramienta que consiste de un cedazo usada para limpiar el
trigo u otras semillas, de impurezas. Esta acción de limpiar se le dice cribar o tamizar.

22

DIVISIBILIDAD

Ejemplo 2.11
Primos menores que n = 10
Lista inicial
Eliminar múltiplos de 2
Resultado
Eliminar múltiplos de 3
Resultado

2
2
2
2
2

3
3
3
3
3

4
4

5
5
5

5
5
7
7
7

6 7 8 9 10
6
10
 7 8 9 
9
9

Primer refinamiento: Tachar solo los impares. Excepto el 2, los pares no son primos, así que
podríamos “tachar” solo sobre la lista de impares ≤ n :

s
{
n−3
{3, 5, 9, ..., } = 2i + 3 : i = 0, 1, ...
2
Para probar que esta lista efectivamente corresponde a los impares ≤ n, observemos que el úlq 3y
timo impar es n o n − 1. En cualquier caso, el último impar es 2 · n−
+ 3 pues:
2
q 3y
Si n es impar, n = 2k + 1 y n−
= k − 1 =⇒ 2(k − 1) + 3 = n.
2
q n −3 y
= k − 2 =⇒ 2(k − 2) + 3 = 2k − 1 = n − 1.
Si n es par, n = 2k y
2
Segundo refinamiento: Tachar de p2k en adelante. En el paso k− ésimo hay que tachar los
múltiplos del primo pk desde p2k en adelante. Esto es así pues en los pasos anteriores se ya se
tacharon 3 · pk , 5 · pk , ..., pk−1 · pk . Por ejemplo, cuando nos toca tachar los múltiplos del primo 7,
ya se han eliminado los múltiplos de 2, 3 y 5, es decir, ya se han eliminado 2 · 7, 3 · 7, 4 · 7, 5 · 7
y 6 · 7. Por eso iniciamos en 72 .

Tercer refinamiento: Tachar mientras p2k ≤ n . En el paso k− ésimo hay que tachar los múltiplos
del primo pk solo si p2k ≤ n. En otro caso, nos detenemos ahí. ¿Porque?. En el paso k− ésimo
tachamos los múltiplos del primo pk desde p2k en adelante, así que si p2k > n ya no hay nada
que tachar.
Ejemplo 2.12
Encontrar los primos menores que 20. El proceso termina cuando el cuadrado del mayor
número confirmado como primo es < 20.
a.) La lista inicial es {2, 3, 5, 7, 9, 11, 13, 15, 17, 19}
b.) Como 32 ≤ 20, tachamos los múltiplos de 3 desde 32 = 9 en adelante:
 17, 19}
{2, 3, 5, 7, 9, 11, 13,
15,
c.) Como 52 > 20 el proceso termina aquí: Primos < 20 : {2, 3, 5, 7, 11, 13, 17, 19}

2.3.1

Algoritmo e implementación.

En este contexto, a/b denota división entera, es decir, a/b es el cociente de dividir a y b.
Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

EJERCICIOS

23

a.) Como ya vimos, para colar los primos en el conjunto {2, 3, ..., n} solo consideramos los
impares:

{2i + 3 : i = 0, 1, ... J(n − 3)/2K} = {3, 5, 7, 9, ...}
b.) Por cada primo p = 2i + 3 (tal que p2 < n ), debemos eliminar los múltiplos impares de p
menores que n, a saber

(2k + 1) p = (2k + 1)(2i + 3), k = i + 1, i + 2, ...

Si k = i + 1 entonces el primer múltiplo en ser eliminado es p2 = (2i + 3)(2i + 3), como
debe ser.
Esto nos dice que para implementar el algoritmo solo necesitamos un arreglo (booleano) de
tamaño T(n − 3)/2U. En Java se pone “(n-3)/2” y en VBA se pone “(n-3)\2”.
El arreglo lo llamamos EsPrimo[i], i=0,1,...,(n-3)/2.Cada entrada del arreglo “EsPrimo[i]”
indica si el número 2i + 3 es primo o no.
Por ejemplo

EsPrimo[0] = true

pues n = 2 · 0 + 3 = 3 es primo,

EsPrimo[1] = true

pues n = 2 · 1 + 3 = 5 es primo,

EsPrimo[2] = true

pues n = 2 · 2 + 3 = 7 es primo,

EsPrimo[3] = false

pues n = 2 · 3 + 3 = 9 no es primo.

Si el número p = 2i + 3 es primo entonces i = ( p − 3)/2 y
EsPrimo[(p-3)/2] = true.

Si sabemos que p = 2i + 3 es primo, debemos poner
EsPrimo[((2k+1)(2i+3) - 3)/2] = false

pues estas entradas representan a los múltiplos (2k + 1)(2i + 3) de p. Observe que cuando
i = 0, 1, 2 tachamos los múltiplos de 3, 5 y 7; cuando i = 3 entonces 2i + 3 = 9 pero en este
momento esPrimo[3]=false así que proseguimos con i = 4, es decir, proseguimos tachando los
múltiplos de 11.

24

DIVISIBILIDAD

En resumen: Antes de empezar a tachar los múltiplos de p = 2i + 3 debemos preguntar si
esPrimo[i]=true.

Algoritmo 2.1: Criba de Eratóstenes
Datos: n ∈ N, n > 3
Salida: Primos entre 2 y n
1 máx = ( n − 3) /2 ;
2 boolean esPrimo[i ], i = 1, 2, ...,máx;
3 for i = 1, 2, ..., máx do
4
esPrimo[i ] =True;
5
6
7
8
9
10
11

i = 0;
while (2i + 3)(2i + 3) ≤ n do
k = i + 1;
if esPrimo(i) then
while (2k + 1)(2i + 3) ≤ n do
esPrimo[((2k + 1)(2i + 3) − 3)/2] =False;
k = k + 1;
i = i + 1;

12
13
14
15
16
17

Imprimir;
Imprima 2, 3;
for j = 1, 2, ..., máx do
if esPrimo[ j] =True then
Imprima 2j + 3

Nota: Es conveniente poner (2i + 3) ≤ n/(2i + 3) en vez de (2i + 3)(2i + 3) ≤ n, para no operar
con números innecesariamente grandes.

Hay variaciones de la criba de Eratóstenes muy eficientes ([15], [14],[20]). En la mayoría de las
referencias elementales sobre esta criba no se eliminan los pares posiblemente por mantener la
simplicidad y porque para estudios asintóticos no hay necesidad. La tabla que sigue muestra la
diferencia en tiempos de ejecución (en segundos) en una implementación en Mathematica2

Tiempo en segundos (en Mathematica.).
n
Criba sin pares Criba con pares
80000
1.10807
4.30427
90000
1.40809
5.49234
100000
1.67611
6.64842

Implementación en VBA Excel. El código que sigue hace la lectura de datos en un cuaderno
como el que sigue. n se lee en la celda B7 y el número de columnas, para imprimir en formato
de tabla, se lee en la columna C7. Se imprime desde la celda B9. La macro Eratostenes(n, 9,
2 Esta

implementación en Mathematica se espera que sea lenta porque es un lenguaje interpretado.

EJERCICIOS

25

criba los primos e imprime. En este cuaderno la macro se ejecuta desde
un botón (el cual se agrega desde la ‘ficha del programador’).
2, CantidadColumnas)

[Descargar]

Option Explicit
Public CantidadColumnasAnt As Integer
’Principal: Lectura de datos y llamada a la macro
Private Sub CommandButton1_Click()
Dim n, CantidadColumnas
n = Cells(7, 2)

’Lee n en celda B7

CantidadColumnas = Cells(7, 3) ’Lee la cantidad de columnas en C7
If n < 2 Then
MsgBox ("El n\’umero digitado debe ser un n\’umero natural mayor que 3")
Call LimpiaCeldas(9, 2, CantidadColumnas)
ElseIf CantidadColumnas < 0 Or CantidadColumnas > 60000 Then
MsgBox ("El n\’umero de columnas debe ser mayor a 0 y menor a 60 000")
Call LimpiaCeldas(9, 2, CantidadColumnasAnt)
Else
Call Eratostenes(n, 9, 2, CantidadColumnas)
End If
End Sub
Sub Eratostenes(n, fil, col, Optional CantidadColumnas As Variant)
Dim i, j, k, pos, l
Dim max As Integer
Dim esPrimo() As Boolean
If CantidadColumnas = "" Or CantidadColumnas = 0 Then
CantidadColumnas = 10
End If

Call LimpiaCeldas(fil, col, CantidadColumnasAnt) ’Limpia celdas
CantidadColumnasAnt = CantidadColumnas
’**Criba---------------------------------------------------------*

26

DIVISIBILIDAD

max = (n - 3) \ 2 ’divisi\’on entera
ReDim esPrimo(max + 1)

For i = 0 To max
esPrimo(i) = True
Next i
j = 0
While (2 * j + 3) <= n\(2 * j + 3)
k = j + 1
If esPrimo(j) Then
While (2 * k + 1) * (2 * j + 3) <= n
pos = ((2 * k + 1) * (2 * j + 3) - 3) \ 2
esPrimo(pos) = False
k = k + 1
Wend
End If
j = j + 1
Wend
’**---------------------------------------------------------------*
’**Imprimir en la hoja Excel--------------------------------------*
Cells(fil, col) = 2
’Hay dos casos especiales
If CantidadColumnas = 1 Then
Cells(fil + 1, col) = 3 : k=2 : j=0
ElseIf CantidadColumnas = 2 Then
Cells(fil, col + 1) = 3 : k=1 : j=0
Else
Cells(fil, col + 1) = 3 : k=0 : j=2
End If
For i = 1 To max
If esPrimo(i) Then
Cells(fil + k, col + j) = 2 * i + 3
If CantidadColumnas <> 1 Then
k = k + j \ (CantidadColumnas - 1)
j = j + 1
j = j Mod CantidadColumnas
Else
k = k + 1
End If
End If
Next i
End Sub
Private Sub LimpiaCeldas(fil, col, nc)
Dim k, j
k = 0
While LenB(Cells(fil + k, col)) <> 0

EJERCICIOS

27

For j = 0 To nc
Cells(fil + k, col + j) = ""
Next j
k = k + 1
Wend
End Sub

2.4

Máximo común divisor

Si a, b son enteros no ambos nulos, entonces d es un divisor común de a y b si d| a y d|b.
Denotamos con Da al conjunto de divisores de a y con Db el conjunto de divisores de b. Estos
conjuntos no son vacíos pues al menos 1 ∈ Da y 1 ∈ Db . El máximo común divisor común de a
y b es el más grande entero positivo del conjunto Da ∩ Db .

Ejemplo 2.13
Como D−3 = {−3, −1, 1, 3} y D6 = {±6, ±3, ±2, ±1}, entonces Da ∩ Db = {−3, 3, −1, 1}.
Por tanto, el máximo común divisor de 3 y 6 es 3.

Antes de continuar, una pregunta: ¿porqué a y b no pueden ser ambos nulos?
Una definición más técnica y apropiada para el desarrollo teórica es,

Definición 2.3 (Máximo Común Divisor).
Sean a, b enteros con al menos uno de los dos diferente de cero. El máximo común divisor de a
y b, denotado mcd ( a, b), es el entero positivo d que satisface:
a.) d| a y d|b
b.) Si c| a y c|b, entonces c|d
Si mcd( a, b) = 1 se dice que a y b son relativamente primos o simplemente “coprimos”.

Ejemplo 2.14
mcd (3, 6) = mcd (−3, 6) = mcd (3, −6) = 3.

Ahora establecemos algunas propiedades útiles. Otras propiedades serán enunciadas más adelante, cuando tengamos más herramientas para hacer las pruebas.

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

28

DIVISIBILIDAD

Teorema 2.8
Sean a, b ∈ Z, no ambos nulos.
a.) mcd ( a, 0) = | a| si a 6= 0
b.) mcd ( a, b) = mcd (| a|, |b|)
c.) Si d = mcd ( a, b), entonces mcd ( a/d, b/d) = 1
d.) Si d = mcd ( a, b), entonces mcd ( a, b − na) = d con n ∈ Z

Prueba: : Para probar a.) sea d = mcd ( a, 0). Como | a| | a y | a| |0, entonces | a| |d. Pero d| | a| =⇒
d ≤ | a |. ∴ d = | a |.
Para probar b.) sea d = mcd( a, b) y d1 = mcd(| a|, |b|). Como d| a ∧ d|b =⇒ d| | a| ∧ d| |b| =⇒
d|d1 . Ahora como d1 | | a| ∧ d1 | |b| =⇒ d1 | a ∧ d1 | b =⇒ d1 |d. ∴ d = d1 por ser ambos positivos.
Para probar c.), sea d0 = mcd ( a/d, b/d), entonces hay enteros k, k0 tales que a/d = kd0 y
b/d = k0 d0 . Por tanto, a = dkd0 y b = dk0 d0 , es decir, dd0 | a ∧ dd0 |b =⇒ dd0 ≤ d por definición; entonces d0 es un entero positivo ≤ 1, es decir, d0 = 1.
Para probar d.), sea d1 = mcd( a, b − na). Como d| a ∧ d|b =⇒ d|(b − na) por el teorema 2.1 a.).
Entonces d ≤ d1 . Como d1 | a =⇒ d1 |na. Así d1 |na ∧ d1 |(b − na) =⇒ d1 |b por el teorema 2.1 b.).
Entonces d1 ≤ d. ∴ d = d1

Nota. El orden importa. En el ejercicio 2.9 se pide dar un par de ejemplos que muestren que en
general, si d = mcd ( a, b), entonces d 6= mcd ( a, a − nb) con n ∈ Z
Ejemplo 2.15
Muestre que si p es primo, mcd ( a, p) = p o mcd ( a, p) = 1.
Solución: Si d = mcd ( a, p), en particular d| p, por tanto, como p es primo, d = 1 ∨ d = p.

Ejemplo 2.16
Muestre que si n > 1, p es primo y p|(n2 + 1), entonces mcd ( p, n) = 1.
Solución: mcd ( p, n) = 1 ∨ mcd ( p, n) = p. Si mcd ( p, n) = p entonces p|n =⇒ p|n2 y
como p|(n2 + 1) entonces p|1; contradicción. ∴ mcd ( p, n) = 1.

EJERCICIOS

29

Ejemplo 2.17
Sea d = mcd ( a, b). Si a = kd y b = k0 d, entonces mcd (k, k0 ) = 1.
Solución: El teorema 2.8 c.) dice que mcd ( a/d, b/d) = 1, es decir, mcd (k, k0 ) = 1.
En la práctica necesitamos calcular el máximo común divisor de varios números. Esto no es
problema, el siguiente teorema nos dice que el máximo común divisor de varios números se
puede calcular de la misma manera en la que sumamos: De dos en dos.

Teorema 2.9
Sean a1 , a2 , .., an ∈ Z+ , n ≥ 3. Entonces mcd ( a1 , a2 , ..., an ) = mcd ( a1 , mcd ( a2 , ..., an )).
Prueba: Sea d = mcd ( a1 , a2 , ..., an ) y d1 = mcd ( a1 , d2 ) con d2 = mcd ( a2 , ..., an ). Como d| a1 , d| a2 , ..., d| an ,
entonces d|d2 y por tanto d|d1 . Como d1 | a1 y d1 |d2 entonces d1 | a1 , ∧ d1 | a2 , ..., d1 | an (por transitividad). Por tanto d1 |d ∴ d = d1 .

Corolario 2.3 Sean a1 , ..., an ∈ Z no todos nulos, si

= d2 , 

= d3 , 
=⇒ dn = mcd ( a1 , ..., an ).

...


mcd (dn−1 , an ) = dn ,
mcd ( a1 , a2 )
mcd (d2 , a3 )

Ejemplo 2.18
mcd (3, 6, 12) = mcd ( mcd (3, 6), 12) = mcd (3, 12) = 3.

2.5

Algoritmo de Euclides I.

El algoritmo de Euclides se basa en la aplicación sucesiva del siguiente lema
Lema 2.1
Sean a, b, q, r ∈ Z tales que a = bq + r con b > 0 y 0 ≤ r < b. Entonces mcd ( a, b) = mcd (b, r ).
Prueba: Según el teorema 2.8 d.), mcd (b, a) = mcd (b, a − bq) = mcd (b, r )

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

30

DIVISIBILIDAD

Este resultado lo podemos usar para obtener un algoritmo para calcular el máximo común
divisor de dos números.

Algoritmo de Euclides. Sean a y b números naturales, b 6= 0. Aplicando el teorema de
la división se obtiene una sucesión finita a, r0 = b, r1 , r2 , ..., rn , 0 definida por
a

= r0 q1 + r1 ,

0 ≤ r1 < r0

r0

= r1 q2 + r2 ,

0 ≤ r2 < r1

r1

= r2 q3 + r3 ,

0 ≤ r3 < r2

r n −2

..
.
=

0 ≤ r n < r n −1

r n −1

= r n q n +1 + 0

r n −1 q n + r n ,

rn+1 = 0.

El último término es rn = mcd ( a, b).

Correctitud del algoritmo. Aplicando el teorema de la división obtenemos una sucesión decreciente de residuos 0 ≤ ... < rk < rk−1 < ... < r1 < r0 = b. La sucesión es finita pues entre 0 y r0 6= 0
solo puede haber un número finito de enteros. Por tanto algún residuo debe ser cero (sino, se
podría aplicar el teorema de la división indefinidamente y tendríamos una sucesión infinita de
enteros entre 0 y b , lo cual es imposible.) Si b| a, entonces r1 = 0 y r0 sería el mínimo residuo
positivo. En general, debe haber un residuo mínimo rn > 0 y rn+1 = 0
De acuerdo al lema (2.1) tenemos que
mcd ( a, b)

=

mcd ( a − r0 q, r0 )

=

mcd (r1 , r0 )

=

mcd (r1 , r0 − r1 q2 )

=

mcd (r1 , r2 )

=

mcd (r1 − r2 q2 , r2 )

=
..
.

mcd (r3 , r2 )

=

mcd (rn−1 , rn )

=

mcd (rn , 0) = rn

Ejemplo 2.19
Vamos a aplicar el algoritmo de Euclides para calcular mcd (8, 2) y mcd (78, 32).

EJERCICIOS

a.) mcd (8, 2) = 2. En efecto;
8

=

Así,

2.5.1

2·4+0
r0 = 2 y r1 = 0.

31

b.) mcd (78, 32) = 2. En efecto;
78

=

32 · 2 + 14

32

=

14 · 2 + 4

14

=

4·3+ 2

4

=

2·2+0

Algoritmo e implementación.

Recordemos que mod( a, b) denota el resto de la división de a por b. En este algoritmo, en cada
paso r = mod (rn+1 , rn ) donde rn+1 = c es el dividendo actual y rn = d es el divisor actual.
Luego se actualiza rn+1 = d y d = r. El proceso continúa mientras d no se anule.
Algoritmo 2.2: Máximo común divisor
Datos: a, b ∈ Z. b 6= 0
Salida: mcd ( a, b)
1 c = | a |, d = | b | ;
2 while d 6 = 0 do
3
r = mod(c, d);
4
c = d;
5
d = r;
6

return mcd ( a, b) = |c|;

Implementación en VBA Excel.

Function mcd(a, b)
Dim c As Long, d As Long, r As Long ’max = 2 147 483 647
c = Abs(a)
d = Abs(b)
While d <> 0
r = c Mod d ’residuo entre (c,d)
c = d
d = r
Wend
mcd = Abs(c)
End Function

Para calcular el mcd de una lista de enteros que están en una columna de una hoja de Excel, se
puede seleccionar la lista con el ratón y convertir la lista a un vector de enteros. Luego aplicamos
el algoritmo.
Private Sub mcdLista()
Dim n, i

32

DIVISIBILIDAD

Dim Rango As Range
Dim Lista() As Long
’Seleccionar rango y convertir a Array
Set Rango = Selection
n = Rango.Rows.Count ’Solo filas
If n <= 1 Then
MsgBox ("Debe seleccionar 2 o m\’as enteros")
Exit Sub
End If
ReDim Lista(n)
For i = 1 To n ’Arreglos inician en cero, rangos en 1
Lista(i) = Rango(i, 1)
Next i
Cells(7, 6) = mcd_Lista(Lista)
End Sub
’Los arreglos se pasan solo por referencia
Function mcd_Lista(ByRef L() As Long) ’ByRef = por referencia
Dim c As Long
Dim i, n
c = 0
n = UBound(L) ’tamano del arreglo

For i = 1 To n
If c = 0 Then
c = mcd(c, L(i))
Else
c = Abs(c) * Abs(L(i)) / mcd(c, L(i))
End If
Next i
mcd_Lista = Abs(c)
End Function

2.6

Algoritmo Extendido de Euclides.

El siguiente teorema establece la llamada “Identidad de Etienne Bezout” aunque el resultado lo
descubrió primero el francés Claude Gaspard Bachet de Méziriac (1581-1638).

Teorema 2.10 (Identidad de Bézout).
Si a, b son dos enteros no ambos cero, existen s, t ∈ Z (posiblemente no únicos) tales que
sa + tb = mcd ( a, b)
Prueba: Sea A el conjunto de combinaciones lineales enteras de a y b, A = {u a + v b : u, v ∈ Z}.
Este conjunto tiene números positivos, negativos y el cero. Sea m = a x + b y el más pequeño
Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

EJERCICIOS

33

entero positivo en A.
¿m divide a a y a b?. Mmmmm, supongamos que a = mq + r con 0 ≤ r < m. Entonces,
0 ≤ r = a − mq = a − ( a x + b y)q = (1 − qx ) a + (−qy)b
Así, r es una combinación lineal de a y b, es decir, r ∈ A. Pero 0 ≤ r < m, así que la única
posibilidad es que r = 0 por ser m el mínimo entero positivo en A.
Luego, a = mq y m| a. De manera análoga podemos establecer que m|b. Sea d = mcd ( a, b).
Como m es común divisor de a y b, entonces d ≥ m. Pero, como a = k1 d y b = k2 d entonces
m = ax + by = ( xk1 + yk2 )d > 0, por lo tanto m ≥ d. Así que m = d.

Los siguientes corolarios son sumamente útiles,
Corolario 2.4 El mcd ( a, b) es el más pequeño entero positivo de la forma sa + tb; s, t ∈ Z. En particular, mcd ( a, b) = 1 si y sólo si existen x, y ∈ Z tal que ax + by = 1
Prueba: Ejercicio.

Corolario 2.5 Si a|bc y mcd ( a, b) = 1 entonces a|c.
Prueba: Como mcd ( a, b) = 1, existen x, y ∈ Z tal que xa + by = 1. Multiplicando por c a ambos
lados,
acx + bcy = c
Como a| ac y a|bc entonces a|( acx + bcy).

∴ a|c.

Ejemplo 2.20

Si n es entero positivo, verifique que

n+2
es irreducible.
n+1

Solución: Si n > 0, n + 2 − (n + 1) = 1; entonces, según el corolario (2.4), mcd (n + 2, n +
1) = 1.
Calcular t y s. La ecuación sa + tb = mcd ( a, b) no tiene solución única para s, t enteros. Se
puede obtener una solución despejando los residuos, en el algoritmo de Euclides, y haciendo
una sustitución hacia atrás.
Consideremos la sucesión r1 , r2 , ..., rn del algoritmo de Euclides. Todos estos residuos son una
combinación lineal entera de a y b : En efecto, como r1 = a − bq0 y b = r1 q1 + r2 entonces r2
es combinación lineal de a y b. Como r1 y r2 son combinaciones lineales de a y b y como
r1 = r2 q2 + r3 entonces r3 es combinación lineal de a y b. Continuando de esta manera, como
ri−1 y ri−2 son combinaciones lineales de a y b y como ri−2 = ri−1 q2 + ri (i = 2, ..., n), entonces
rn es combinación lineal (mínima) de a y b.

34

DIVISIBILIDAD

Ejemplo 2.21
mcd (78, 32) = 2. De acuerdo a la identidad d Bézout, existen s, t ∈ Z tal que
s · 78 + t · 32 = 2. En este caso, una posibilidad es 7 · 78 − 17 · 32 = 2, es decir s = 7 y
t = −17.
s y t se pueden obtener así: Primero despejamos los residuos en el algoritmo de
Euclides de abajo hacia arriba, iniciando con el máximo común divisor. Luego hacemos
sustitución hacia atrás, sustituyendo las expresiones de los residuos. En cada paso se ha
subrayado el residuo que se sustituye

2
78
32
14
4

=
=
=
=

32 · 2 + 14
14 · 2 + 4
4·3+2
2·2+0

−→ 14 = 78 − 32 · 2
−→ 4 = 32 − 14 · 2
−→ 2 = 14 − 4 · 3

_↑
_↑

=⇒

=
=
=
=
=

14 − 4 · 3
14 − (32 − 14 · 2)3
14 · 7 − 32 · 3
(78 − 32 · 2)7 − 32 · 3
7 ·78 + − 17 ·32
|{z}
|{z}
s

t

Ejemplo 2.22
Calcular s, t ∈ Z tal que s · −8 + t · 22 = mcd (−8, 22).
Solución:
Calcular mcd (−8, 22)

−8
22
14
8
6

2.6.1

=
=
=
=
=

−1 · 22 + 14
1 · 14 + 8
1·8+6
1·6+2
3·2+0

Cálculo de s y t
2

=
=
=
=
=
=
∴

8−6
8 − (14 − 8)
8 · 2 − 14
8 · 2 − (−8 + 22)
8 · 3 − 22
−8 · −3 + −1 · 22
s = −3 y t = −1

Algoritmo e implementación.

En este contexto, a/b denota el cociente de dividir a por b. El agoritmo implementa la sustitución hacia atrás que vimos antes.

EJERCICIOS

35

Algoritmo 2.3: Algoritmo Extendido de Euclides
Datos: a, b enteros no ambos nulos
Salida: mcd ( a, b), t y s
1 c = | a |, d = | b | ;
2 c1 = 1, d1 = 0 ;
3 c2 = 0, d2 = 1 ;
4 while d 6 = 0 do
q = c/d,
r = c − qd,
r1 = c1 − qd1 , r2 = c2 − qd2 ,
c = d,
c1 = d1 ,
c2 = d2 ,
5
d = r,
d1 = r1 ,
d2 = r2 ,
6

return mcd (a,b) = |c|, s = c1 /sgn( a) · sgn(c), t = c2 /sgn(b) · sgn(c) ;


Recordemos que sgn( x ) =

1 si x ≥ 0
.
−1 si x < 0

Validez del algoritmo. La validez de este algoritmo se establece probando que en todo el ciclo
While, se tiene

c

= c1 | a | + c2 | b |

d

= d1 | a | + d2 | b |

(2.1)

Al final, cuando d = 0, obtenemos s y t usando los datos en (2.1).

Como | x | = x/sgn( x ) = x · sgn( x ), entonces

|c| =
=

c1
c2
| a| +
|b|
sgn(c)
sgn(c)
c1
c2
a+
b
sgn(c) · sgn( a)
sgn(c) · sgn(b)
|
|
{z
}
{z
}
s

t

Implementación en VBA Excel. Primero debemos implementar una función signo acorde con
nuestra definición. Luego implementamos el algoritmo tal cuál.

[Descargar]

36

DIVISIBILIDAD

Option Explicit
Private Sub Calcular_Click()
Dim a, b
Dim vector() As Long
a = Cells(8, 2) : b = Cells(8, 3)
vector = EuclidesExtendido(a, b)
Cells(8, 4) = vector(1) : Cells(8, 5) = vector(2) : Cells(8, 6) = vector(3)
End Sub
Function signo(x)
If x < 0 Then
signo = -1
Else signo = 1
End If
End Function
Dim mcdst() As Long
Dim c, c1, c2, d, d1, d2, q, r, r1, r2
ReDim mcdst(3)
Function EuclidesExtendido(a, b) As Long()
c = Abs(a) : d = Abs(b)
c1 = 1 : c2 = 0
d1 = 0 : d2 = 1
While d <> 0
q = c \ d
r = c - q*d
r1 = c1 - q*d1
r2 = c2 - q*d2
c = d : c1 = d1 : c2 = d2
d = r : d1 = r1 : d2 = r2
Wend
mcdst(1) = Abs(c)

’mcd(a,b)

mcdst(2) = c1 * signo(a) * signo(c) ’s
mcdst(3) = c2
’t
EuclidesExtendido= mcdst()
End Function

2.7

Ecuaciones Diofánticas lineales.

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

EJERCICIOS

37

Consideremos el problema de resolver ax + by = c en enteros. Aquí a, b, c son dados y se debe
determinar x, y ∈ Z. Las condiciones de existencia de soluciones y el método para obtenerlas se
basa en el algoritmo extendido de Euclides.

Ejemplo 2.23
Consideremos la ecuaciones en enteros 2x + 3y = 2 y 6x − 3y = 1 Gráficamente, las soluciones enteras corresponden a los pares ( x, y) ∈ Z × Z contenidos en la representación
gráfica de cada recta.
En el caso de 2x + 3y = 2, en la figura (2.1), se puede observar que
(−5, 4), (−2, 2), (1, 0), (4, −2), (7, −4) son algunas soluciones. En el caso de la recta
6x − 3y = 1, no se observan soluciones; ¿tendrá alguna?

6
4
2
-5

5

Figura 2.1. Algunas soluciones enteras de la ecuación 2x + 3y = 2.

Teorema 2.11
La ecuación diofántica lineal ax + by = c tiene soluciones x, y ∈ Z si y sólo si mcd ( a, b)|c

Prueba: Sea d = mcd ( a, b)
“=⇒ ”: Si existen x, y ∈ Z tal que c = ax + ay, entonces d|c pues d| a y d|b.
“⇐= ”: Si d|c entones c = kd. Como podemos determinar, usando el algoritmo extendido de Euclides, s, t ∈ Z tal que d = sa + tb, entonces c = kd = (ks) a + (kt)b y una solución de la ecuación
diofántica lineal sería x = ks y y = kt.

Ejemplo 2.24
La ecuación en enteros 2x + 3y = 2 tiene solución pues mcd (2, 3) = 1 y 1|2. La ecuación
en enteros 6x − 3y = 1 no tiene soluciones enteras pues mcd (6, 3) = 3 y 3 - 1.

38

DIVISIBILIDAD

Ejemplo 2.25
Calcule una solución para la ecuación en enteros −8x + 22y = 20
Solución: En el ejemplo (2.21) encontramos que 2 = mcd (−8, 22) y que 2 = −3 · −8 +
−1 · 22. Ahora, como 20 = 2 · 10,
2 = −3 · −8 + −1 · 22 =⇒ 20 = −30 · −8 + −10 · 22.
Así, una solución de la ecuación diofántica es x = −30 ∧ y = −10 .

Solución general. La solución general se establece al estilo de las ecuaciones diferenciales y el
álgebra lineal: Primero se busca la solución de la ecuación homogénea ax + by = 0 y la solución
general de la ecuación ax + by = c se expresa usando esta solución.

Teorema 2.12
Sea d = mcd ( a, b). Las soluiones de la ecuación diofántica lineal homogénea ax + by = 0 son de
la forma,
b
a
x = t,
y = − t con t ∈ Z.
d
d

a
b
y
son enteros. Sustituyendo directamente x e y se observa que efectid
d
vamente son soluciones de la ecuación homógenea para cualquier t ∈ Z.

Prueba: Claramente

Ahora hay que mostrar que cualquier otra solución x, y ∈ Z tiene esa forma. Sea a = kd y
b = k0 d. ax + by = 0 =⇒ ax = −by =⇒ k x = −k0 y. Esto último dice que k|(−k0 y). Ahora
b
a
como mcd (k , k0 ) = 1, entonces por el corolario 2.5, k|(−y). Por tanto y = − t y x = t, t ∈ Z.
d
d

Teorema 2.13
Sea d = mcd ( a, b). Si la ecuación diofántica lineal ax + by = c tiene una solución x = x0 , y = y0 ,
b
a
entonces la solución general es x = x0 + t, y = y0 − t con t ∈ Z.
d
d

Prueba: Sean x = x0 , y = y0 , solución de ax + by = c. Tenemos,



ax + by = c



ax0 + by0 = c


Ecuación homogénea
 x − x0 = (b/d) t =⇒ x = x0 + (b/d)t
}|
{
z
=⇒ a( x − x0 ) + b(y − y0 ) = 0 =⇒

y − y0 = (− a/d) t =⇒ y = y0 − ( a/d)t

EJERCICIOS

39

Ejemplo 2.26
Consideremos la ecuación en enteros 2x + 3y = 2. Como una solución particular es
( x0 , y0 ) = (1, 0), entonces la solución general es x = 1 + 3t, y = 0 − 2t, t ∈ Z.
k
·s
−4
−3
−2
−1
0
1
2
3
4
·s

6
4
2
5
-5
5

Figura 2.2. Soluciones enteras de la ecuación
2x + 3y = 2.

2.8

x

y

−11
−8
−5
−2
1
4
7
10
13

8
6
4
2
0
−2
−4
−6
−8

Teorema fundamental de la aritmética

Antes de enunciar el teorema fundamental de la aritmética, veamos un ejemplo muy familiar
Ejemplo 2.27
Podemos factorizar 36 como un producto de primos: En cada paso buscamos el divisor
primo más pequeño:

36

= 2 · 18
= 2·2·9
= 2·2·3·3

El método que usamos es el procedimiento usual de la escuela. Obtener la factorización
prima de un número n dividiendo por los primos ≤ n

36

84

18

2

9

2

42

2

21

2

3

3

7

3

1

3

1

7

36 = 22 · 32

84 = 22 · 3 · 7

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

40

DIVISIBILIDAD

Lema 2.2 (Lema de Euclides).
Si p es primo y p| ab entonces p| a o p|b.
Prueba: Supongamos que p| ab pero p - a. En este caso mcd ( p, a) = 1 por ser p primo (el único
factor en común sería p o 1), entonces por el corolario 2.5, concluimos que p|b.
Teorema 2.14 (Fundamental de la aritmética).
Todo número natural compuesto n > 1 se puede factorizar de manera única como
β

β

β

n = p1 1 p2 2 · spk k
donde p1 , . . . , pn son primos distintos y β 1 , . . . , β n son enteros positivos. Esta factorización se
llama la factorización prima de n.
Prueba: La prueba se hace por inducción completa. El resultado es cierto para n = 2. Supongamos ahora que el resultado es cierto para n = 3, 4, ..., k. Hay que probar que es cierto para
k + 1. Si k + 1 es primo, listo. Si k + 1 es compuesto, entonces existen a, b ∈ Z, 1 < a ≤ b < k + 1,
tal que k + 1 = ab. Pero, por hipótesis de inducción a y b factorizan como producto de primos,
así que k + 1 también factoriza como producto de primos, a saber, los factores de a y b.
Unicidad: La prueba es por contradicción. Supongamos que n = r1 r2 · sru = q1 q2 · sqv donde
todos los ri0 s y los q0j s son primos, r1 ≤ r2 ≤ ... ≤ ru y q1 ≤ q2 ≤ ... ≤ qv . Si cancelamos los primos
iguales que hay en ambos lados nos queda
ri1 ri2 · srin = q j1 q j2 · sq jm (todos distintos)
entonces
ri1 (ri2 · srin ) = q j1 q j2 · sq jm ,
es decir, ri1 divide a q j1 q j2 · sqim , entonces por el lema de Euclides, ri1 divide a algún q jt , por
tanto ri1 = q jt : Contradicción pues los asumimos distintos.
Nota: Observe que el número 1 no es ni primo ni compuesto. Esto garantiza la unicidad de la
factorización.

Máximo común divisor y Mínimo común Múltiplo.

Definición 2.4
Si a, b ∈ Z+ entonces el mínimo común múltiplo de a y b es el más pequeño entero m > 0 tal
que a|m y b|m. Se escribe mcm ( a, b) = m

Para el teorema que sigue necesitamos aclarar la notación. Necesitamos que dos números tengan los mismos factores primos en una factorización por conveniencia; lo que hacemos es que
completamos con potencias p0k . Por ejemplo, si

EJERCICIOS

41

a = 22 · 33 · 74 · 192

b = 2 · 32 · 112 ,
entonces la factorización por conveniencia sería
a = 22 · 33 · 74 · ·110 · 192

b = 2 · 32 · 70 · 112 · 190 .

Teorema 2.15
Si a, b son enteros positivos, supongamos que
k

a = ∏ pi i , αi ≥ 0
α

i =1
k

b = ∏ pi i , β i ≥ 0
β

i =1

Donde αi y β i podrían ser cero con el propósito de completar la factorización prima de a con
los primos de la factorización prima de b y viceversa (se completan con potencias p0k ). Entonces,
k

mcd ( a, b) = ∏ pi i , γi = mín {αi , β i }, i = 1, ..., k
γ

i =1
k

mcm ( a, b) = ∏ pi i , δi = máx{αi , β i }, i = 1, ..., k
δ

i =1

En particular mcd ( a, b) mcm ( a, b) = ab, es decir
mcm ( a, b) =

ab
.
mcd ( a, b)

Prueba: Ejercicio.
Aunque para números pequeños, el método de la factorización prima sirve para calcular mcd (n, m)
y el mcm (n, m), en general, es computacionalmente ineficiente, por el costo de obtener esta factorización. Un algoritmo más adecuado está basado en el teorema (2.5).

Ejemplo 2.28
A partir de la factorización prima de dos números a, b podemos calcular el mcd ( a, b) y
el mcm ( a, b).

42

DIVISIBILIDAD

36
18

84
2

9

2

3

3

1

3

36 = 22 · 32 · 70

Luego, mcd (36, 84) =

22

· 3 · 70

42

2

21

2

7

3

1

7

84 = 22 · 3 · 7

= 12 y el mcm (36, 84) = 22 · 32 · 7 = 252.

Ejemplo 2.29 (Suma de fracciones).

Realizar la suma

5
7
3
+
+ .
36 84 4

Solución: Como mcm (36, 84, 4) = 252, entonces

5
7
3
+
+
36 84 4

=
=
=

7·5
3·7
63 · 3
+
+
252
252
252
245
35
=
252
36

Para el mínimo común múltiplo de una lista de números tenemos un teorema similar al teorema
del máximo común divisor.

Teorema 2.16
mcm ( a1 , a2 , ..., an ) = mcm ( a1 , mcm ( a2 , ..., an )).

Prueba: Ejercicio.
En la sección que trata sobre el “teorema chino del resto” vamos a necesitar los dos corolarios
que siguen y, en su momento, haremos referencia a ellos.

Corolario 2.6 Si m1 , m2 , ..., mk son primos relativos dos a dos, entonces
mcm (m1 , m2 , ..., mk ) = m1 · m2 · smk .
Prueba: Ejercicio.
Corolario 2.7 Si m1 , m2 , ..., mk , a ∈ Z+ y si mi | a, i = 1, 2, ..., k; entonces
mcm (m1 , m2 , ..., mk )| a.
Prueba: Por inducción completa.

EJERCICIOS

43

La afirmación es claramente correcta para k = 1 y k = 2. Asumamos que es correcta para 1, 2, ..., t.
Ahora, supongamos que mi | a, i = 1, 2, . . . , t, t + 1 entonces mcd (m1 , m2 , . . . , mt )| a por la hipótesis de inducción y mt+1 | a, pero entonces los dos números mcd (m1 , m2 , . . . , mt ) y mt+1 dividen a, así que la hipótesis de inducción nos dice que mcd ( mcd (m1 , m2 , . . . , mt ), mt+1 )| a, i.e.
mcm (m1 , m2 , ..., mk )| a por el teorema (2.16).
Ejemplo 2.30
El entero 290290 es divisible por 10, 77 , y 13. Como mcd (10, 77) = 1, mcd (10, 13) = 1
y mcd (77, 13) = 1; entonces mcm (10, 77, 13) = 10 · 77 · 13 = 10010 y 10010 | 290290.

Ejemplo 2.31
Muestre que si p = 4k + 1 y p = 3k0 + 1 entonces hay un k00 ∈ Z tal que p = 12k00 + 1
Solución: Como mcd (4, 3) = 1, 4|( p − 1) y 3|( p − 1), entonces mcm (3, 4) = 12 y
12|( p − 1), es decir, hay un k00 ∈ Z tal que p − 1 = 12k00 .

EJERCICIOS
2.8

Muestre que los divisores de n ocurren en pares, es decir, si d|n con n = kd, entonces k|n.

2.9 De un par de ejemplos que muestren que en general, si d = mcd ( a, b), entonces d 6=
mcd ( a, a − nb) con n ∈ Z
2.10

Muestre que mcd ( ab, m)| mcd ( a, m) mcd (b, m) (Use Id. Bezout).

2.11

Muestre que mcd ( a, b) = 1 entonces mcd ( a, m) mcd (b, m) = mcd ( ab, m)

2.12

Probar el corolario 2.4.

2.13

Muestre que si mcd ( a, b) = 1 y si mcd ( a, c) = 1,

2.14 Muestre que si mcd ( a1 , m) = 1, mcd ( a2 , m) = 1, . . . , mcd ( ak , m) = 1 entonces mcd ( a1 ·
a2 · sak , m) = 1.
2.15 Muestre, usando la identidad de Bezout, que si mcd ( a, b) = d y si a = k1 d y b = k2 d,
entonces mcd (k1 , k2 ) = 1
2.16

Muestre que si d = mcd ( a, b) y si ra + sb = d, entonces mcd (r, s) = 1.

2.17

Muestre que si am + bn = h entonces mcd ( a, b)|h

44

DIVISIBILIDAD

2.18

Muestre que la ecuación diofántica ax + by = h tiene solución solo si mcd ( a, b)|h

2.19

Resuelva la ecuación diofántica 24 = 365x + 1876y

2.20 Sea p un número primo. Determinar todos los enteros k ∈ Z tales que
ral. Ayuda: Si p2 = ab =⇒ ( a = p ∧ b = p) ∨ ( a = p2 ∧ b = 1)

p

k2 − kp es natu-

2.21 Sean q1 , . . . , qn y pi todos números primos distintos. Use inducción matemática para probar que si pi |q1 q2 · sqn entonces pi = q j para algún j ∈ 1, 2, ..., n.
2.22

Sea p primo, si p| an =⇒ p| a

2.23 Muestre que si p es primo, entonces
√
suponga n p = a/b con mcd ( a, b) = 1.

√
n

p no es racional. Ayuda: Por contradicción,

2.24

Sean mcd ( a, b) = 1 y p primo, entonces p - mcd ( an , bn ).

2.25

Muestre que si mcd ( a, p) = 1 con p primo, entonces mcd ( a, ps ) = 1, con s > 0.

2.26 Sean m y n son primos relativos. Muestre que si mn = ak , k ≥ 0; entonces existe x, y ∈ Z
tal que m = x k y n = yk . Ayuda: Use la descomposición en factores primos de cada uno de los
números.
2.27

Consideremos la descomposición prima n = ∏ik pi i . ¿ mcm ( p1 1 , . . . , pk k ) = n?
α

α

α

2.28 Supongamos que los enteros m y n son primos relativos. Muestre que si d|mn, entonces
∃ b, c únicos tal que d = bc con b|m y c|n.
2.29

Si 4| p − 3 y 3| p − 1, muestre que 12| p + 1.

2.30

Sea n > 1 y p el más pequeño divisor primo de n. Muestre que mcd (n, p − 1) = 1

2.31 Encuentre tres números a, b, c tal que mcd ( a, b, c) = 1 pero que mcd ( a, b) 6= 1, mcd ( a, c) 6=
1, mcd (b, c) 6= 1.
2.32

Probar que dos enteros consecutivos son primos relativos

2.33

Probar que si mcd ( a, b) = mcm ( a, b) =⇒ a = b.

2.34

Muestre que mcd (mg, g) = g si g ∈ N.

2.35

Si a, b ∈ N, y si a|b calcule mcd ( a, b) y mcm ( a, b).

2.36 Muestre que (∃ x, y ∈ Z tal que x + y = s ∧ mcd ( x, y) = g) ⇐⇒ g|s, g ∈ Z+ Ayuda:
Una implicación es directa por Bezout, la otra requiere descomponer kg = (k − 1) g + g

EJERCICIOS

2.37

Mostrar que si mcd ( a, b) = mcd (c, d) = 1 y si

p|qc y mcd ( p, q) = 1, entonces p|c.

45

a
c
+ ∈ Z entonces |b| = |d|. Ayuda: Si
b
d

2.38

Mostrar que mcd ( a, b) = mcd ( a, b, ax + by) con x, y ∈ Z

2.39

Muestre que mcd ( a, a + 2) = 1 ó 2

2.40

Sea pi el i −ésimo primo y sea N = p1 p2 · spn−1 + 1. Muestre que N ≥ pn .

2.41

Sean m, a, b ∈ Z. Muestre que mcd (ma, mb) = |m| mcd ( a, b)

2.42 Sea mcd ( a, b) = 1. Muestre que si d = mcd ( a + b, a − b) entonces d = 1 o d = 2.
Sea mcd ( a, b) = 1 y d = mcd ( a + 2b, 2a + b). Muestre que d|3a y d|3b y por tanto, d = 1 o d = 3.
1
1 1
+ + ... + no es entero
2 3
n

2.43

Muestre que para todo n ∈ N, n > 1; A = 1 +

2.44

Mostrar que si d|(n2 + 1) y d|((n + 1)2 + 1) para algún entero n, entonces d = 1 d = 5.

2.45

Probar que la fracción (21n + 4)/(14n + 3) es irreducible para cualquier n ∈ Z

2.46

Sea N = 2 p − 1,
a) Probar que 2ab − 1 = (2a − 1)(1 + 2a + 22a + 23a + ·s + 2(b−1)a ). Ayuda: Usar la identidad
1 − x k +1
1 + x + x2 + x3 + ·s + x k =
, x 6= 1, k ∈ N.
1−x
b) Muestre que si N es primo, entonces p es primo.

2.47

Considere los números de Euler: Tn = 22 + 1 con n ∈ N.
n
a) Muestre que 22 − 1 = Tn2−1 − 2Tn−1
b) Muestre, usando a), que Tn − 2 = Tn−1 Tn−2 · sT0
c) Muestre que si m > n, mcd ( Tn , Tm ) = 1

n

2.48 Sea n entero positivo y S un conjunto con n + 1 elementos distintos tomados del conjunto
{1, 2, ..., 2n}. Muestre que hay al menos dos elementos en S primos relativos
2.49 n ≥ 2. Supongamos que tomamos n + 1 enteros al azar. Muestre que hay dos elementos
tal que su diferencia es divisible por n. Ayuda: usar le principio del palomar y el algoritmo de
la división: n + 1 enteros producen n + 1 restos, pero dividir por n solo produce n restos...
2.50 Mostrar que hay un número infinito de primos de la forma 4n + 3.
Ayuda: Asuma que solo hay k primos de esa forma y considere el número N = 4p1 p2 · spk + 3.

46

DIVISIBILIDAD

Versión actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

3
3.1

CONGRUENCIAS

Congruencias módulo m

Recordemos que estabamos usando ‘ r = rem( a, m) ’ para indicar el resto (en el teorema de
la división) de dividir a por m. Dos números ‘‘son congruentes módulo m” si dejan el mismo
residuo al dividir por m, es decir si rem( a, m) = rem(b, m). Como a = qm + rem( a, m) y
b = q0 m + rem(b, m) entonces m|(b − a).
Todos los números son congruentes módulo m = 1. Si usamos m = 2, los pares son congruentes
con los pares (resto 0 módulo 2) y los impares con los impares (resto 1 módulo 2). En general, la
idea es ‘agrupar’ los números según el residuo que dejan al dividir por m. Estos subconjuntos
constituyen una partición de Z de tal manera que podemos trabajar no con todo Z sino con un
grupo de representantes.

Definición 3.1
Sea m ∈ Z, m ≥ 1. Decimos que a es congruente con b módulo m si m|(b − a). Escribimos
a ≡ b (mod m) o también a ≡m b

Ejemplo 3.1
a.) 10 ≡ 0 (mod 5)
b.) 10 ≡ 1 (mod 3)

pues
pues

5|(10 − 0)
3|(10 − 1)

c.) 10 ≡ −1 (mod 11)
d.) 5 ≡ 3 (mod 2)

pues
pues

11|(10 + 1)
2|(3 − 5)

Teorema 3.1
b − a ≡ 0 (mod m)

(ii)

a = mk + b,

(iii)

rem( a, m) = rem(b, m) (residuos módulo m)

⇐
⇒

(i)
a ≡ b (mod m) ⇐⇒

para algún k ∈ Z

⇒
⇐

Prueba: Probemos (iii) usando el teorema de la división.
47

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

48

CONGRUENCIAS

” =⇒ ” Sea rem( a, m) = r1 y rem(b, m) = r2 , es decir, a = q1 m + r1 con 0 ≤ r1 < m y b =
q2 m + r2 con 0 ≤ r2 < m. Supongamos que r1 > r2 , entonces b − a = (q1 − q2 )m + (r1 − r2 ) con
0 ≤ r1 − r2 < m pues 0 < r1 − r2 < r1 < m. Pero m|(b − a), por tanto b − a = mq3 , como el resto
es único (en el esquema del teorema de la divisón) entonces r2 = r1 . El caso r1 < r2 es idéntico.
” ⇐= ” Si a = q1 m + r1 con 0 ≤ r1 < m y b = q2 m + r2 con 0 ≤ r2 < m, entonces b − a = q3 m, es
decir, m|(b − a).

(Notación de congruencia y residuo).
Si r es el residuo r = rem( a, m), entonces a ≡ r (mod m)
El símbolo “ ≡ ” se puede manipular como “=” excepto para la cancelación:

Teorema 3.2
Sean a ≡ b (mod m) a0 ≡ b0 (mod m) y c, k ∈ Z. Entonces,
a.) ka ≡ kb (mod m), en particular si k ≥ 0, ak ≡ bk (mod m).
b.) aa0 ≡ bb0 (mod m)
c.) a ± a0 ≡ b ± b0 (mod m)
d.) a ≡ a (mod m) para toda a ∈ Z
e.) a ≡ b (mod m) ⇐⇒ b ≡ a (mod m)
f.) a ≡ b (mod m) ∧ b ≡ c (mod m) =⇒ a ≡ c (mod m)
g.) Sea a 6= 0, ab ≡ ac (mod m) ∧ mcd ( a, m) = d =⇒ b ≡ c (mod

m
d)

h.) Sea a 6= 0, ab ≡ ac (mod m) ∧ mcd ( a, m) = 1 =⇒ b ≡ c (mod m)
i.) Si a ≡ b (mod m) y d|m , entonces a ≡ b (mod d)
Prueba: Sólo vamos a probar algunos items, el resto queda como ejercicio.
b.) aa0 ≡ bb0 (mod m) : Por hipótesis existen k, k0 ∈ Z tal que b = mk + a y b0 = mk0 + a0 ,
multiplicando obtenemos bb0 = m(mkk0 + ka0 + k0 a) + aa0 =⇒ m|(bb0 − aa0 ).
g.) ab ≡ ac (mod m) ∧ mcd ( a, m) = d =⇒ b ≡ c (mod md ) : En efecto, como d = mcd ( a, m)
a m
a
m
entonces
y
son enteros y mcd
,
= 1.
d
d
d d
a
m
Por hipótesis, existen k ∈ Z tal que ac − ab = mk =⇒ a(c − b) = mk =⇒ (c − b) = k.
d
d
a m
m  a
m
Así,
(
c
−
b
)
∧
mcd
,
=
1
=⇒
c
−
b
)
por
el
corolario
??.
|(

d d
d d
d

49

Ejemplo 3.2 (Manipulación algebraica módulo m ).
a.) Muestre que si a ≡ b (mod m) y si c ≡ a + d (mod m) entonces c ≡ b + d (mod m).
Solución: Como 0 ≡ b − a (mod m) y c ≡ a + d (mod m), sumando miembro a
miembro (teorema 3.2 c.)) se obtiene c ≡ b + d (mod m)
b.) Muestre que si a ≡ b (mod m) y si c ≡ ad (mod m) entonces c ≡ bd (mod m)
Solución: Existe k, k0 ∈ Z tal que a = mk + b y c − ad = mk0 , entonces c − ad =
c − (mk + b)d = mk0 =⇒ c − bd = m(k0 + kd) =⇒ c ≡ bd (mod m).
≡ 0
10

≡ 0
10

≡ 7
10

z }| { z }| { z }| {
c.) d ≡ [8 + 2 + 3 + 2 + 5 + 5 + 2] (mod 10) =⇒ d ≡ 7 (mod 10)
d.) Calcular rem(95 , 5) (el resto de dividir 95 por 5).
Solución: Recordemos que rem(95 , 5) = r si 95 ≡ r (mod 5). Como 9 ≡ −1 (mod 5)
entonces 95 ≡ (−1)5 (mod 5), es decir rem(95 , 5) = −1 o también 95 = 11810 · 5 − 1.
Si queremos el resto positivo (como en el esquema del teorema de la división),
observamos que −1 ≡ 4 (mod 5), por tanto rem(95 , 5) = 4 o también 95 = 11809 ·
5 + 4.

Ejemplo 3.3
Calcular el resto de dividir 15196 por 13.
Solución: La idea es descomponer 15196 en potencias más pequeñas. Si r es el resto
buscado, 15196 ≡ r (mod 13).
15196

≡
≡
≡
≡
≡

rem(2196 , 13),
pues 15 ≡ 2 (mod 13),
 7·7
rem( 22·2
, 13), pues 196 = 2 · 2 · 7 · 7,
7
rem( 37 , 13),
pues 24 = 16 ≡ 3 (mod 13),
2
rem((3)7 , 13),
pues 37 = 33 · 3 ≡13 12 · 3 ≡ 3 (mod 13)
rem(3, 13)
pues 37 ≡ 3 (mod 13).

Así, el resto de dividir 15196 por 13 es 3.

Ejemplo 3.4
Resolver 4x ≡ 8 (mod 12) con x ∈ {0, 1, 2, ..., 11}.

50

CONGRUENCIAS

Solución: Podríamos resolver esta congruencia por ensayo y error, pero la vamos a
resolver usando el teorema 3.2 g.).
4x ≡ 8 (mod 12) =⇒ x ≡ 2 (mod 3) por el teorema 3.2 g.)
Luego, los x ∈ {0, 1, 2, ..., 11} que dejan resto 2 al dividir por 3 son x = 2, 5, 8 y 11.

No siempre usamos el residuo del teorema de la divisón porque a veces los residuos negativos
son, en valor absoluto, más pequeños.
Ejemplo 3.5
Calcular el resto de la división de 12201 por 13, es decir, calcular 12201 mod 13
Como 12 ≡ −1 (mod 13) =⇒ 12201 ≡ (−1)201 (mod 13). Entonces, por transitividad
12201 ≡ 12 (mod 13). Esto dice que 12201 mod 13 = 12 mod 13 = 12

Ejemplo 3.6
Calcular 13300 mod 7.
Aunque 13 ≡ 5 (mod 7) es mejor iniciar con 13 ≡ −2 (mod 7) pues de esta congruencia obtene-mos 133 ≡ −8 (mod 7) y −8 ≡ 1 (mod 7). Así, 13300 ≡ 1 (mod 7) =⇒
13300 mod 7 = 1 mod 7 = 1.

3.2

(*) Calendarios: ¿Qué día nació Ud?.

Supongamos que queremos saber el día de la semana correspondiente a una fecha dada: Por
ejemplo, ¿qué día fue el 9 de mayo de 1973?
En varios libros se hace un análisis de como resolver este problema, por ejemplo en [3]; aquí solo
vamos a dar la solución, según el calendario Gregoriano.
Primero debemos numerar los días y los meses, como se muestra en en la tabla que sigue (a
febrero se le asigna el 12; febrero es especial por ser el mes al que se agrega un día en año
bisiesto).
Ahora, sea f = fecha, m = mes, a = año, s = siglo y n = años en el siglo. Por ejemplo, si tenemos la fecha: abril 1, 1673 entonces: f = 1, m = 2, a = 1673 = 100s + n donde s = 16 y n = 73.
Finalmente, si d denota el día de la semana correspondiente a la fecha ( f , m, a), entonces

51
Domingo
Lunes
Martes
Miércoles
Jueves
Viernes
Sábado

=0
=1
=2
=3
=4
=5
=6

Marzo
Abril
Mayo
Junio
Julio
Agosto
Setiembre

=1
=2
=3
=4
=5
=6
=7

Octubre
Noviembre
Diciembre
Enero
Febrero

=8
=9
= 10
= 11
= 12

Tabla 3.1

s

{
r s z rnz
13m − 1
d≡ f +
− 2s + n +
+
(mod 7)
5
4
4
Un detalle. En esta redistribución, el año inicia en Marzo y finaliza en Febrero. Este es un detalle
a tener en cuenta: Las fechas que involucran a enero y febrero se les debe restar un año, pues en esta
fórmula estos meses están en el año anterior. Por ejemplo, si tenemos la fecha 3 de enero del
2010 entonces f = 3, m = 11 y a = 2009 = 100s + n donde s = 20 y n = 9.

100s + n − 1
enero febrero

100s + n
marzo
marzo

abril
abril

···
···

diciembre
diciembre

Ahora ya puede calcular qué día nació Ud.
Ejemplo 3.7
a.) El 9 de mayo de 1973 fue miércoles = 3; pues f = 9, m = 3, A = 1973 = 100s + n con
s = 19 y n = 73. Usando la fórmula obtenemos,
d ≡ 9 + 7 − 38 + 73 + 4 + 18 ≡ 3 (mod 7)

a.) El 3 de enero del 2010 fue domingo = 0; pues f = 3, m = 11, A = 2009 = 100s + n
con s = 20 y n = 9. Usando la fórmula obtenemos,
d ≡ 3 + 28 − 40 + 19 + 5 + 4 ≡ 0 (mod 7)

a.) El 29 de febrero del 2008 fue viernes, verifíquelo!

52

CONGRUENCIAS

Implementación en Excel.

[Descargar]

Private Sub CommandButton1_Click()
Dim f, m, s, n, d, dia
f = Cells(8, 1)
m = Cells(8, 2)
s = Cells(8, 3)
n = Cells(8, 4)
If m=11 or m=12 then
n=n-1
End If
d = (f+Int((13*m-1)/5)-2*s+n+Int(s/4)+Int(n/4))Mod 7
If d<0 then
d=d+7
End If
dia = Switch(d = 0,"D",d =1,"L",d=2,"K",d=3,"M",d=4,"J",d=5,"V",d=6,"S")
Cells(8, 5) = dia
End Sub

3.3

Trucos de divisibilidad.

Si a = an 10n + an−1 10n−1 + ... + a1 10 + a0 , la suma de sus dígitos es congruente con a módulo
9, en efecto, como 10 ≡ 1 (mod 9) entonces 10i ≡ 1 (mod 9), i = 0, 1, 2, ... Luego, multiplicando
por ai y sumando
n

n

∑ ai 10i ≡ ∑ ai

i =0
n

i =0

n

∑ ai 10i ≡ ∑ ai

i =0

n

(mod 9) =⇒ a ≡

i =0

∑ ai

(mod 9)

i =0
n

(mod 3) =⇒ a ≡

∑ ai

(mod 3) pues 3|9

i =0

a.) Divisibilidad por 9 : 9 divide a a si y sólo si 9 divide la suma de sus dígitos, es decir,
9| a ⇐⇒ 9 |∑in=0 ai

53
n

En efecto, como a ≡

∑ ai

(mod 9) entonces 9 |(∑in=0 ai − a) . Si 9| a entonces divide la

i =0

suma de sus dígitos y si 9 divide la suma de los dígitos de a entonces divide a a.
b.) Divisibilidad por 3 : 3 divide a a si y sólo si 3 divide la suma de sus dígitos. La demostración es igual a la anterior, cambiando 9 poe 3.
c.) Divisibilidad por 2 y por 5 : tanto 2 como 5 dividen a a si y sólo si dividen a0 .
n

En efecto: Observemos que a =
n

dividen a la suma

∑ ai 10

∑ ai 10i

+ a0 . Tanto 2 como 5 dividen a ai 10i , por tanto,

i =1
i

+ a0 si y solo si tanto 2 y 5 dividen a a0

i =1

d.) Divisibilidad
 por 11 : 11 divide a a si y sólo si 11 divide la suma alternada de sus dígitos,
es decir, 11 ∑in=0 (−1)i ai
En efecto, esto es consecuencia de que 10 ≡ −1 (mod 11).

3.4

(*) Cuadrados Mágicos

Un cuadrado mágico es un arreglo de n × n números en el que la suma de las entradas de cada
fila o columna siempre es la misma. Por ejemplo, consideremos el cuadrado mágico 3 × 3


4 2 6
 0 7 5  , tanto las filas como las columnas suman 12
8 3 1
En la actualidad hay varios métodos para construir cuadrados
mágicos. En 1693 De la Loubère dio un método para construir
cuadrados mágicos para cualquier n impar, el método es llamado el “Método Siamés”. En 1929 D.N. Lehmer investigó,
por medio de congruencias, una generalización de este método.
El resultado es una manera sencilla de colocar los números
0, 1, ..., n2 − 1 en un arreglo n × n de tal manera que sea un
cuadrado mágico. Este método, llamado método del “paso uniforme”, calcula la entrada (i, j), usando congruencias, en la que
se debe colocar cada uno de los números k = 0, 1, ..., n2 − 1 para
que el arreglo resulte “mágico”.
Definición 3.2
Supongamos que n2 enteros diferentes son colocados en un arreglo n × n. Si la suma de las
entradas de cada fila suma siempre lo mismo, decimos que el cuadrado es “mágico por filas”. Si
la suma de las entradas de cada columna suma siempre lo mismo, decimos que el cuadrado es
“mágico por columnas”. Si el cuadrado es ambos “mágico por filas” y “mágico por columnas”,
se dice “cuadrado mágico” y la suma se dice “suma mágica”.
Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

54

CONGRUENCIAS

Teorema 3.3
Sea n entero positivo impar y a, b, c, d, e, f enteros, tal que mcd (c f − de, n) = 1 Sea A = ( aij ) la
matriz n × n definida así: Para cada k = 0, 1, ..., n2 − 1,
ai+1,j+1 = k si i ≡ a + c · k + e · Jk/nK (mod n) y j ≡ b + d · k + f · Jk/nK (mod n)
Entonces,
Si mcd (c, n) = mcd (e, n) = 1, el cuadrado es ”mágico por columnas”.
Si mcd (d, n) = mcd ( f , n) = 1, el cuadrado es ”mágico por filas”.
Si mcd (c, n) = mcd (d, n) = mcd (e, n) = mcd ( f , n) = 1, el cuadrado es mágico. En cada caso la
suma mágica es n(n2 − l )/2.

Ejemplo 3.8
Sea n = 7 y a = 4, b = 3, c = 1, d = −2, e = 1, f = −4. Como mcd (c, n) = mcd (d, n) =
mcd (e, n) = mcd ( f , n) = 1, el método construye un cuadrado mágico 7 × 7 con suma
mágica 168.
k = 0 : i ≡ 4 + 1 · 0 + 1 · J0/7K (mod 7) y
k = 1 : i ≡ 4 + 1 · 1 + 1 · J1/7K (mod 7) y
k = 2 : i ≡ 4 + 1 · 2 + 1 · J2/7K (mod 7) y
···

15 40 9
 10 28 4

 5
23 48


 42 18 36

 37 13 31

 32 1 26
27 45 14

j ≡ 3 − 2 · 0 − 4 · J0/7K (mod 7) ⇒ a5,4 = 0
j ≡ 3 − 2 · 1 − 4 · J1/7K (mod 7) ⇒ a6,2 = 1
j ≡ 3 − 2 · 2 − 4 · J2/7K (mod 7) ⇒ a7,7 = 2
34
22
17
12
0
44
39

3
47
35
30
25
20
8

21
16
11
6
43
38
33

46
41
29
24
19
7
2













Implementación usandoMathematica. La implementación, usando Mathematica, es muy
sencilla,
a = 4; b = 3; c = 1; d = -2; e = 1; f = -4; n = 7;
(*Verificar si son primos relativos?*)
{GCD[c*f - d*e, n], GCD[c, n], GCD[d, n], GCD[e, n], GCD[f, n]}
B = Array[A, {n, n}]; (*A[i,j]=k*)
Do[A[Mod[a + c*k + e*Floor[k/n], n] + 1,
Mod[b + d*k + f*IntegerPart[k/n], n] + 1] = k, {k, 0, n^2 - 1}
]
MatrixForm[B]

55

Implemetnación en VBA Excel.
[Descargar]

Private Sub CommandButton1_Click()
Dim n, a, b, c, d, e, f, k, i, j
Dim CM() ’Matriz=Cuadrado m\’agico
n = Cells(4, 1) : a = Cells(4, 2) : b = Cells(4, 3)
c = Cells(4, 4) : d = Cells(4, 5) : e = Cells(4, 6)
f = Cells(4, 7)
If mcd(c * f - d * e, n) = 1 And mcd(c, n) = 1 And mcd(d, n) = 1
And mcd(e, n) = 1 And mcd(f, n) = 1 Then
’ nada
Else: MsgBox "No se cumplen las condiciones del teorema!!! "
End If
ReDim MC(1 To n, 1 To n)
For k = 0 To n ^ 2 - 1
i = (a + c * k + e * Int(k / n)) Mod n
j = (b + d * k + f * Int(k / n)) Mod n
’Queremos residuos positivos
If i < 0 Then
i = i + n
End If
If j < 0 Then
j = j + n
End If
MC(i + 1, j + 1) = k
Next k
’Imprimir la matriz
For i = 1 To n
For j = 1 To n
Cells(5 + i, 1 + j) = MC(i, j)
Next j

56

CONGRUENCIAS

Next i
End Sub
Function mcd(a, b)
Dim c As Long, d As Long, r As Long ’max = 2 147 483 647
c = Abs(a) : d = Abs(b)
While d <> 0
r = c Mod d ’residuo entre (c,d)
c = d : d = r
Wend
mcd = Abs(c)
End Function

3.5

Clases residuales módulo m

Sea m ∈ Z con m > 1. La relación “congruente módulo m”, denotada por brevedad con “≡m ”,
se define así:
a ≡ b (mod m) ⇐⇒ m|(b − a)
La relación “ ≡m ” es una relación de equivalencia, es decir, particiona Z en clases (de equivalencia.) El conjunto cociente “ Z/ ≡m ”, es el conjunto de clases de equivalencia. También se usa la
notación Z/Zm o Zm . Denotamos con a la clase cuyo representante es a, es decir,
En Zm , a = {b ∈ Z : a ≡ b (mod m)}. En particular, 0 = m.
Es fácil saber a qué clase pertence un a ∈ Z arbitrario: Si a ∈ Z y a = mk + r con 0 ≤ r < m,
entonces a ≡ r (mod m). Entonces es natural tomar como representante de clase los residuos
positivos más pequeños, es decir a = rem( a, m) (recordemos que “ rem( a, m) ” denota el más
pequeño residuo ≥ 0 de dividir a por m ).

Ejemplo 3.9
Si m = 2. Al dividir por dos solo hay dos posibilidades: Que el número se a par y el resto
es 0 o que el número sea impar y el resto es 1. Por tanto Z2 = {0, 1}, es decir Z se
particiona en dos conjuntos, los pares y los impares.

Ejemplo 3.10
La relación “ ≡5 ” particiona Z en 5 clases pues, por el teorema de la división, si a ∈ Z,
existe k ∈ Z tal que a = k · 5 + r con 0 ≤ r < 5; entonces al dividir por 5 solo hay
posibilidad de cinco residuos: 0, 1, 2, 3 o 4.

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

57

El conjunto cociente es Z5 = {0, 1, 2, 3, 4}.
0
...
11... 10
-5 -10
6
-9
-4
5
1 0
-3
4 -6
2
7...
3 9 -11
-8
-12 -2 -1...
2
8... -7
4
1

0 = {5k : k ∈ Z} = {0, ±5, ±10, ...}
1 = {5k + 1 : k ∈ Z} = {..., −9, −4, 1, 6, 11, ...}
2 = {5k + 2 : k ∈ Z} = {..., −8, −3, 2, 7, 12, ...}
3 = {5k + 3 : k ∈ Z} = {..., −7, −2, 3, 8, 13, ...}
4 = {5k + 4 : k ∈ Z} = {..., −6, −1, 4, 9, 14, ...}

3

En este contexto, a las clases de equivalencia se les denomina clases residuales módulo m y, como
deciamos más arriba, el conjunto cociente se denota con Zm (o también Z/mZ ) en vez de
Z/ ≡m .
Zm = {0, 1, 2, 3, · · · m − 1} y Z = 0 ∪ 1 ∪ · · · ∪ m − 1

Por abuso del lenguaje, es usual poner
Zm = {0, 1, 2, 3, · · · m − 1}
Observe que: Si n ∈ Z entonces n debe estar en alguna clase y solo una, de Zm

Ejemplo 3.11
Muestre que si p > 3 es primo, p es de la forma 6k ± 1.
Solución: Mmmmmm...Idea: Si p = 6k ± 1 entonces p ≡ ±1 (mod 6).
Como p ∈ Z, p debe estar en alguna de las clases de Z6 . No está en 0, 2 ni 4 pues estas
clases solo contienen pares (sus elementos son números de la forma 6k, 6k + 2, 6k + 4,
respectivamente). No está en 3 pues esta clase solo números de la forma 6k + 3 que son
múltiplos de 3. Así que p ∈ 1 o p ∈ 5 = −1. Es decir, p es de la forma 6k ± 1.

Permutaciones módulo m. En las aplicaciones a veces se usan otros conjuntos de representantes
para las clases.A estas representaciones las llamamos permutaciones del conjunto {0, 1, 2, ..., m − 1}
módulo m.
Por ejemplo, Z5 = {5, 7, 6, −6, 13} es una permutación módulo 5 de Z5 = {0, 1, 2, 3, 4} pues

58

CONGRUENCIAS

5 ≡ 0 (mod 5),
7 ≡ 2 (mod 5),
6 ≡ 1 (mod 5),
−6 ≡ 4 (mod 5)
13 ≡ 3 (mod 5),

y

Además, por supuesto, Z5 = {5, 7, 6, −6, 13} = {0, 1, 2, 3, 4}

Si m es impar, la representación simétrica de Zm es


−

m−1
m−1
, . . . , −1, 0, 1, . . .
2
2



En efecto,

0 ≡ 0 (mod m),
1 ≡ 1 (mod m),
..
.
m−1
m−1
≡
(mod m),
2
2

mientras que −

m−1
m−1
m−1
+i−1≡
+ i (mod m), i = 1, 2, ...,
.
2
2
2

Si p es primo, existe b ∈ Z tal que Zm = {0, b, b2 , ..., b p−1 } (ver capítulo 5).

Ejemplo 3.12

Z5

= {0, 1, 2, 3, 4}
= {−2, −1, 0, 1, 2} pues − 2 ≡ 3 (mod 5) y − 1 ≡ 4 (mod 5),
= {0, 3, 32 , 33 , 34 } pues 32 ≡ 4 (mod 5), 33 ≡ 2 (mod 5), 34 ≡ 1 (mod 5)

Suma y producto en Zm . Ahora nos interesa ver Zm desde el punto de vista de su estructura
algebraica. Esto no solo nos permite usar un lenguaje común, sino que también nos permite usar
resultados generales de la teoría de grupos, por ejemplo.
Podemos definir operaciones de suma y producto en Zm de la siguiente manera:
a + b = rem( a + b, m) i.e. a + b es el resto de dividir a + b por m
a · b = rem( a · b, m) i.e. a · b es el resto de dividir a · b por m

59

Ejemplo 3.13
En Z7 ,
5 + 6 = rem 117 = 4
5 · 30 = rem(150, 7) = 3
Propiedades de la suma y producto en Zm . Con estas operaciones, si m ≥ 2, Zm es anillo
conmutativo con identidad. Si a, b, c ∈ Zm ,
(1) a + b ∈ Z,

(1’) a · b ∈ Z,

(2) a + b = b + a,

(2’) a · (b + c) = a · b + a · c y (b + c) · a = b · a + c · a,

(3) a + (b + c) = ( a + b) + c,

(3’) a · 1 = a.

(4) a + 0 = 0 + a = a,
(5) el inverso aditivo de a es − a
Inversos módulo m (unidades) y divisores de cero. Sea a ∈ Zm , a es una unidad si tiene inverso, es decir, si existe b ∈ Zm tal que ba ≡ ab ≡ 1 (mod m). En este caso ponemos a−1 = b. Por
ejemplo, 2 · 3 ≡ 1 (mod 5), entonces el inverso de 2, módulo 5, es 3 y viceversa.
Por otra parte, a 6= 0, es divisor de cero en Zm si existe b ∈ Zm , b 6= 0, tal que ab = 0. Por
ejemplo, 2 · 3 ≡ 0 (mod 6), entonces 2 y 3 son divisores de cero en Z6 .

Teorema 3.4
En Zm ,
a.) a es una unidad si y solo si mcd ( a, m) = 1;
b.) a es divisor de cero si y solo si 1 < mcd ( a, m) < m;
Prueba: a.) ab ≡ 1 (mod m) si y solo si existe k ∈ Z tal que ab + mk = 1, es decir, si y solo si
mcd ( a, m) = 1.
b.) Sea a > 1 y d = mcd ( a, m).
” =⇒ ” Como a es divisor de cero, sea b 6= 0, tal que ab = 0. Supongamos, por contradicción,
que d = 1 o d = m. Si d = 1 ∧ m| ab =⇒ m|b, pero esto no puede ser pues b 6≡ 0(mod m). Si
d = m =⇒ m| a pero esto no puede ser pues a 6≡ 0(mod m).
” ⇐= ” Como 1 < d < m y d|m, existe k tal que dk = m y 1 < k < m. Entonces k 6= 0 y dk = 0.
Por tanto, si a = dk0 , ak = dkk0 = 0, es decir, a es divisor de cero.

Inversos y módulo primo. Si p es primo, entonces mcd (i, p) = 1 para todo i = 1, 2, ..., p − 1.
Así, en Z p todo elemento tiene inverso y no hay divisores de cero. Zm es un campo si y solo si

60

CONGRUENCIAS

Ejemplo 3.14 (Unidades y divisores de cero).
Sea m = 9. Si construimos una tabla de multiplicar para Z9 podemos detectar las
unidades y los divisores de cero (si hubiera). La otra manera es usar el teorema (3.4)
(Z9 , ·) 1 2 3 4 5 6 7 8
1
1 2 3 4 5 6 7 8
2
4 de
6 multiplicar
8 1 3para
5 Z79
Tabla 3.2.2Tabla
3
3 6 0 3 6 0 3 6
4 a 41 82 33 74 25 66 17 58
mcd5( a, 9) 5 1 1 1 6 3 2 1 7 1 3 3 8 1 4 1
6
6 Aplicando
3 0 6el teorema
3 0 (3.4)
6 3
Tabla
3.3.
7
7 5 3 1 8 6 4 2
4 3 de
2 cero
1 son 3, 6 .
Así, las unidades de Z8 son 81, 2, 4, 85, 7,78 y 6los 5divisores

m es primo.
En el mundillo del álgebra, si p es primo, se usa a Z p como el “representante” de los campos
finitos con p elementos y se le denota F p .
Sistemas de residuos. Como ya dijimos, hay distintos conjuntos de representantes de Zm . Vamos a establecer un par de lemas que serán de mucha utilidad la hora de establecer los teoremas
clásicos en teoría de números.

¿Cómo determinar si dado { a1 , a2 , ..., am }, se tiene Zm = { a1 , a2 , ..., am } ?.
Zm = { a1 , a2 , ..., am } si todos los m ai0 s están en clases distintas, es decir,

{ a1 , a2 , . . . , am } = { rem( a1 , m), rem( a2 , m), . . . , rem( am , m)} = {0, 1, . . . , m − 1},
Para comprobaciones en la teoría usaríamos la siguiente caracterización: Zm = { a1 , a2 , ..., am } si
y sólo si ai 6≡ a j (mod m) ∀i, j con i 6= j, 1 ≤ i, j ≤ m.

Lema 3.1
Sea mcd ( a, m) = 1, entonces Zm = {0, a, a · 2, . . . , a · (m − 1)}
Prueba: Solo hay que probar que los m elementos de {0, a, a · 2, . . . , a · (m − 1)} no se repiten
módulo m.
Primero observemos que si i, j ∈ {0, 1, 2, ..., m − 1} y si i 6= j , entonces j 6≡ i (mod m) pues i y j
estarían en clases distintas.
Ahora, si a · i ≡ a · j (mod m) con i 6= j, 1 ≤ i, j ≤ m, entonces m| a( j − i ) ; pero mcd ( a, m) = 1
entonces m|( j − i ) pero esto es imposible pues j 6≡ i (mod m) .

61

La aplicación práctica que vamos a encontrar frecuentemente es la que se establece en el siguiente
corolario,
Corolario 3.1 Si mcd ( a, m) = 1, entonces
a · 1 · a · 2 · · · a · (m − 1) ≡ 1 · 2 · · · (m − 1) (mod m)
Prueba: Ejercicio.

Ejemplo 3.15
mcd (4, 5) = 1, entonces 4 · 1 · 4 · 2 · 4 · 3 · 4 · 4 ≡ 1 · 2 · 3 · 4 (mod 5) o 6144 ≡ 24 (mod 5).

3.6

Congruencias lineales

Es fácil resolver la ecuación x + a ≡ b (mod m), la solulción es x ≡ b − a (mod m.)
Consideremos la ecuación ax ≡ b (mod m) : Hay un k ∈ Z tal que b − ax = mk o b = mk + ax.
Como ya vimos en la sección sobre ecuaciones diofánticas lineales, b = mk + ax tiene solución si
y sólo si mcd ( a, m)|b. Si esta es la situación, hay un k0 ∈ Z tal que b = k0 · mcd ( a, m) y entonces,
utilizando el algoritmo extendido de Euclides, determinamos s, t ∈ Z tal que mcd ( a, b) = sa +
tm =⇒ b = k0 sa + k0 tm y una solución sería x = k0 s.
Ejemplo 3.16
Determinar una solución de 2x ≡ 5 (mod 7).
Solución: Como mcd (2, 7) = 1 y 1|5, la ecuación tiene solución. Como el módulo es
pequeño, podemos encontrar una solución por ensayo y error: Sustituimos los valores
x = 0, 1, 2, ..., 6 y buscamos los valores de x que satisfacen la congruencia. En este caso
obtenemos la solución x = 6. Esta solución es única módulo 7.
Si el módulo es muy grande, podemos encontrar una solución usando algoritmo extendido de Euclides: 1 = −3 · 2 + 1 · 7 =⇒ 5 = −15 · 2 + 5 · 7. Así, x = −15 es una solución.
La reducción módulo 7 nos da x = 6.

Inversos módulo m
Teorema 3.5
Si mcd ( a, m) = 1 entonces ax ≡ 1 (mod m) tiene solución única x = a−1 módulo m.
Prueba: Resolver la congruencia ax ≡ 1 (mod m) es equivalente a resolver la ecuación ax + my =
1. Como mcd ( a, m) = 1, existen s, t ∈ Z tal que sa + tm = 1, con lo que tenemos la solución

62

CONGRUENCIAS

x = s para la ecuación ax ≡ 1 (mod m).
La unicidad módulo m significa que si as ≡ 1 (mod m) y as0 ≡ 1 (mod m), entonces s ≡
s0 (mod m). Para verificar que la solución es única módulo m, supongamos que as0 ≡ 1 (mod m),
luego, restando tenemos a(s − s0 ) ≡ 0 (mod m) =⇒ m| a(s − s0 ) pero como mcd ( a, m) = 1 entonces m|(s − s0 ) =⇒ s ≡ s0 (mod m).

Si sa + tm = 1, en la práctica tomamos a−1 = rem(s, m) (el residuo de dividir s por m en el
teorema de la división).

Ejemplo 3.17
Como mcd (27, 31) = 1 entonces 27 tiene inverso módulo 31. Aplicando el algoritmo
extendido de Euclides obtenemos −8 · 27 + 7 · 31 = 1. Así a−1 = −8. En la práctica nos
interesa la solución a−1 = rem(−8, 31) = 23 (pues −8 = −1 · 31 + 23 ).

Solución general. Podemos aplicar la teoría de ecuaciones diofánticas lineales para obtener el
siguiente resultado,

Teorema 3.6
ax ≡ b (mod m) tiene solución si y sólo si d = mcd ( a, m)|b. Si x0 es una solución particular,
la solución general es x ≡ x0 (mod m/d), es decir, obtenemos las ‘ d ’ soluciones módulo m,
m
x = x0 + t con 0 ≤ t < d
d

Prueba: Para la prueba vamos a usar los teoremas (2.11) y (2.13) de la sección de ecuaciones
diofánticas. Si ax ≡ b (mod m), entonces hay un k ∈ Z tal que ax − mk = b. Esta ecuación
diofántica tiene solución si y solo si d = mcd ( a, m)|b. Si una solución particular es x = x0 , enm
tonces la solución general es x = x0 + t, con t ∈ Z (aquí solo interesa x ). Solo falta probar
d
que solo hay d soluciones distintas módulo m.
m
m
Si x0 + t1 ≡ x0 + t2 (mod m), usando el hecho de que (m/d)|m, obtenemos que t1 ≡
d
d
m
m
t2 (mod d), es decir, x0 + t1 y x0 + t2 son soluciones distintas módulo m si y solo si t1 y
d
d
t2 están en clases distintas de Zd . Esto nos deja solo las d posibilidades t = 0, 1, ..., d − 1.

Corolario 3.2 Si p es primo y mcd ( a, p) = 1, la ecuación lineal ax ≡ b (mod m) tiene solución única
x ≡ a−1 b (mod p).
Prueba: Ejercicio.

63

Ejemplo 3.18
a.) Resolver 2x ≡ 5 (mod 7).
Solución: como mcd (2, 7) = 1, la ecuación tiene solución única módulo 7. La solución es x ≡ 2−1 · 5 (mod 7); como 4 · 2 ≡ 1 (mod 7), x ≡ 4 · 5 ≡ 6 (mod 7). Así, la
solución es x = 6.
b.) Resolver 42x ≡ 50 (mod 76).
Solución: Usando el algoritmo extendido de Euclides obtenemos la solución particular
x = −225 ≡ 3 (mod 76).
Ahora, como mcd (42, 76) = 2, la solución general es
x ≡ 3 (mod 38),
es decir, x = 3 + 38 t. La ecuación tiene dos soluciones módulo 76, a saber x = 3 y
x = 41.
c.) Resolver 12x ≡ 48 (mod 18).
Solución: Una solución particular es x = 1, ahora, como mcd (12, 18) = 6, la solución general es x ≡ 1 (mod 3), es decir, x = 1 + 3 t. La ecuación tiene seis soluciones
módulo 18, a saber x = 1, 4, 7, 10, 13 y 16.
d.) La ecuación 2x ≡ 3 (mod 4) no tiene solución pues mcd (2, 4) = 2 - 3

3.7

Teorema Chino del resto

Un ejemplo concreto de un sistema de congruencias lineales se describe en el ejemplo que sigue,

Ejemplo 3.19

Calcule x tal que


x ≡ 1 (mod 3),







x ≡ 2 (mod 5),





x ≡ 3 (mod 7).




Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

64

CONGRUENCIAS

Solución: Hay un número infinito de soluciones para este sistema, por ejemplo x =
52, −53, 157, ... como se puede verificar rápidamente. Una manera de resolver este sistema es despejar y sustituir x hasta que la última congruencia sea usada,

x ≡ 1 (mod 3)

=⇒ x = 1 + 3t1
=⇒ 1 + 3t1 ≡ 2 (mod 5)
=⇒ 3t1 ≡ 1 (mod 5)
=⇒ t1 ≡ 2 (mod 5) pues 3 · 2 ≡ 1 (mod 5)
=⇒ t1 = 2 + 5t2
=⇒ x = 7 + 15t2
=⇒ 7 + 15t2 ≡ 3 (mod 7)
=⇒ 15t2 ≡ 3 (mod 7)
=⇒ t2 ≡ 3 (mod 7) pues 15 · 1 ≡ 1 (mod 7)

Por tanto,
y

t2 = 3 + 7t
x = 7 + 15 · (3 + 7t) = 52 + 105t, t ∈ Z.

Así, x = 52 + 105t, t ∈ Z; es la solución general del sistema. Aquí debemos notar que
105 = 3 · 5 · 7, es decir, la solución es única módulo 3 · 5 · 7.

Teorema 3.7 (Teorema Chino del resto).
Consideremos el sistema lineal de congruencias
x ≡ a1 (mod m1 )
x ≡ a2 (mod m2 )
...
x ≡ ak (mod mk )
con mcd (mi , m j ) = 1, i 6= j; entonces, si M = m1 · m2 · · · mk , Mi = M/mi y yi ≡ Mi−1 (mod mi ),
el sistema tiene solución única x = a1 M1 y1 + a2 M2 y2 + · · · + ak Mk yk , módulo M.

65

Prueba: La prueba3 es en dos partes, primero se muestra una solución de manera explícita y
luego se prueba que es única.
Sean M = m1 · m2 · · · mk y Mi = M/mi , 1 ≤ i ≤ k. Como los módulos son primos relativos dos a
dos, mcd ( Mi , mi ) = 1 para cada i. También, Mi ≡ 0 (mod m j ) j 6= i.
Como mcd ( Mi , mi ) = 1, entonces Mi yi ≡ 1 (mod mi ) tiene solución única yi ≡ Mi−1 (mod mi ).
Sea x = a1 M1 y1 + a2 M2 y2 + · · · + ak Mk yk . Vamos a mostrar que x es solución del sistema de
congruencias.

k

x

=

∑ a i Mi y i

+ a j Mj y j

i =1
i6= j
k

≡

∑ ai · 0 · yi

+ a j · 1 (mod m j )

i =1
i6= j

≡ 0 + a j (mod m j )
≡ a j (mod m j ), 1 ≤ j ≤ k

Por tanto, x satisface todas las congruencias del sistema, es decir, es una solución del sistema.
Para probar la unicidad módulo M supongamos que x1 y x2 son soluciones del sistema, vamos
a demostrar que x1 ≡ x2 (mod M).
Puesto que x1 ≡ a j (mod m j ) y x2 ≡ a j (mod m j ) para 1 ≤ j ≤ k, restando x1 − x2 ≡ 0 (mod m j ),
luego m j |( x1 − x2 ) para cada j.
Entonces mcm (m1 · m2 · · · mk )|( x1 − x2 ), es decir, M|( x1 − x2 ) pues también M = mcm (m1 ·
m2 · · · mk ). Por tanto, x1 − x2 ≡ 0 (mod M ), es decir x1 ≡ x2 (mod M ).

Ejemplo 3.20

Resolver el sistema


 x ≡ 1 (mod 3),


x ≡ 2 (mod 5),
x ≡ 3 (mod 7).

usando el método del teorema anterior.

Solución: M = 3 · 5 · 7 = 105, M1 = 35, M2 = 21, M3 = 15. Luego,

3

Para seguir la prueba debemos recordar que si m1 , m2 , ..., mk son primos relativos dos a dos, entonces
mcm (m1 , m2 , ..., mk ) = m1 · m2 · · · mk y si m1 , m2 , ..., mk , a ∈ Z+ y mi | a, i = 1, 2, ..., k; entonces mcm (m1 , m2 , ..., mk )| a .

66

CONGRUENCIAS

y1 ≡ M1−1 (mod 3) =⇒ y1 ≡ 2 (mod 3)
y2 ≡ M2−1 (mod 5) =⇒ y2 ≡ 1 (mod 5)
y3 ≡ M3−1 (mod 7) =⇒ y3 ≡ 1 (mod 7)
Así,
x

= a1 M1 y1 + a2 M2 y2 + a3 M3 y3
= 1 · 35 · 2 + 2 · 21 · 1 + 3 · 15 · 1
= 157 ≡ 52 (mod M)

Podemos decir, la solución única es x ≡ 52 (mod 105).

Sistemas con módulos no coprimos dos a dos. Si los módulo no son coprimos dos a dos, el
sistema podría tener solución en las condiciones del siguiente teorema,

Teorema 3.8
El sistema
x ≡ a1 (mod m1 )
x ≡ a2 (mod m2 )
...
x ≡ ak (mod mk )
tiene solución si y solo si mcd (mi , m j )|( ai − a j ), 1 ≤ i, j ≤ k. Cuando hay solución, es única
módulo mcm (m1 · m2 · · · mk ).

Si hay solución, se puede obtener despejando y sustituyendo como en el ejemplo (3.19).

3.8

Congruencias de Orden Superior

Consideremos de manera general el problema de resolver la congruencia P( x ) ≡ 0 (mod m) con
P( x ) un polinomio con coeficientes enteros. La manera directa (y no muy eficiente) de resolver
este problema es probar con x = 0, 1, ..., m − 1.
Ejemplo 3.21
Resolver x2 + x − 2 ≡ 0 (mod 10).
Solución: Probamos sustituyendo x = 0, 1, ..., 9 y encontramos las soluciones x = 1, 3, 6, 8.
Si m no es la potencia de un primo, el problema se puede reducir a resolver un sistema con
módulos menores que m, usando el teorema chino del resto.

EJERCICIOS

67

Teorema 3.9
Sea m = m1 · m2 · · · mk con m1 , m2 , · · · , mk primos relativos dos a dos. x = a es una solución de
P( x ) ≡ 0 (mod m) si y solo si a es solución del sistema
P( x ) ≡ 0 (mod m1 )
P( x ) ≡ 0 (mod m2 )
...
P( x ) ≡ 0 (mod mk )
Prueba: Si P( a) ≡ 0 (mod M ), entonces P( a) ≡ 0 (mod mi ), i = 1, 2, ..., k.
Ahora supongamos que x = a es solución del sistema, es decir,
P( a) ≡ 0 (mod m1 )
P( a) ≡ 0 (mod m2 )
...
P( a) ≡ 0 (mod mk )
El teorema chino del resto nos dice que P( a) ≡ 0 (mod m1 · m2 · · · mk ), es decir, x = a es solución
de P( x ) ≡ 0 (mod m).

Ejemplo 3.22
Resolver x2 + x − 2 ≡ 0 (mod 10).
Solución: Como 10 = 2 · 5, podemos resolver el sistema
P( x ) ≡ 0 (mod 2)
P( x ) ≡ 0 (mod 5)
La ganancia sería resolver congruencias con un módulo más pequeño. Por ensayo y error,
P( x ) ≡ 0 (mod 2) tiene soluciones x = 0, 1
P( x ) ≡ 0 (mod 5) tiene soluciones x = 1, 3
La solución del problema requiere resolver los cuatro sistemas


x ≡ 0 (mod 2)
,
x ≡ 1 (mod 5)



x ≡ 0 (mod 2)
,
x ≡ 3 (mod 5)



x ≡ 1 (mod 2)
,
x ≡ 1 (mod 5)



x ≡ 1 (mod 2)
.
x ≡ 3 (mod 5)

Las solución de cada uno de los cuatro sistemas son x = 6, 8, 1, 3, respectivamente. Por
tanto, la solución de la congruencia x2 + x − 2 ≡ 0 (mod 10) es x = 1, 3, 6, 8.

EJERCICIOS
3.1 Sea r el residuo de dividir b por m en el Teorema de la División. Dé un contra-ejemplo
que evidencie que “b ≡ r (mod m) =⇒
6
b = r mod m”.¿Cuál es el requisito para la equivalencia?
3.2

Calcule el inverso de a = 7 módulo m = 211.

68

CONGRUENCIAS

3.3 Si llamamos a los días de la semana por un número 0 ≤ d < 7 (0 = domingo, 6 = sábado),
describa un algoritmo (usando congruencias) que, sabiendo que hoy es el día d, nos diga qué
día será en n días contando el día de hoy? Por ejemplo, si hoy es domingo (0), en 7 días es
domingo. Por ejemplo, si hoy es lunes(d = 1), ¿qué día es en 374 días?.
3.4 Probar que todo entero es congruente con exactamente uno de los residuos {0, 1, 2, ..., m −
1} módulo m.
3.5 Muestre que todo primo p > 3 es congruente con 1 o con 5 módulo 6. Ayuda: Use el
ejercicio anterior.
3.6 Sea S = {2, 3, 5, 7, 11, 13, 17, ...} = {2, 3} ∪ {6k ± 1 : k = 1, 2, ...}. Muestre que S contiene a
todos los primos.
Ayuda: 2, 3 ∈ S. Solo falta verificar que si p es primo > 3, entonces p ∈ S.
3.7 Muestre que si p es primo y p - a , la ecuación ax ≡ b (mod p) tiene solución única, módulo
p, x ≡ a p−2 b (mod p).
3.8

¿ Z7 = {0, 1, −2, 4, −8, 16, −32} ?

3.9

Mostrar que si a ∈ Z, Zm = { a, a + 1, ... , a + m − 1}.

3.11

m−1
m−1
, . . . , −1, 0, 1, . . .
}
2
2
Muestre que si mcd (b, m) > 1, entonces Zm 6= {0, b · 1, b · 2, . . . , b · (m − 1)}

3.12

Sea p primo, muestre que si mcd ( a, p) = 1, entonces mcd ( a−1 , p) = 1.

3.13

Muestre que si k ≥ 5 entonces k! ≡ 0 (mod 15)

3.14

Muestre que 3! + 4! + 5! + · · · + 100! es divisible por 15 .

3.10

Mostrar que si m es impar, Zm = {−

3.15 Muestre que N = 11 · 14n + 1 es compuesto.
Ayuda: Si n es par, iniciar con 14 ≡ −1 (mod 3) y recalcular N módulo 3. Si n es impar, iniciar
con 14 ≡ −1 (mod 5) y recalcular N módulo 5.
3.16 Muestre que si P( x ) es un polinomio con coeficientes enteros y si a ≡ b (mod m) entonces
P( a) ≡ P(b) (mod m).
3.17

Dé un ejemplo que muestre que ( a ≡ b (mod p) y si p|m) 6=⇒ a ≡ b mod (m)

3.18 Sea p un divisor no trivial de m. Muestre que si xi ≡ x j (mod p) ∧ xi 6≡ x j mod (m),
entonces mcd ( xi − x j , m) es un divisor no trivial de m.
3.19 Muestre que si p ≡ 1 (mod 4) y p ≡ 1 (mod 3), entonces p ≡ 1 (mod 12). Ayuda: Corolario
(2.7).
3.20 Muestre que si p ≡ 3 (mod 4) y p ≡ 2 (mod 3), entonces p ≡ 7 (mod 12). Ayuda: Corolario
(2.7).
3.21

Muestre que 43q ≡ 1 (mod 9), q ∈ N.

3.22 Muestre que para cada n ∈ N, 4n ≡ 1 (mod 9) o 4n ≡ 4 (mod 9) o 4n ≡ 7 (mod 9)
Ayuda: Calcule primero 4t mod 9 para t = 0, 1, 2, 3. Luego use el algoritmo de la división: 4n =
43q+r .
3.23

Muestre que 6 · 4n ≡ 6 (mod 9) para todo n ≥ 0.

3.24

Muestre que ( a1 + a2 )2 ≡ ( a21 + a22 ) (mod 2)

3.25

Muestre que ( a1 + a2 + ... + an )2 ≡ ( a21 + a22 + ... + a2n ) (mod 2)

EJERCICIOS

3.26

69

Muestre que si 0 ≤ r < m y a ≡ r (mod m), entonces a mod m = r

3.27 Sean m1 , m2 , ..., mk ∈ Z+ con c = mcm (m1 m2 · · · mk ). Muestre que si a ≡ b (mod mi ), i =
1, 2, ..., k; entonces a ≡ b (mod c).
3.28

Verifique que 112 ≡ 1 (mod 5) y 11 ≡ 1 (mod 5) pero 11 6≡ −1 mod 5

3.29 Muestre que si p es primo y si mcd ( a, p) = 1, entonces si a2 ≡ 1 (mod p) =⇒ a ≡
1 (mod p) o a ≡ −1 (mod p). Indique además, ¿porqué se requiere la hipótesis mcd ( a, p) = 1, ?
3.30

Sea p primo impar y i, j ∈ {−

mod p)

p−1
p−1
, . . . , −1, 0 1, . . .
} con i 6= j. Muestre que i2 6≡ j2 (
2
2

3.31

Sea p primo y i, j ∈ {0, 1, 2, ..., p − 1} con i 6= j. Muestre que i2 6≡ j2 ( mod p)

3.32

Muestre que a2 ≡ a (mod 2) para todo a ∈ Z

3.33

Muestre que si ra ≡ rb (mod rm) entonces a ≡ b (mod m).

3.34

Sean a, b enteros positivos < m. Muestre que a 6≡ b( mod m)

3.35

Dé un ejemplo en el que mcd ( a, m) = 1 y mcd (b, m) = 1 y que a ≡ b (mod m).

3.36 Calcule el más pequeño entero positivo n que deja residuo 3 al dividir por 7, residuo 4 al
dividir por 9 y residuo 8 cuando se divide por 11.
3.37

Resuelva el sistema
x ≡ 21 (mod 3),
x ≡ 32 (mod 5),
x ≡ 3 (mod 7),
x ≡ 9 (mod 11),
x ≡ 2 (mod 2),
x ≡ 1 (mod 97).

3.38 Un niño tiene una bolsa con bolinchas. Si las agrupa en puños de 7, le sobran 5, Si las
agrupa en puños de 11, le sobran 6, Si las agrupa en puños de 13, le sobran 8. Determine el
mínimo número de bolinchas que podría tener el niño.

x ≡ 2 (mod 4)
3.39 Muestre que el sistema
no tiene solución. Ayuda: Use el método de
x ≡ 3 (mod 6)
sustitución y Bezout.
3.40

Calcule el más pequeño entero positivo n tal que 2|n, 3|n + 1, 5|n + 2, 7|n + 3, y 11|n + 4.

3.41

Resuelva el sistema
x ≡ 4 (mod 6),
x ≡ 2 (mod 8),
x ≡ 1 (mod 9).

3.42

Resolver x5 − 3x4 + x − 2 ≡ 0 (mod 165).

70

CONGRUENCIAS

Versión actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

4
4.1

POTENCIAS mod m

Orden de un elemento módulo m.

Sea mcd ( a, p) = 1, entonces p - as si s ≥ 1. Como a, a2 , a3 , ..., a p son p elementos no nulos del
conjunto de p − 1 residuos {1, 2, ..., p − 1}, entonces al menos dos se tienen que repetir módulo
p: Existen s 6= t tal que as ≡ at (mod p).
La parte importante aquí es ver que si s = t + r, entonces, como mcd ( at , p) = 1, at tiene inverso
módulo p, así multiplicando este inverso a ambos lados se tienen
as ≡ at (mod p) =⇒ at+r ≡ at (mod p) =⇒ ar ≡ 1 (mod p).
Ejemplo 4.1
En Z7 , {2, 22 , 23 , 24 , 25 , 26 , 27 } = {2, 4, 1, 2, 4, 1, 2}. En particular, 22 ≡ 25 (mod 7), entonces
23 ≡ 1 (mod 7)

Teorema 4.1
Si mcd ( a, m) = 1 entonces at ≡ 1 (mod m) para algún 1 ≤ t < m.

Prueba: Se trata de refinar un poco el argumento que se dio más arriba, así que se deja como
ejercicio.

Definición 4.1 (Orden de un número módulo m ).
Sea m ≥ 2. Si mcd ( a, m) = 1, el orden de “a” módulo m , denotado Ordm ( a), es el más pequeño
entero positivo t tal que at ≡ 1 (mod m)

Observe que si Ordm ( a) = t, entonces at ≡ 1 (mod m) pero as 6≡ 1(mod m) si 0 < s < t
71

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

72

POTENCIAS mod m

Ejemplo 4.2
El orden de 2 módulo 7 es t = 3 pues 23 ≡ 1 (mod 7) pero 22 6≡ 1(mod 7) y 21 6≡
1(mod 7). Observemos que 26 ≡ 1 (mod 7) y 3|6.

Teorema 4.2
Si Ordm ( a) = t y as ≡ 1 (mod m), entonces t|s.

Prueba: Si s = kt + r con 0 ≤ r < t, se tiene que as ≡ akt+r (mod m) =⇒ ar ≡ 1 (mod m). Pero
como 0 ≤ r < t y t es el orden de a, la única posiblidad que queda es ar ≡ 1 (mod m) solo si
r = 0.

Si conocemos el orden de un número módulo m, podríamos ganar algo en el cálculo del orden
de otros elementos de Zm : Si a tiene orden t módulo m y queremos calcular el orden de ad ,
ya se sabe que adt ≡ 1 (mod m) pero el orden de ad es ≤ dt, en realidad tenemos,

Teorema 4.3
Si Ordm ( a) = t, entonces el orden de ad es q =

t
si d > 0
mcd (d, t)

Prueba: amcm(d,t) ≡ 1 (mod m) pues t| mcm (d, t). Tenemos,

( ad )

Como mcm (d, t) =

mcm(d,t)
d

≡ 1 (mod m)

dt
mcm (d, t)
t
=⇒
=
, entonces
mcd (d, t)
d
mcd (d, t)

t

( ad ) mcd(d,t) ≡ 1 (mod m)
t
: Si ( ad )s = ads ≡ 1 (mod m) entonces t|ds. Así, ds
mcd (d, t)
es múltiplo de t y es múltiplo de d, por tanto,
Falta probar que el orden de ad es

ds ≥ mcm (d, t) =⇒ s ≥

mcm(d, t )

d

=

t
.
mcd (d, t)

73

Ejemplo 4.3
El orden de 2 módulo 7 es t = 3, entonces el orden de 4 = 22 es

3
= 3, i.e.
mcd (2, 3)

43 ≡ 1 (mod 7.)
El orden de 3 módulo 163 es 162, entonces el orden de 326 es

4.2

162
= 81.
mcd (26, 162)

El Teorema “pequeño” de Fermat.

Para establecer el teorema “pequeño” de Fermat4 , observemos que

( a · 1) ( a · 2) · · · ( a · ( p − 1)) = a p−1 (1 · 2 · · · ( p − 1))
Pero podemos probar que si mcd( a, p) = 1, entonces el conjunto { a · 1, a · 2, · · · , a · ( p − 1)} es
una permutación módulo p, del conjunto {1, 2, ..., p − 1}. Luego, si mcd ( a, p) = 1, cancelando
tendríamos a p−1 ≡ 1 (mod p.)

Ejemplo 4.4
Sea a = 270 y p = 7.
270 · 1 ≡ 4 (mod 7)
270 · 3 ≡ 5 (mod 7)
270 · 5 ≡ 6 (mod 7)

270 · 2 ≡ 1 (mod 7)
270 · 4 ≡ 2 (mod 7)
270 · 6 ≡ 3 (mod 7)

Así,
2706 (1 · 2 · 3 · 4 · 5 · 6)

≡ (270 · 1)(270 · 2)(270 · 3)(270 · 4)(270 · 5)(270 · 6) (mod 7)
≡

(4 · 5 · 6 · 1 · 2 · 3)(mod 7)

entonces, 2706 (1 · 2 · · · 6) ≡ (1 · 2 · · · 6) (mod 7) =⇒ 2706 ≡ 1 (mod 7)

Antes de enunciar el teorema, establecemos el lema
4

P.

El 18 de octubre de 1640, Fermat escribió una carta a Bernhard Frenicle de Bessy (1605-1675), un funcionario de
la Casa de la Moneda francesa, excelente alumno en teoría de los números.
En su carta, Fermat comunica el resultado siguiente: Si p es primo y p - a entonces p| a p−1 − 1 . Fermat no presentó
una prueba de este resultado, pero una nota adjunta prometía enviar una demostración, siempre que no resultara
demasiado extensa. Sin embargo, la primera prueba conocida la dio Euler un siglo después. Este resultado es
conocido como el “pequeño” teorema de Fermat para diferenciarlo del “último teorema de Fermat” (1637): La
Fermat (1601-1665)
ecuación x n + yn = zn no tiene soluciones enteras positivas si n > 2 (demostrado por A.Wiles en 1995.)

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

74

POTENCIAS mod m

Lema 4.1
Sea p primo y mcd ( a, p) = 1, entonces
a · 1 · a · 2 · · · a · ( p − 1) ≡ 1 · 2 · · · ( p − 1) (mod p)

Prueba: Aplicación directa del lema (3.1) y el corolario (3.1)

Teorema 4.4 (Teorema “pequeño” de Fermat)
Sea p primo y a ∈ Z.

• Si mcd ( a, p) = 1 entonces, a p−1 ≡ 1 (mod p)
• Para cualquier a ∈ Z+ se tiene a p ≡ a (mod p.)

Prueba: Usando lema anterior,

a p−1 (1 · 2 · · · ( p − 1))

≡ ( a · 1)( a · 2) · · · ( a · ( p − 1)) (mod p)
≡ 1 · 2 · · · ( p − 1) (mod p)

Entonces a p−1 (1 · 2 · · · ( p − 1)) ≡ 1 · 2 · · · ( p − 1) (mod p) =⇒ a p−1 ≡ 1 (mod p) pues se sabe que
mcd (1 · 2 · · · ( p − 1), p) = 1.
Para probar la segunda afirmación solo hay que observar que si p| a entonces a ≡ 0 (mod p) por
tanto a p ≡ a (mod p). Si a y p son primos realtivos se obtiene el resultado de manera inmediata.

Ejemplo 4.5
Calcule manualmente el resto de dividir 241937 por 17.
Solución: Por el teorema de Fermat, como mcd (24, 17) = 1, 2416 ≡ 1 (mod 17). Luego,
como 1937 = 16 · 121 + 1, entonces
241937 = 2416·121+1 = 2416·121 241 ≡ 24 (mod 17), es decir, 241937 ≡ 7 (mod 17).

75

Ejemplo 4.6
La congruencia x6 + x4 + x − 3 ≡ 0 (mod 5) tiene las mismas soluciones que la congruencia x2 + x − 3 ≡ 0 (mod 5) pues, por el teorema de Fermat, x4 ≡ 1 (mod 5) y
x6 = x4 · x2 ≡ x2 (mod 5)

Teorema 4.5
Sea p primo y a cualquier entero tal que p - a. Entonces, a p−2 es el inverso de a módulo p.
Prueba: Por el teorema de Fermat, a p−1 ≡ 1 (mod p), entonces a · a p−2 ≡ 1 (mod p), es decir,
a · a p−2 = 1.

Corolario 4.1 Sea p > 1. Si existe a ∈ Z y mcd ( a, p) = 1, tal que a p 6≡ a (mod p), entonces p es
compuesto.
Prueba: Ejercicio.

El teorema de Fermat no se puede usar, en principio como una prueba de primalidad pues
solo nos da una condición necesaria pero no suficiente. En efecto, hay números compuestos que
pasan la “prueba” del teorema de Fermat para alguna base a.
Ejemplo 4.7
a.) 341 = 11 · 31 es compuesto, mcd (341, 2) = 1 y 2340 ≡ 1 (mod 341), es decir, 341
pasa la “prueba de Fermat” en base 2 pero no es primo.
b.) 4 no es primo pues 24 6≡ 2 (mod 4).

4.3

Teorema de Euler

El teorema de Euler es uno de los grandes hitos en la desarrollo de la teoría de números. Fue
probado por Euler en 1760. Este teorema extiende el teorema “pequeño” de Fermat a un módulo
arbitrario. Antes de enunciarlo y probarlo, necesitamos algunos detalles técnicos.

Definición 4.2
Para cada n ≥ 1, denotamos con ϕ(n) la cantidad de enteros positivos menores que n y coprimos con n. A ϕ se le llama función “phi” de Euler.
Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

76

POTENCIAS mod m

Euler parece que no usaba una notación funcional para esta función; él usó en algún momento
la notación “ πn ”. Gauss introdujo la notación “ ϕ(n) ” aunque también se usa “ φ(n) ”. Sylverter
introdujo la notación “Totient(n)” que a veces aparece en la literatura actual.
Ejemplo 4.8
ϕ(24) = 8 pues 1, 5, 7, 11, 13, 17, 19 y 23 son los coprimos con 24 inferiores a 24.

Recordemos que a ∈ Zm tiene inverso si mcd ( a, m) = 1. Luego, ϕ(m) calcula la cantidad de
unidades en Zm . Así, si p es primo, entonces ϕ( p) = p − 1.

Ejemplo 4.9
Sea m = 9, de acuerdo con la tabla, ϕ(9) = 6.
a
mcd ( a, 9)

1
1

2
1

3
3

4
1

5
1

6
3

7
1

8
1

Tabla 4.1. Unidades de Z9 : ϕ(9) = 6.

Teorema 4.6
p es primo si y solo si ϕ( p) = p − 1
Prueba: Si p es primo, los enteros 1, 2, ..., p − 1 son primos relativos con p y menores que p,
entonces ϕ( p) = p − 1.
Hay exactamente p − 1 enteros positivos inferiores a p. Como ϕ( p) = p − 1, ninguno de estos
p − 1 enteros divide a p, es decir, p es primo.

Corolario 4.2 Sea m es compuesto, ϕ(m) < m − 1.
Prueba: Ejercicio.

Teorema 4.7
Sea p primo y α > 1. ϕ( pα ) = pα − pα−1 = pα−1 ( p − 1)
Prueba: Observemos que el conjunto {1, 2, ..., pα } tiene pα elementos. Por ejemplo, el conjunto
{1, 2, 3, ..., 52 } tiene 52 = 25 elementos.

77

Como p es primo, los números que dividen a pα e inferiores a él (excepto 1) son los pα−1
números
p, 2p, . . . , pα−1 p.
Entonces, en el conjunto {1, 2, . . . , pα } hay pα − pα−1 elementos coprimos con pα .

Ejemplo 4.10
ϕ(9) = ϕ(32 ) = 3 · 2 = 6 y ϕ(4) = ϕ(22 ) = 2 · 1 = 1

Si ϕ fuera multiplicativa, es decir, si ϕ(nm) = ϕ(n) ϕ(m) cuando mcd (m, n) = 1, entonces
ϕ(36) = ϕ(22 · 32 ) = ϕ(22 ) ϕ(32 ) = 2 · 6 = 12. Y efectivamente, ϕ es multiplicativa. Para tener una
guía para la demostración de este hecho, necesitamos un lema previo y un ejemplo numérico.

Lema 4.2
Sean mcd (n, m) = 1 y r un entero, entonces Zm = {r, n + r, 2n + r, ..., (m − 1)n + r }

Prueba: Solo necesitamos probar que los m elementos de A = {r, n + r, 2n + r, ..., (m − 1)n + r }
no se repiten módulo m. En efecto, si
jn + r ≡ in + r (mod m), i 6= j, 0 ≤ i, j ≤ m − 1;
entonces, como mcd (n, m) = 1, se obtiene j ≡ i (mod m), pero esto no puede pasar i y j están
en clases distintas módulo m.

Ejemplo 4.11
Sea n = 4 y m = 9. mcd (4, 9) = 1. Para establecer una guía para la demostración de que
ϕ es multiplicativa, hacemos un arreglo con los números 1, 2, ..., 36,
1
 2

 3
4


5
6
7
8

9
10
11
12

13
14
15
16

17
18
19
20

21
22
23
24

25
26
27
28

29
30
31
32


33
34 

35 
36

La idea es eliminar números hasta que nos quede un arreglo rectangular ϕ(n) × ϕ(m).
La fila i es i n + i 2n + i ... (m − 1)n + i. Como 2 no es primo relativo con n = 4,
entonces 2 ni la fila 2 n + 2 2n + 2 ... (m − 1)n + 2 es prima relativa con n = 4,
así que podemos quitar esta fila y, con el mismo argumento, podemos quitar la fila 4.

78

POTENCIAS mod m

1 5
  

 3 7
 


9

11


13

15


17 21
 
19 23
 

25 29
 
27 31
 


33
 

35 


Las filas que quedan son las filas que inician con primos relativos de n = 4, es decir
quedan ϕ(n) = 2 filas.
Ahora quitamos, en cada fila, los números que no son primos relativos con m = 9, resulta
que los elementos que se deben quitar son ϕ(m) = 3 elementos:
1 5
  

 3 7
 




11


13 17
 
 19
 



23


25





29 
  

31  
 



−→

1
3

5
7

13
11

17
19

25
23

29
31



En cada fila quedan ϕ(m) elementos, pues si hacemos reducción módulo m, por el lema
anterior, la fila {i, n + i 2n + i ... (m − 1)n + i } se convierte en {0, 2, ..., m − 1}, y en este
conjunto solo hay ϕ(m) elementos primos relativos con m. Finalmente el arreglo queda
ϕ(n) ϕ(m). Recordemos que si mcd (i, n) = 1 y mcd (i, m) = 1, entonces mcd (i, mn) = 1.
Así, el arreglo tiene todos los primos relativos con mn e inferiores a mn, es decir ϕ(nm).

Teorema 4.8
ϕ es multiplicativa, i.e., si mcd (m, n) = 1 =⇒ ϕ(nm) = ϕ(n) ϕ(m)
Prueba: Consideremos el arreglo

1
 2

 ···


 i

 ···

 m−1
m

m+1
m+2

2m + 1
2m + 2

m+i

2m + i

2m

3m


( n − 1) m + 1
( n − 1) m + 2 




. . . ( n − 1) m + i 




. . . mn

...
...

Si mcd (i, n) 6= 1, entonces los elementos de la fila i no son primos relativos con n. Si quitamos
estas filas, quedan ϕ(n) filas
rj

n + rj

2n + r + j

...

(m − 1)n + r j , j = 1, ..., ϕ(n)

con mcd (r j , n) = 1. Ahora, como Zm = {r j , n + r j , 2n + r + j, ..., (m − 1)n + r j }, entonces en
cada fila de estas solo hay ϕ(m) números primos relativos con m. Finalmente nos queda un
arreglo de ϕ(n) × ϕ(m) con números ambos primos relativos con n y m y por tanto, primos
relativos con nm. Como todos son inferiores a nm, ϕ(nm) = ϕ(n) ϕ(m).

El teorema (4.8) nos permite calcular ϕ(n) de manera directa, si conocemos la factorización
prima de n ,

79



α
α −1
ϕ (n) = ϕ ∏ik=1 pi i = ∏ik=1 pi i ( pi − 1).

Teorema 4.9
Sea n = ∏ik=1 pi i , pi primo. Entonces
α



1
ϕ(n) = n 1 −
p1



1
1−
p2





1
··· 1 −
pk







1
1
Prueba: Si n = pα , ϕ(n) = ϕ( pα ) = pα − pα−1 = pα p −
=n p−
.
p
p
Si n = ∏ik=1 pi i ,
α

!

k

ϕ(n) = ϕ

∏

i =1

α
pi i

k

=∏

i =1

α
pi i



1
1−
pi



k

= n∏

i =1



1
1−
pi



Este teorema parece algo extraño, ¿para qué usar fracciones si podemos calcular ϕ(n) con enteros?. Es cierto. Pero esta forma de expresar ϕ será de mucha utilidad más adelante cuando
aparezcan los factores 1 − 1/pi en productos infinitos.
Ejemplo 4.12
Muestre que ϕ(n) = n/2 ⇐⇒ n = 2α .
Solución: Si n = 2α el resultado es directo. En la otra dirección, si n = ∏ik=1 pi i y ϕ(n) =
n/2, entonces ϕ(n) = n ∏ik=1 (1 − 1/pi ) = n/2, es decir, ∏ik=1 (1 − 1/pi ) = 1/2, por tanto
k = 1 y p1 = 2, sino tendríamos una contradicción pues si k > 1, entonces ∏ik=1 (1 −
1/pi ) < 1/2. Finalmente, n = 2α
α

Por ahora, vamos a establecer un lema análogo al lema (4.1): a ϕ(m) ≡ 1 (mod m) si mcd ( a, m) = 1.
Para familiarizarnos, veamos primero un ejemplo.
Ejemplo 4.13
ϕ(12) = 4 cuenta los primos relativos con 12 que son inferiores a 12, es decir 1, 5, 7, 11.
Ahora, mcd (12, 35) = 1 y 35 · 1 ≡ 11 (mod 12), 35 · 5 ≡ 7 (mod 12), 35 · 7 ≡ 5 (mod 12)
y 35 · 11 ≡ 1 (mod 12).
Así, {35 · 1, 35 · 5, 35 · 7, 35 · 11} es una permutación módulo 12 de {1, 5, 7, 11}

80

POTENCIAS mod m

El conjunto de unidades de Zm se denota (Z/mZ)∗ . Este conjunto es un ejemplo de un “sistema reducido de residuos.”
Es claro entonces que |(Z/mZ)∗ | = ϕ(m) y, en particular, |(Z/mZ)∗ | = m − 1 si y solo si m es
primo.

Lema 4.3
Sea m entero positivo y mcd ( a, m) = 1. Sean r1 , r2 , . . . , r ϕ(m) los ϕ(m) enteros positivos < m y
primos relativos con m. Entonces el conjunto de residuos R = { rem( a · r j , m) : j = 1, ..., ϕ(m)}
es una permutación módulo m de los enteros r1 , r2 , . . . , r ϕ(m) .

Prueba: Como el conjunto de residuos R = {rem( a · r j , m) : j = 1, ..., ϕ(m)} ⊆ {r1 , r2 , . . . , r ϕ(m) },
solo hay que demostrar que R tiene ϕ(m) elementos distintos y todos primos relativos con m .
Así, estos ϕ(m) números son inferiores a m y coprimos con m, entonces constituyen una permutación módulo m de r1 , r2 , . . . , r ϕ(m) .
Pimero observemos que cada ri ∈ {1, 2, ..., m − 1} y son todos distintos, por tanto si i 6= j; ri y
r j están en clases de equivalencia distintas y no pueden ser congruentes.
Sea i 6= j con i, j ∈ {1, ..., ϕ(m)}. Si a · ri ≡ a · r j (mod m) entonces, como mcd ( a, m) = 1, podemos cancelar a y nos queda ri ≡ r j (mod m), pero esto no puede pasar.
Si mcd ( a · ri , m) > 1 entonces sea p un divisor primo de a · ri y de m. Si p| a · ri , entonces p|ri
o p| a. Pero esto no puede pasar pues si p|ri , como p|m entonces contradice el hecho de que
mcd (ri , m) = 1. Por otra parte p| a contradice el hecho de que mcd ( a, m) = 1.

De nuevo, vamos a dar un ejemplo antes de enunciar el teorema de Euler.

Ejemplo 4.14
ϕ(12) = 4 cuenta los primos relativos con 12 que son inferiores a 12, es decir 1, 5, 7, 11.
Ahora, mcd (12, 35) = 1 y 35 · 1 ≡ 11 (mod 12), 35 · 5 ≡ 7 (mod 12), 35 · 7 ≡ 5 (mod 12)
y 35 · 11 ≡ 1 (mod 12).
Luego,
354 (1 · 5 · 7 · 11)

≡ (35 · 1)(35 · 5)(35 · 7)(35 · 11) (mod 12)
≡ (11 · 7 · 5 · 1) (mod 12)

∴ 354

≡ 1 (mod 12)

81

pues mcd (11 · 7 · 5 · 1, 12) = 1.

Teorema 4.10 (Teorema de Euler).
Sea m entero positivo y mcd ( a, m) = 1, entonces
a ϕ(m) ≡ 1 (mod m)

Prueba: Sean r1 , r2 , . . . , r ϕ(m) ϕ(m) los enteros positivos ≤ m y primos relativos con m. Entonces,
por el lema (4.3),

a ϕ ( m ) (r1 · r2 · · · r ϕ(m) )

≡ ( a · r1 )( a · r2 ) · · · ( a · r ϕ(m) ) (mod m)
≡ (r1 · r2 · · · · r ϕ(m) ) (mod m)

∴ a ϕ(m)

≡ 1 (mod m)

pues mcd (r1 · r2 · · · · r ϕ(m) , m) = 1.

Ejemplo 4.15

ϕ(6566304875)

=

ϕ(53 · 132 · 310831)

= 52 (5 − 1) · 13(13 − 1) · (310831 − 1)
= 4848948000.

ϕ(15)

=

ϕ(3 · 5) = ϕ(3) ϕ(5) = 2 · 4 = 8, pues mcd (3, 5) = 1.

Ejemplo 4.16
Calcular Ord39 (4).
Solución: Como ϕ(39) = 24, Ord39 (4)|24. Por tanto, debemos probar solo con los
divisores di de 24 hasta que 4id ≡ 1 (mod 39).

82

POTENCIAS mod m

4

≡

rem(4, 39)

4

2

≡

rem(16, 39)

4

3

≡

rem(25, 39)

4

6

≡

rem(1, 39)

Ord39 (4) = 6.

4.3.1

Un recíproco del Teorema pequeño de Fermat

Esta es la versión de E. Lucas del recíproco del Teorema pequeño de Fermat: Si p es primo,
ϕ( p) = p − 1 y si p no es primo ϕ( p) < p − 1. Entonces si n − 1 es el más pequeño entero
positivo tal que an−1 ≡ 1 (mod n), n debería ser primo.

Teorema 4.11
Si existe un entero a primo relativo con n tal que an−1 ≡ 1 (mod n) y si as 6≡ 1 (mod n), para
todo s < n − 1, entonces n es primo.

Prueba: De acuerdo a la hipótesis del teorema, Ordn ( a) = n − 1. Si n no fuera primo, ϕ(n) <
n − 1, pero a ϕ(n) ≡ 1 (mod n), contradicción con la definición de orden de un número.

Una versión refinada es

Teorema 4.12
Si a y n son enteros primos relativos tales que tales que an−1 ≡ 1 (mod n) y a(n−1)/q 6≡ 1 (mod n)
para todos los divisores primos q de n − 1, entonces n es primo.

Prueba: Como los divisores propios de n − 1 dividen (n − 1)/q para algún primo q, entonces
Ordm ( a) no divide al entero (n − 1)/q, según la hipótesis del teorema. Por tanto, la única posibilidad es que Ordm ( a) = n − 1. Así, (Z/nZ)∗ tiene n − 1 elementos, entonces n debe ser
primo.

Con este teorema podríamos decidir si n es primo si conocemos la factorización de n − 1.

83

Ejemplo 4.17
Usar el teorema (4.12) para probar que n = 229 es primo.
Solución: n − 1 = 22 · 3 · 19. Para probar que n es primo debemos encontrar 2 ≤ a ≤ 228
tal que a228 ≡ 1 (mod 229) y a(228)/q 6≡ 1 (mod 229) para q = 2, 3, 19. Ahora hacemos una
búsqueda exhaustiva:
a
2
3
4
5
6

rem( an−1 , 229)
1
1
1
1
1

rem( a(n−1)/2 , 229)
228
1
1
1
228

rem( a(n−1)/3 , 229)
1
134
1
94
134

rem( a(n−1)/19 , 229)
203
161
218
61
165

Tabla 4.2. n = 229 es primo según el teorema (4.12).

∴ n = 229 cumple las condiciones del teorema (4.12) para a = 6. Por tanto, n = 229 es
primo.

4.4

Teorema de Wilson

 
n
n!
Sean n, r enteros no negativos. Recordemos que 0! = 1 y si n ≥ r,
=
. Se puede
r
r!
(
n
− r )!
 
n
probar que
es un entero procediendo por inducción y usando la identidad de Pascal:
r
  



n
n−1
n−1
=
+
r
r−1
r
El teorema del binomio establece que si x, y ∈ R y n no negativo,
n  
n k n−k
( x + y)n = ∑
x y
k
k =0
Se asume como convenio que 00 = 1 para el caso especial x 6= 0, y = 0, n = 0.

Teorema 4.13
 
 p
Si p es primo y 0 < r < p, entonces p 
r
 
p
Prueba:
es un entero así que r!( p − r )!| p!. Como p - r! y p - (( p − r )!), entonces p - r!( p − r )!.
r
Así r!( p − r )!| p! ∧ mcd ( p, r!( p − r )!) = 1 =⇒ r!( p − r )!|( p − 1)!.
 
p
( p − 1) !
∴
= p·
.
r!( p − r )!
r

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

84

POTENCIAS mod m

Teorema 4.14
Si p es primo, entonces ( x + y) p ≡ x p + y p (mod p) si x, y ∈ Z.
 
 p
si r = 1, 2, . . . , p − 1, entonces
Prueba: Como p 
r
 
 


 
p p
p 1 p −1
p
p p
( x + y) p ≡
y +
x y
+ ··· +
x p −1 y 1 +
x (mod p)
0
1
p−1
p

≡ 1 · y p + 0 + · · · + 0 + 1 · x p (mod p)

p

p

p

En general, si p es primo, entonces ( x1 + x2 + · · · + xn ) p ≡ x1 + x2 + · · · + xn (mod p) si xi ∈ Z.

Teorema 4.15
Sea p primo y P( x ) = an x n + · · · + a1 x + a0 ∈ Z[ x ] con an 6≡ 0 (mod p). Entonces la ecuación
P( x ) ≡ 0 (mod p) tiene a lo sumo n soluciones (enteras) distintas módulo p.
Prueba: La prueba es por inducción sobre el grado de P. .
Si n = 0 no hay soluciones pues a0 6≡ 0 (mod p).
Si n = 1, la congruencia a1 x + a0 ≡ 0 (mod p) tiene una solo solución (módulo p) pues a1 x ≡
− a0 (mod p) tiene solución única módulo p si mcd ( a1 , p) = 1.
Supongamos que el resultado es cierto para polinomios de grado ≤ n − 1. Para el resto de la
prueba vamos a razonar por contradicción: Supongamos que P( x ) = an x n + · · · + a1 x + a0 tiene
s > n soluciones a1 , a2 , ..., as distintas módulo p. Consideremos ahora
Q( x ) = P( x ) − an ( x − a1 )( x − a2 ) · · · ( x − an ).
Observe que Q es de grado ≤ n − 1 pues
Q( x ) = P( x ) − an ( x − a1 )( x − a2 ) · · · ( x − an ) = an x n + ... − ( an x n + ...)
y tiene al menos n raíces pues Q( x ) ≡ 0 (mod p) si x = a1 , x = a2 , ..., an . Por hipótesis de inducción, como Q tiene grado n − 1, la única posibilidad es que Q sea el polinomio nulo, es decir,
Q( x ) ≡ 0 (mod p) para toda x ∈ Z. En particular, Q( as ) ≡ 0 (mod p), Entonces

Q( as )

≡

P( as ) − an ( as − a1 )( as − a2 ) · · · ( as − an ) (mod p)

≡ − an ( as − a1 )( as − a2 ) · · · ( as − an ) (mod p)
≡ 0 (mod p)

85

Luego, p| an ( as − a1 )( as − a2 ) · · · ( as − an ) y como p - an , p divide algún factor ( as − a j ) con lo
que a j ≡ as (mod p) en contradicción con nuestra hipótesis.

Teorema 4.16
Sea p primo. Entonces,
x p−1 − 1 ≡ ( x − 1)( x − 2) · · · ( x − p + 1) (mod p)
Prueba: Como p es primo y como p es coprimo con 1, 2, ..., p − 1, por el teorema de Euler tenemos, x p−1 ≡ 1 (mod p) para x = 1, 2, ..., p − 1. Entonces, x p−1 − 1 es un polinomio con p − 1
raíces. Usando el teorema (4.15) tenemos
x p−1 − 1 ≡ ( x − 1)( x − 2) · · · ( x − p + 1) (mod p) si x = 1, 2, ..., p − 1
Pero, como Q( x ) = x p−1 − 1 − ( x − 1)( x − 2) · · · ( x − p + 1) tiene grado ≤ p − 2 y p − 1 raíces,
Q( x ) ≡ 0 (mod p), es decir,
x p−1 − 1 ≡ ( x − 1)( x − 2) · · · ( x − p + 1) (mod p) si x ∈ Z

Teorema 4.17 (Teorema de Wilson).
p es primo si y solo si ( p − 1)! ≡ −1 (mod p)
Prueba: Si p es primo, por el teorema (4.16),
x p−1 − 1 ≡ ( x − 1)( x − 2) · · · ( x − ( p − 1)) (mod p) para cualquier x ∈ Z.
Poniendo x = 0, −1 ≡ (−1) p−1 1 · 2 · · · ( p − 1) (mod p). Si p es impar, obtenemos el resultado.
Si p = 2 el resultado es directo.
Si ( p − 1)! ≡ −1 (mod p) y p tiene un divisor d, 1 < d < p, entonces d|( p − 1)! + 1 pero
d|( p − 1)! pues 1 < d < p, así que d|1, contradicción.

Es claro que no es práctico usar este teorema para verificar si p es o no primo.

4.5

Teorema de Carmichael

El cálculo del orden de un número a puede ser complicado. Algo que nos puede ayudar es saber
que este orden es inferior a ϕ( a) y un factor de la función λ( a) de Carmichael.

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

86

POTENCIAS mod m

Definición 4.3 (Función de Carmichael).
Sean p, p1 , p2 , ..., ps primos, la función λ se define así:
λ (1)
λ (2)
λ (4)
λ (2α )
λ( pα )
λ(n)

=
=
=
=
=
=











1,
1,
2,
2α −2
ϕ ( p α ) = p α −1 ( p − 1 )
α
α
mcm (λ( p1 1 ), λ( p2α2 ), . . . , λ( pk k ))

si α ≥ 3,
si pi ≥ 3 y α ≥ 1,
α
si n = ∏ik=1 pi i










Ejemplo 4.18
λ(1) = 1, λ(2) = 1, λ(3) = 2, etc.
n
λ(n)

1
1

2
1

3
2

4
2

5
4

6
2

7
6

8
2

9
6

10
4

100
20

101
100

102
16

103
102

Teorema 4.18 (Teorema de Carmichael).
Sean a, n ∈ Z+ y mcd ( a, n) = 1. Entonces
aλ(n) ≡ 1 (mod n)
Prueba: n = ∏ik=2 2α pi i , pi primo y mcd ( a, n) = 1. Por la definición de la función λ, se tiene
α

α

(1)

aλ(2 ) ≡ 1 (mod 2α )

(2)

a λ ( p1

α1

)

α
λ ( p2 2 )

(3)

a
...

(k)

aλ( pk

αk

)

≡ 1 (mod p1α1 )
≡ 1 (mod p2α2 )
α

≡ 1 (mod pk k )

Ahora, en la primera congruencia, elevamos a ambos lados a la potencia entera λ(n)/λ(2α ) y en
α
la congruencia i −ésima elevamos a ambos lados a la potencia entera λ(n)/λ( pi i ), obtenemos
aλ(n) ≡ 1 (mod 2α )
α
aλ(n) ≡ 1 (mod p1 1 )
aλ(n) ≡ 1 (mod p2α2 )
...
α
λ
(
n
)
a
≡ 1 (mod pk k )
Para concluir, recordemos que si m1 , m2 , ..., mk ∈ Z+ y si a ≡ b (mod mi ), i = 1, 2, ..., k; entonces
a ≡ b (mod mcm (m1 m2 · · · mk )). Usando este hecho, podemos concluir que aλ(n) ≡ 1 (mod n).

¿Se gana algo usando λ(n) en vez de ϕ(n)? Con un esfuerzo razonablemente pequeño,
podemos obtener, en general, mejores resultados con λ.

87

Ejemplo 4.19
Sea n = 65520 = 24 · 32 · 5 · 7 · 13. Entonces ϕ(n) = 8 · 6 · 4 · 6 · 12 = 13824 mientras que
λ(n) = mcm (4, 6, 4, 6, 12) = 12. Entonces, si mcd ( a, n) = 1,
aλ(n) ≡ 1 (mod 65520) =⇒ a12 ≡ 1 (mod 65520)
a ϕ(n) ≡ 1 (mod 65520) =⇒ a13824 ≡ 1 (mod 65520)
Para encontrar el orden de a, se puede probar con los divisores de 12 en vez de calcular
y usar los divisores de 13824

Ejemplo 4.20
Calcular Ord39 (4).
Solución: Como λ(39) = 12, Ord39 (4)|12. Por tanto, debemos probar solo con los
divisores di de 12 hasta que 4id ≡ 1 (mod 39).
4
42
43
46

≡
≡
≡
≡

rem(1, 39)
rem(16, 39)
rem(25, 39)
rem(1, 39)






=⇒ Ord39 (4) = 6.





Uno de los resultados importantes es: λ(n) es el más pequeño entero positivo para tal que aλ(n) ≡
1 (mod m) para todo a tal que mcd ( a, m) = 1 (ver [1]).
λ(n) y ϕ(n) si mcd ( a, n) > 1 . El teorema de Euler y Carmichael requieren mcd ( a, n) = 1. Sin
embargo hay una versión útil para el caso en que mcd ( a, n) no sea necesariamente 1.

Teorema 4.19
Sea d = mcd ( a, n),
 n
= 1.
a ϕ(n)+1 ≡ a (mod n) ⇐⇒ mcd d,
d
Si n es producto de primos distintos,
aλ(n)+1 ≡ a (mod n) para cualquier a ∈ Z.

Prueba: Ver ([9], pág. 274).

88

POTENCIAS mod m

Ejemplo 4.21
Sea a = 7 y n = 210, mcd ( a, n) = 7 > 1, ϕ(n) = 48, 749 ≡ 7 (mod 210) y mcd (7, 30) = 1
(también 71 ≡ 7 (mod 210) , 75 ≡ 7 (mod 210), etc.).
Sea n = 2 · 3 · 5 · 7, λ(n) = 12, 213 ≡ 2 (mod 210) , 313 ≡ 3 (mod 210), etc.
Sea n = 22 · 5, en este caso λ(n) = 4 y 25 6≡ 2 (mod n), 35 ≡ 3 (mod n), . . . , 65 6≡ 6 (mod n),
etc.

EJERCICIOS
4.1

Verifique, usando el teorema de Fermat, que 2340 ≡ 1 (mod 11).

4.2

Verifique que 2340 ≡ 1 (mod 31). Ayuda: 25 ≡ 1 (mod 31)

4.3

Verifique que mcd (341, 2) = 1 y 2340 ≡ 1 (mod 341). ¿Es 341 primo?

4.4

Verifique que ϕ(666) = 6 · 6 · 6
n

4.5 Consideremos los números de Fermat, Fn = 22 + 1. Vamos a probar, usando congruencias, que si n 6= m, mcd ( Fn , Fm ) = 1. Para probar esto, vamos a suponer, por contradicción, que
mcd ( Fn , Fm ) = d > 1. Entonces hay un primo p tal que p| Fn y p| Fm . Bajo esta suposición,
n

a) verifique que 22 ≡ −1 (mod p),
n +1

b) verifique que 22 ≡ 1 (mod p).
c) Sea Ord p (2) = 2s . ¿Porqué 2s ≤ n + 1 ?
d) Verifique que s  n. Ayuda: considere 2n = 2s 2t con s + t = n y obtenga una contran
dicción con 22 ≡ −1 (mod p).
e) Deduzca que el orden de 2 módulo p es 2n+1
f) Deduzca que el orden de 2 módulo p debería ser también 2m+1
g) ¿Cuál es la contradicción?
4.6 Use el resultado anterior para dar otra prueba de que los primos son un conjunto infinito.
Ayuda: para cada Fn considere uno de sus divisores primos.
4.7

Sea mcd ( a, m) = 1 y Ordm ( a) = t. Si i, j ∈ Z, ai ≡ a j (mod m) ⇐⇒ i ≡ j (mod t).

4.8 Muestre que si m es compuesto y mcd ( a, m) = 1, entonces Ordm (b) < m − 1. Ayuda: Use
el teorema de Euler.
4.9 Muestre que si p es primo y t - ( p − 1), entonces no pueden haber elementos de orden t
en Z p . Ayuda: Use Fermat.
4.10

Sea Ordm ( a) = t. Muestre que Ordm ( ai ) = t si y solo si mcd (i, t) = 1.

4.11

Calcule Ord13 (5) y Ord13 (7)

4.12

Sea mcd ( a, m) = 1. Muestre que Ordm ( a) divide a φ(m).

4.13

Muestre que si p es primo y mcd ( a, p) = 1, entonces Ord p ( a)| p − 1.

EJERCICIOS

89

4.14 Muestre que si Ordm ( a) = t y k es cualquier entero positivo, entonces Ordm ( ak ) = 1 si y
solo si mcd (t, k) = 1.
4.15

Sean a = 7 y m = 310.
a) Calcule ϕ(m) y λ(m).
b) ¿Se puede afirmar, sin calcular, que aλ(m) ≡ 1 (mod m) ?
c) Obtenga Ordm ( a) Ayuda: solo debe probar con los divisores de λ(m).

4.16

Sean a = 7 y m = 210.
a) ¿Tiene sentido hablar de Ordm ( a) ?
b) Calcule s tal que as ≡ a (mod m).

4.17

Calcule Ord2337 (2)

4.18 Muestre que si p es primo y Ord p ( a) = t, entonces las soluciones, módulo p, de x t − 1 ≡
0 (mod p) son {1, a, a2 , ..., at−1 }. ¿porqué no hay más soluciones módulo p?
4.19 Sea p primo impar. Muestre que si P( x ) es un polinomio con coeficientes enteros de
grado n ≥ 1 y coeficiente principal an 6≡ 0 (mod p), entonces hay un polinomio Q( x ) ∈ Z[ x ] de
grado 0 < m < p tal que P( x ) ≡ Q( x ) (mod p).
4.20

Muestre el teorema “pequeño” de Fermat usando el teorema de Euler.

4.21

Muestre el teorema de Euler usando el teorema de Carmichael.

4.22 Muestre que si n es par entonces ϕ(2n) = 2ϕ(n) y que si n es impar entonces ϕ(2n) =
2ϕ(n). Ayuda: Teorema (4.8).
4.23

Calcule ϕ(25) usando el teorema (5.2).

4.24

Factorizar n = 2337 y calcular ϕ(n) y λ(n)

4.25

Calcule las raíces (si hubiera) de P( x ) = x5 + 1 módulo 5

4.26

Calcule las raíces (si hubiera) de P( x ) = x5 − 1 módulo 5

4.27 Calcule 96−1 módulo 97. Luego calcule el resto de dividir 95! por 97. Ayuda: Fermat y
Wilson.
4.28 Sea p primo impar y mcd ( a, p) = 1. Mostrar que a( p−1)/2 ≡ 1 (mod p) o a( p−1)/2 ≡
−1 (mod p). Ayuda: Usar la tercera fórmula notable y el teorema de Fermat.
4.29 Resuelva 7x ≡ 1 (mod 26 · 3 · 5 · 17) usando primero el teorema pequeño de Fermat y luego
usando el teorema de Carmichael.
p

p

p

4.30 Mostrar que si p es primo, entonces ( x1 + x2 + · · · + xn ) p ≡ x1 + x2 + · · · + xn (mod p) si
xi ∈ Z.
4.31

Sean mcd ( a, b) = 1 y S = a ϕ(b) + b ϕ(a) . Muestre que S ≡ 1 (mod ab)

4.32 Use el teorema “pequeño” de Fermat para probar que si p es primo y mcd ( p, n) = 1 y
p|4n2 + 1, entonces p ≡ 1 (mod 4). Ayuda: Muestre que p 6≡ 3 (mod 4) por contradicción: Si
p = 4k + 1 y si y = 2n, y2 ≡ −1 (mod p) luego, como mcd ( p, y) = 1, aplique Fermat.
4.33

Muestre que si p es primo y mcd ( p, n) = 1 y p|n2 + 1, entonces p ≡ 1 (mod 4) o p = 2.

4.34 Muestre que en Z8 , el polinomio P( x ) = x2 − 1 tiene 4 raíces: x = 1, 3, 5, 7, es decir,
P(1) ≡ 0 (mod 8), etc. ¿Contradice esto el teorema (4.15)?

90

POTENCIAS mod m

4.35

Muestre el teorema “pequeño” de Fermat usando el teorema del binomio. Ayuda: xi = 1.

4.36 Muestre que si a ≡ 1 (mod 2), entonces a2 ≡ 1 (mod 23 ) . Ayuda: a = 2h + 1, eleve al
cuadrado y observe que h(h + 1) es par.
2

4.37

Muestre que si a2 ≡ 1 (mod 23 ) entonces a2 ≡ 1 (mod 24 ).

4.38

Use inducción para demostrar que si α > 2, entonces a2

4.39

Verifique que si α > 2, entonces a 2 ϕ(2 ) ≡ 1 (mod 2α ).

4.40

Muestre que si n = ∏ik=1 pi i , pi primo; entonces λ( pi i )|λ(n)

4.41

Muestre que λ(n)| ϕ(n)

4.42

Muestre que λ(n) = ϕ(n) si n = 1, 2, 4, pα , 2pα

1

α −2

≡ 1 (mod 2α ).

α

α

α

EJERCICIOS

91

Versión actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

5
5.1

RAÍCES PRIMITIVAS Y
LOGARITMO DISCRETO

Introducción

Se puede demostrar que si p es primo, existe b ∈ Z tal que Z p = {Z p = {0, b, b2 , ..., b p−1 }. A b
se le llama “raíz primitiva” módulo p. Como cualquier elemento a ∈ Z p debe ser una potencia
de b, tiene sentido definir un logaritmo discreto (indicador) que resulta tener propiedades similares al logaritmo usual. Es muy útil en el cálculo de residuos y para resolver algunos tipos de
ecuaciones congruenciales. Las raíces primitivas módulo n son usadas a menudo en criptografía.

5.2

Raíces Primitivas

Definición 5.1 (Raíces primitivas).
Sea m ∈ Z+ y mcd ( a, m) = 1. Si Ordm ( a) = ϕ(m) entonces a se dice raíz primitiva módulo m

Teorema 5.1
Si p es primo y b raíz primitiva módulo p, entonces Z p = {0, b, b2 , ..., b p−1 }.

Prueba: Ejercicio.

Ejemplo 5.1
Ord5 (3) = 4 pues 32 ≡ 4 (mod 5), 33 ≡ 2 (mod 5) y 34 ≡ 1 (mod 5). Entonces,
Z5 = {0, 3, 32 , 33 , 34 }

Existencia de las raíces primitivas. Para establecer la existencia de las raíces primitivas en
cualquier Z p , p primo; necesitamos algunos resultados.
El teorema que sigue establece que

∑ ϕ(d) = n.

Para la demostración, se usa un conjunto

d|n
d >0

Sd = { d1 , 2d , . . . , dd } y otros conjuntos de fracciones irreducibles (disjuntos):


i
Td =
∈ Sd tal que mcd (i, d) = 1 .
d
La idea es contar la cantidad de primos relativos como el número de fracciones irreducibles. El
siguiente ejemplo muestra la idea de la prueba.
Ejemplo 5.2
Sea n = 4. Los divisores positivos de 4 son 1, 2, 4. Entonces,



S4 =

Observemos que Ti

T


1 2 3 4
, , ,
4 4 4 4


1 3
,
T4 =
4 4
 
1
T2 =
2
 
1
T1 =
1

=⇒ |S4 | = 4
=⇒ | T4 | = ϕ(4) = 2
=⇒ | T2 | = ϕ(2) = 1
=⇒ | T1 | = ϕ(1) = 1

Tj = ∅ y que |S4 | = | T4 | + | T2 | + | T1 |, es decir,

4 = ϕ (1) + ϕ (2) + ϕ (4)

Teorema 5.2
Sea n un entero positivo, entonces

∑ ϕ(d) = n

d|n
d >0

93

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

94

RAÍCES PRIMITIVAS Y LOGARITMO DISCRETO

Prueba: Sea Sn = { n1 , n2 , . . . , nn } y sea Tn = { ni ∈ Sn tal que mcd (i, n) = 1}. Claramente |Sn | = n
y | Tn | = ϕ(n). Ahora, si d|n, d > 0; Td = { di ∈ Sd tal que mcd (i, d) = 1}, entonces
Sn =

[

Td = T1 ∪ . . . ∪ Tn

d|n
d >0

En efecto,
“⊆ ”:

i
∈ Sn tenemos dos casos. Si mcd (i, n) = 1,
n

i
n

∈ Tn . Si

i
no está en forma reducida,
n

i
k
=
con
n
h
∈ Th y por tanto está en la unión de los “Td ’s”.

entonces, usando la factorización prima de i y de n, simplificamos y nos queda
mcd (k, h) = 1 y 1 ≤ k ≤ h. Como h|n, entonces
“⊇ ”: Ahora si s ∈

S

d|n Td ,
d >0

k
h

entonces s ∈ Th para algún h|n. Por tanto, s =

y 1 ≤ j ≤ h. Si n = k0 h, se tiene jk0 ≤ n, así s =

j
con mcd ( j, h) = 1
h

j
k0 j
= 0 ∈ Sn .
h
kh

Si d y d0 son divisores distintos de n, Td ∩ Td0 = ∅. Esto es así pues si s está en esta la interj
i
sección, s = = 0 =⇒ id = jd0 y entonces, como mcd ( j, d) = mcd (i, d0 ) = 1, d|d0 y d0 |d. Esto
d
d
contradice que d 6= d0 .
Finalmente, |Sn | =

∑ |Td |, entonces, como |Td | = ϕ(d), n = ∑ ϕ(d).

d|n
d >0

d|n
d >0

El teorema (5.2) nos da una fórmula recursiva para calcular ϕ(n). No es un fórmula adecuada
para cálculos porque requiere todos los divisores (primos y compuestos) de n

Ejemplo 5.3
Como ϕ(1) = 1, ϕ(3) = 2 y ϕ(5) = 4, entonces
ϕ(1) + ϕ(3) + ϕ(5) + ϕ(15) = 15 =⇒ ϕ(15) = 8.

Teorema 5.3
Sea p primo y t un entero positivo. Si t - ( p − 1) entonces Z p no tiene elementos de orden t. Si
t|( p − 1), hay exactamente ϕ(t) elementos de orden t en Z p
Prueba: De acuerdo al teorema “pequeño” de Fermat, para cada a ∈ Z p , a 6= 0, a p−1 ≡ 1 (mod p).
Luego, si a es de orden t, t|( p − 1), o lo que es lo mismo, si t - ( p − 1) no hay elementos de
orden t.
Para probar la segunda parte, definimos una nueva función ψ(t) : Para cada entero positivo s
que divide a p − 1, sea ψ(s) el número de elementos de orden s en Z p . Ahora, como cada

95

elemento en Z∗p tiene algún orden s que divide a p − 1, entonces

∑

ψ(t) = p − 1

t|( p−1)

Por el teorema (5.2), ∑t|( p−1) ϕ(t) = p − 1, entonces

∑

( ϕ(t) − ψ(t)) = 0

t|( p−1)

Pero, para cualquier entero t, no hay elementos de orden t o hay exactamente ϕ(t) elementos
de orden t; entonces ϕ(t) − ψ(t) ≥ 0 para todo t. Como los sumandos son ≥ 0 y la suma da
cero, cada sumado vale cero: ϕ(t) = ψ(t) para cada t|( p − 1).

Corolario 5.1 Si p es primo, en Z p hay ϕ( p − 1) elementos de orden p − 1, es decir, hay ϕ( p − 1)
raíces primitivas.

Ejemplo 5.4
Cuando tenemos un primo pequeño, podemos localizar las raíces primitivas por “ensayo
y error”, construyendo una tabla de potencias.
a
1
2
3
4
5
6

a1
1
2
3
4
5
6

a2
1
4
2
2
4
1

a3
1
1
6
1
6
6

a4
1
2
4
4
2
1

a5
1
4
5
2
3
6

a6
1
1
1
1
1
1

Ord7 ( a)
1
3
6
3
6
2

Tabla 5.1. Potencias de los elementos de Z7

Solo hay ϕ(6) = 2 raíces primitivas módulo 7, 3 y 5 tienen orden 6, es decir, son las
únicas dos raíces primitivas módulo 7. También, por ejemplo, Z7 = {0, 5, 52 , 53 , 54 , 55 , 56 }.

Ejemplo 5.5
La tabla que sigue es un listado de las raíces primitivas de los primeros seis primos.

96

RAÍCES PRIMITIVAS Y LOGARITMO DISCRETO

p
2
3
5
7
11
13

ϕ ( p − 1)
1
1
2
2
4
4

Raíces primitivas
1
2
2, 3
3, 5
2, 6, 7, 8
2, 6, 7, 11

Tabla 5.2. Raíces primitivas módulo p

Si b es raíz primitiva del primo p, hay ϕ( p − 1) raíces primitivas no congruentes, a saber,
bα1 , bα2 , ..., bα ϕ( p−1) , donde α1 , α2 , ..., α ϕ( p−1) son los ϕ( p − 1) enteros menores que p − 1 y coprimos con p − 1.

Ejemplo 5.6
Determinar las raíces primitivas de 17 sabiendo que 3 es raíz primitiva módulo 17.
Solución: Como ϕ(17) = 8, los ocho enteros menores que 16 y coprimos con 16 son
1, 3, 5, 7, 9, 11, 13 y 15. Así, la raíces primitivas son 33 , 35 , 37 , 39 , 31 1, 31 3. Haciendo la
reducción a módulo 17, no queda 3, 10, 5, 11, 14, 7, 12, 6.

Ya probamos la existencia de raíces primitivas para p primo. El siguiente teorema define la
situación general.

Teorema 5.4 (Gauss).
Un entero n > 1 tiene raíces primitivas módulo n si y solo si n = 2, 4, pα o 2pα donde p es
primo impar y α entero positivo.

En particular, todos los primos tienen raíces primitivas.

Ejemplo 5.7
Los primeros n para los que hay raíces primitivas son 2, 3, 4, 5, 6, 7, 9, 10, 11, 13,
14, 17, 18, 19, 22, ... . En particular, no hay raíces primitivas módulo n = 24 = 16.
En resumen, podemos determinar si hay o no hay raíces primitivas módulo n y el cálculo de estas raíces se hace usando “prueba y error” (aunque hay unas pocas técnicas generales de cálculo).

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

97

5.3

Logaritmo discreto o Indicador

El problema que queremos resolver es el siguiente: Si sabemos que a ≡ bk (mod m), ¿Cómo determinar k?
Recordemos que en Zn hay ϕ(n) elementos primos relativos con n.

Definición 5.2 (Sistema reducido de residuos).
Sea n ∈ Z+ . El conjunto { a1 , a2 , ..., a ϕ(n) } es un sistema reducido de residuos módulo n, si
contiene exactamente un elemento de cada una de las clases ri ∈ Zn para las que mcd (ri , n) = 1.

Ejemplo 5.8
Si n = p es primo, {1, 2, ..., p − 1} es un sistema reducido de residuos módulo p.
Si n = 10, ϕ(10) = 4. En este caso, {1, 3, 7, 9} es un sistema reducido de residuos módulo
10.

Claramente, si b es una raíz primitiva módulo n, el conjunto {b, b2 , ..., b ϕ(n) } es un sistema
reducido de residuos. Entonces, si a ∈ Zn con mcd ( a, n) = 1, existe 1 ≤ k ≤ ϕ(n) tal que
a ≡ bk (mod n). En particular 1 ≡ b ϕ(n) (mod n), por el teorema de Euler.

Definición 5.3
Sea b una raíz primitiva módulo n. Si mcd ( a, n) = 1, entonces el más pequeño entero positivo
k tal que a ≡ bk (mod n) se denota con Indb ( a) y se llama indicador de a respecto a la base b
módulo n.

Entonces tenemos,
a ≡ bIndb (a) (mod n)

A veces se pone Indb ( a) = logb a y se le llama “logaritmo discreto”.
Propiedades.Las propiedades de Indb ( a) son similares a las de la función logaritmo.

98

RAÍCES PRIMITIVAS Y LOGARITMO DISCRETO

Teorema 5.5
Sea b raíz primitiva módulo n y mcd ( a, n) = mcd (c, n) = 1. Entonces,
a.) b x ≡ by (mod n) ⇐⇒ x ≡ y (mod ϕ(n))
b.) Indb (1) ≡ 0 (mod ϕ(n))
c.) Indb ( ac) ≡ [Indb ( a) + Indb (c)] (mod ϕ(n))
d.) Indb ( ak ) ≡ k · Indb ( a) (mod ϕ(n)), si k es entero positivo.

Prueba: Ejercicio.

El teorema 5.5 a.) nos dice que,
a ≡ bk (mod n) ⇐⇒ Indb ( a) = rem(k, ϕ(n))

(5.1)

La reducción módulo ϕ(n) es necesaria para obtener el menor exponente positivo, excepto
cuando 1 ≡ b ϕ(n) (mod n), es claro que, como 1 ≡ b ϕ(n) (mod n), Indb (1) = ϕ(n).
Ejemplo 5.9
Se sabe que b = 5 es raíz primitiva módulo 7 y ϕ(7) = 6,
a.) 2 ≡ 510 (mod 7)
2 ≡ 54 (mod 7).

⇐⇒ Ind5 (2) = rem(10, 6) = 4, es decir, efectivamente

b.) 1 ≡ 56 (mod 7) ⇐⇒ Ind5 (1) = rem(6, 6) = 0, es decir, como efectivamente indica
5.5 b.) , 6 = Ind5 (1) ≡ 0 (mod 6).

Observe que el teorema 5.5 nos dice que “Ind” se puede aplicar igual que se aplican los logaritmos para resolver ecuaciones (siempre y cuando se cumplan las hipótesis),
g( x ) ≡ f ( x ) (mod m) =⇒ Indb ( g( x )) ≡ Indb ( f ( x )) (mod ϕ(m)).
Por supuesto, la aplicación de esta parte del teorema requiere tener a la mano una tabla de
indicadores. En el ejemplo que sigue construimos una breve tabla para Ind2 ( a) módulo 13.
Ejemplo 5.10
Como es usual, para usar el teorema (5.5) necesitamos una tabla de logaritmos discretos.
Por ejemplo, para construir una tabla parcial en base b = 2 módulo 13, calculamos las
potencias de 2 módulo 13.

99

2
4
8
3
6
12

≡
≡
≡
≡
≡
≡

21 (mod 13),
22 (mod 13),
23 (mod 13),
24 (mod 13),
25 (mod 13),
26 (mod 13),

11
9
5
10
7
1

≡ 27 (mod 13),
≡ 28 (mod 13),
≡ 29 (mod 13),
≡ 210 (mod 13),
≡ 211 (mod 13),
≡ 212 (mod 13).

Luego, ponemos la información en una tabla,
a
Ind2 ( a)

1
12

2
1

3
4

4
2

5
9

6
5

7
11

8
3

9
8

10
10

11
7

12
6

Tabla 5.3. Logaritmos discreto base b = 2 módulo 13

Ejemplo 5.11
Resolver 8x5 ≡ 2 (mod 13) con mcd ( x, 13) = 1
Solución: Como b = 2 es raíz primitiva módulo 13 y como conocemos una tabla de logaritmos discretos para esta base, podemos aplicar “Ind2 (·)” a ambos lados de la ecuación
8x5 ≡ 2 (mod 13),
8x5 ≡ 2 (mod 13) =⇒ Ind2 (8x5 ) ≡ Ind2 (2) (mod ϕ(13))
Ahora operamos,
Ind2 (8x5 )
Ind2 (8) + 5Ind2 ( x )
3 + 5Ind2 ( x )
5Ind2 ( x )
Ind2 ( x )
Ind2 ( x )
x

≡
≡
≡
≡
≡
≡
≡

Ind2 (2) (mod ϕ(13))
1 (mod 12),
1 (mod 12),
−2 (mod 12),
−10 (mod 12),
2 (mod 12),
rem(22 , 13),

pues mcd (8, 13) = 1 y mcd ( x, 13) = 1,
pues Ind2 (8) = 3
pues 5 · 5 ≡ 1 (mod 12)
pues − 10 ≡ 2 (mod 12)
por 5.1

Y, efectivamente, 8 · 45 = 8192 ≡ 2 (mod 13).

Ejemplo 5.12
Resolver 23x ≡ 8 (mod 13) .
Solución: Como b = 2 es raíz primitiva módulo 13, podemos aplicar “Ind2 (·)” a ambos
lados,
23x ≡ 8 (mod 13)

=⇒ Ind2 (23x ) ≡ Ind2 (8) (mod 12)
=⇒ 3x ≡ 3 (mod 12)
=⇒ x ≡ 1 (mod 4)

100

RAÍCES PRIMITIVAS Y LOGARITMO DISCRETO

Ahora, los elementos en Z13 que son congruentes con 1 módulo 4 son x = 1, 5, 9.

Ejemplo 5.13
Calcule el residuo de dividir 12729 · 797 por 17.
Solución: 3 es raíz primitiva módulo 17. Así que podemos tomar logaritmo discreto en
base 3. En particular, Ind3 (12) = 13 y Ind3 (7) = 11.
Sea x ≡ 12729 · 797 (mod 17), aplicando logaritmo discreto,
Ind3 ( x ) ≡ Ind3 (12729 · 797 ) (mod 16),
entonces Ind3 ( x ) ≡ 729 · Ind3 (12) + 97 · Ind3 (7) ≡ 9 · 13 + 1 · 11 ≡ 0 (mod 16), es decir,
x ≡ 1 (mod 17.)

Ejemplo 5.14
Probar que la congruencia 25x5 ≡ 17 (mod 71) no tiene solución
Solución: Para aplicar logaritmo discreto a ambos lados, necesitamos una raíz primitiva
módulo 71. Como Ord71 (7) = 70, g = 7 es raíz primitiva módulo 71. En particular,
Ind7 (17) = 49 y Ind7 (25) = 15. Ahora,
Ind7 (25x5 ) ≡ Ind7 (17) (mod 70) ⇔ 5 · Ind7 ( x ) ≡ Ind7 (17) − Ind7 (25) (mod 70), es decir,
5 · Ind7 ( x ) ≡ 34 (mod 70).
Esta última congruencia no tiene solución pues mcd (5, 70) = 5 - 34.

Comparado con el logaritmo común, el logaritmo discreto tiene dos defectos: (1) las tablas se
deben construir para cada módulo primo y hay ϕ( p − 1) posibles bases; (2) los datos en las
tablas no están en orden ascendente.
El siguiente teorema establece algunas fórmulas útiles para el cálculo de índices.

EJERCICIOS

101

Teorema 5.6
Sea b una raíz primitiva módulo m.
a.) Si mcd ( a, m) = 1, entonces Indb ( a−1 ) = ϕ(m) − Indb ( a)
b.) Si m ≥ 3, Indb (m − 1) = ϕ(m)/2
c.) Si p es primo impar, Indb ( p − 1) = ϕ( p − 1)/2
d.) Si m ≥ 3 y mcd ( a, m) = 1, entonces Indb (m − 1) = Indb ( a) + ϕ(m)/2
e.) Si m es primo impar y mcd ( a, m) = 1, entonces Indb (m − 1) = Indb ( a) + ϕ(m − 1)/2

Ejemplo 5.15
Podemos usar la parte e.) del teorema (5.6) para construir una tabla para logaritmo discreto en base 3 módulo 7,
a
Ind3 ( a)

1
6

2
2

3
1

4
.

5
.

6
.

Tabla 5.4. Logaritmos discreto base b = 3 módulo 7

EJERCICIOS
5.1

Muestre que en Z7 , las únicas raíces primitivas son 3 y 5.

5.2

Calcule las raíces primitivas de módulo 71.

5.3 Muestre que si b es raíz primitiva módulo p y b ≡ c (mod p), entonces c es raíz primitiva
módulo p.
5.4 Sea p = 2n + 1. Verifique que si p es primo, entonces n es par Ayuda: Solamente puede
pasar p ≡ 2 (mod 3). Ahora use logaritmo discreto.
5.5

Verifique que no hay raíces primitivas módulo 8.

5.6

Verifique que 8 no es raíz primitiva módulo 13.

5.7

¿Hay raíces primitivas en Z12 ?

5.8

Calcule las raíces primitivas de Z11

5.9 Si p es primo y t un entero, muestre que si en Z p hay elementos de orden t, entonces hay
exactamente ϕ(t) elementos de este orden.
5.10 Sea p primo y Ord p ( a) = t. Muestre que si b ∈ Z p y bt ≡ 1 (mod p), entonces b debe ser
una potencia de a.
5.11
5.12

Construya una tabla para el logaritmo discreto en base 11
Resolver
a) 7x ≡ 13 (mod 18)
b) 2x4 ≡ 5 (mod 13)
c) 85x ≡ 5 (mod 13)

102

RAÍCES PRIMITIVAS Y LOGARITMO DISCRETO

d) 34x+1 ≡ 10 (mod 19)
e) 8x2 ≡ 2 (mod 13) . Sugerencia: x ≡ 2Ind2 ( x) (mod 13) con Ind2 ( x ) ≡ 5 (mod 6) y Ind2 ( x ) ∈
{1, 2, ..., 12} .
5.13

Sea m = m1 m2 con mcd (m1 , m2 ) = 1 y mi ≥ 3.
a) Muestre que si m ≥ 3 , ϕ(m) es par
b) Sea n = ϕ(m1 ) ϕ(m2 )/2 y mcd ( a, m) = mcd ( a, m1 ) = mcd ( a, m2 ) = 1. Muestre que
a ϕ(m1 ) ϕ(m2 )/2 ≡ 1 (mod m1 ) y que a ϕ(m2 ) ϕ(m1 )/2 ≡ 1 (mod m2 )
c) Muestre que an ≡ 1 (mod m)

5.14

Usar logaritmo discreto para encontrar el residuo de dividir 231001 por 13.

EJERCICIOS

103

Versión actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

6
6.1

RESIDUOS
CUADRÁTICOS

Congruencias cuadráticas módulo m

Definición 6.1
Una congruencia cuadrática es una congruencia de la forma
x2 ≡ a (mod m)
donde mcd ( a, n) = 1. Si la congruencia tiene solución, a es llamado residuo cuadrático módulo
m.
Ejemplo 6.1
Calcular los residuos cuadráticos módulo 7.
Solución: Una manera directa es hacer una tabla de cuadrados,
b
Residuo rem(b2 , 7)

1
1

2
4

3
2

4
2

5
4

6
1

←− residuos cuadráticos

Tabla 6.1. Residuos cuadráticos módulo 7

Tenemos,
12 ≡ 62
22 ≡ 52
32 ≡ 42

≡ 1 (mod 7)
≡ 4 (mod 7) =⇒ 1, 2, 4 son residuos cuadráticos mod 7.
≡ 2 (mod 7)

La congruencia Ax2 + Bx + C ≡ 0 (mod p) . Observemos que si p es primo y p - A; la congruencia Ax2 + Bx + C ≡ 0 (mod p) es equivalente a (2Ax + B)2 ≡ B2 − 4AC (mod p) (ver ejercicios),
o lo que es lo mismo, u2 ≡ a (mod p) con u = 2Ax + B y a = B2 − 4AC.
Representación simétrica. En principio podemos decidir si la congruencia x2 ≡ a (mod p)
tiene solución o no, por ensayo y error. La teoría que sigue está orientada a buscar respuestas
a preguntas como ¿cuándo es soluble o no, esta congruencia?, si es soluble, ¿cuántas soluciones
tiene módulo p?. La teoría requiere trabajar con la representación simétrica de Z p .

Zp =


 
p−1
p−1


,
...,
−
1,
0,
1,
...
−


2
2


si p es impar





p−1
p−1


 −
+ 1, ..., −1, 0, 1, ...
2
2

si p es par

En las aplicaciones, el caso común es cuando p es impar. La regla de conversión para pasar de
{0, 1, ..., p − 1} a representación simétrica es sencilla:






−→ i

i




 p−1 +k
2

−→ −

si 0 ≤ i ≤
p−1
+k−1
2

p−1
,
2

con 1 ≤ k ≤

p−1
.
2

Ejemplo 6.2
Consideremos Z7 ,

p−1
= 3.
2
0,
↓
0,

1,
↓
1,

2,
↓
2,

3,
↓
3,

4,
↓
−3,

5,
↓
−2,

6
↓
−1

Si volvemos a calcular como en el ejemplo (6.1), pero esta vez usando la representación simétrica,
se nos hará evidente nuestro siguiente teorema,
b
rem(b2 , 7)

−3
2

−2
4

−1
1

1
1

2
4

3
2

←− residuos cuadráticos mod 7

Tabla 6.2. Residuos cuadráticos módulo 7

Tenemos,

(−1)2 ≡ 12
(−2)2 ≡ 22
(−3)2 ≡ 32

≡ 1 (mod 7)
≡ 4 (mod 7)
≡ 2 (mod 7)

Teorema 6.1
Sea p primo impar y mcd ( a, p) = 1.
a.) x2 ≡ a (mod p) no tiene solución o tiene exactamente dos soluciones mod p,
b.) Hay exactamente
y



p−1
p−1 2
residuos cuadráticos rem(12 , p), rem(22 , p), ..., rem(
, p)
2
2

p−1
residuos no cuadráticos.
2

105

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

106

RESIDUOS CUADRÁTICOS

Prueba: a.) Si x2 ≡ a (mod p) y y2 ≡ a (mod p) entonces p| x2 − y2 =⇒ p| x + y ∨ p| x − y =⇒
x ≡ ±y (mod p).
b.) Sea Z p = {−( p − 1)/2, ..., −1, 0, 1, ..., ( p − 1)/2}. Entonces tenemos ( p − 1)/2 residuos cuadráticos a j con (− j)2 = j2 ≡ a j (mod p), −( p − 1)/2 ≤ j ≤ ( p − 1)/2 y j 6= 0. Claramente son residuos
cuadráticos distintos pues si i 6≡ j (mod p) entonces i2 6≡ j2 (mod p) si i, j ∈ {1, ..., ( p − 1)/2}
(ya que 0 < |i − j| < i + j < p − 1 ). Hay exactamente ( p − 1)/2 residuos cuadráticos pues ya
agotamos los cuadrados en Z p .

En el caso p = 2 el teorema no aplica: sólo hay un residuo cuadrático módulo 2 : 12 ≡ 1 (mod 2).

6.2

Criterio de Euler

Euler divisó un criterio sencillo, para decidir si un número es residuos cuadrático módulo p. El
criterio no es muy práctico computacionalmente pero si de gran valor teórico.
La idea es la siguiente: Si a es residuo cuadrático módulo p, hay un entero x tal que a ≡ p x2 ,
entonces, por el teorema pequeño de Fermat se tiene
a( p−1)/2 ≡ ( x2 )( p−1)/2 ≡ x p−1 ≡ 1 (mod p),
es decir, si a es residuo cuadrático módulo p,
a( p−1)/2 ≡ 1 (mod p).
Ejemplo 6.3
Sea p = 11. Vamos a calcular todas las potencias a( p−1)/2 módulo p en representación
estándar y en representación simétrica,
a
Residuo rem( a( p−1)/2 , p)
Residuo rems ( a( p−1)/2 , p)

1
1
1

2
10
−1

3
1
1

4
1
1

5
1
1

6
10
−1

7
10
−1

8
10
−1

9
1
1

10
10
−1

← estándar
← simétrica

Teorema 6.2 (Criterio de Euler).
Sea p primo impar y mcd ( a, p) = 1, entonces
a.)
b.)

a es residuo cuadrático
a no es residuo cuadrático

⇐⇒ a( p−1)/2 ≡ 1 (mod p),
⇐⇒ a( p−1)/2 ≡ −1 (mod p),

Prueba: Para la demostración usamos el teorema pequeño de Fermat y logaritmo discreto.
La parte a.) requiere probar dos dos direcciones,
Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

107

” =⇒ ” Si a es un residuo cuadrático módulo p, existe x ∈ Z tal que x2 ≡ a (mod p.) Como
mcd( a, p) = 1 entonces mcd( x2 , p) = 1. Ahora aplicamos el teorema pequeño de Fermat,
1

≡ x p−1 (mod p)
≡ ( x2 )( p−1)/2 (mod p)
≡ a( p−1)/2 (mod p)

” ⇐= ” Si a( p−1)/2 ≡ 1 (mod p), sea b una raíz primitiva de p (todos los primos tienen raíces
primitivas) y sea t ∈ Z tal que a ≡ bt (mod p). Entonces,

bt
bt( p−1)/2

=⇒

≡ a (mod p)
≡ a( p−1)/2 ≡ 1 (mod p)

=⇒ Indb (bt( p−1)/2 ) ≡ Indb (1) ≡ 0 (mod p)
=⇒

t( p − 1)/2

=⇒

t ( p − 1)

=⇒



bt/2

2

≡ 0 (mod ( p − 1))
= 2k( p − 1), k ∈ Z, i.e. t es par.
= bt ≡ a (mod p), i.e. a es residuo cuadrático módulo p.

b.). Para probar esta parte se suficiente observar que, por el Pequeño Teorema de Fermat,

( a( p−1)/2 − 1)( a( p−1)/2 + 1) = a p−1 − 1 ≡ 0 (mod p).
Como p es primo, no hay divisores de cero en Z p , por lo que si a no es residuo cuadrático
módulo p, la única opción que queda es a( p−1)/2 ≡ −1 (mod p). La otra implicación es consecuencia de la parte a.)

El criterio de Euler, en su versión cruda, es útil en el cálculo directo si p es pequeño, dado que
tenemos que calcular la potencia a( p−1)/2 .

Ejemplo 6.4
¿Es a = 72 residuo cuadrático módulo 229 ?
Solución: Tenemos que calcular rem(72114 , 229). Para simplificar el cálculo descomponemos en potencias de 2,
72114 = 722 · ((((722 )2 )2 )2 )7 ≡ 228 ≡ −1 mod 229; no es residuo cuadrático.

108

RESIDUOS CUADRÁTICOS

Ejemplo 6.5
Sea p primo impar. Muestre que si b es raíz primitiva módulo p, entonces b no es
residuo cuadrático módulo p.
Solución: Como Ord p (b) = p − 1, entonces b( p−1)/2 6≡ 1 (mod p) y por el criterio de Euler, la única posibilidad es que b( p−1)/2 ≡ −1 (mod p), es decir, b no es residuo cuadrático
módulo p.

6.3

Símbolos de Legendre y Jacobi

El símbolo de Legendre nos permite establecer si un número a es o no es residuo cuadrático
módulo un primo p, mediante un cálculo automático. La ley de la reciprocidad cuadrática, una
de las joyas de la teoría de números, simplifica notablemente este cálculo.
El símbolo de Jacobi es una generalización del símbolo de Legendre que permite una simplificación del cálculo cuando el módulo no es primo.
Los estudios en residuos cuadráticos de Euler fueron extendidos por Legendre. El símbolo de
Legendre nos proporciona una serie de reglas para el cálculo automático. Estas reglas en el
fondo, son aplicaciones simplificadas del criterio de Euler.

Definición 6.2
 
a
Sea p un primo impar y mcd ( a, p) = 1. El símbolo de Legendre
es definido por,
p

  
a
=

p

1

−1

si a residuo cuadrático módulo p
si a no es residuo cuadrático módulo p

En algunos textos se usa una definición alternativa: Si p es primo impar,


  
a
=

p

1
0
−1

si a residuo cuadrático módulo p
si p| a
si a no es residuo cuadrático módulo p

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

109

Ejemplo 6.6
     
 
1
2
4
3
Los residuos cuadráticos de Z7 son 1, 2, 4, es decir,
=
=
=1 y
=
7
7
7
7
   
6
5
=
= −1
7
7
Para el cálculo del símbolo de Legendre es necesario establecer las siguientes propiedades,

Teorema 6.3
Sea p primo impar y mcd( p, a) = mod( p, b) = 1. Entonces,

a.)
b.)
c.)
d.)
e.)

 
a
= rems ( a( p−1)/2 , p) (rems es el residuo en representación simétrica).
p
 
 2
1
a
= 1. En particular
= 1.
p
p
   
  

a
b
a
rem( a, p)
Si a ≡ b (mod p) entonces
=
, En particular,
=
.
p
p
p
p
    
ab
a
b
=
.
p
p
p



−1
1
si p ≡ 1 (mod 4)
(
p
−
1
)
/2
= (−1)
=
−1
si p ≡ −1 (mod 4)
p

Prueba: El item a.) es el criterio de Euler: a( p−1)/2 ≡ 1 (mod p) o a( p−1)/2 ≡ −1 (mod p). Entonces
rems ( a( p−1)/2 , p) = ±1 y el signo depende de que a sea residuo cuadrático o no.

( a2 ,

a2



a2
p

≡ r a (mod p), es decir,
   
b
a
(
p
−
1
)
/2
(
p
−
1
)
/2
=
.
c.): a ≡ b (mod p) =⇒ a
≡b
(mod p). Luego, por a.),
p
p
b.): Sea r a = rems

p). Entonces mcd (r a , p) = 1 y



= 1.

d.): Como a( p−1)/2 ≡ ±1 (mod p) y b( p−1)/2 ≡ ±1 (mod p), entonces ( ab)( p−1)/2 ≡ ±1 (mod p)
y entonces el signo de rems (( ab)( p−1)/2 , p) = ±1 depende de los signos de rems ( a( p−1)/2 , p) y
rems (b( p−1)/2 , p) por separado. En resumen, aplicando a.),



ab
p



=

rems (( ab)( p−1)/2 , p)

=

rems ( a( p−1)/2 b( p−1)/2 , p)

=

  
a
b
p
p

110

RESIDUOS CUADRÁTICOS

e.): Por a.)



−1
p



≡ rems ((−1)( p−1)/2 , p) = (−1)( p−1)/2 (en representación simétrica)

Ahora, como p ∈ Z4 y p es primo impar, entonces las únicas posibilidades son: p ≡ 1 (mod 4)
o p ≡ 3 (mod 4). Si p = 4k + 1 para algún entero k, ( p − 1)/2 = 2k = par. Si p = 4k − 1 para
algún entero k, ( p − 1)/2 = 2k − 1 = impar. Por lo tanto,


−1
p





=

si p ≡ 1 (mod 4)
si p ≡ −1 (mod 4)

1
−1

Corolario 6.1 Sea p primo impar,
a.) Sea mcd (n, p) = 1. Si n = ∏ik=1 pi i es la descomposición prima de n,
α

∏ik=1 pi i
p
α

!

k

=∏

i =1



pi
p

 αi

b.) El producto de dos residuos cuadráticos módulo p es residuo cuadrático módulo p.
c.) El producto de dos residuos no cuadráticos módulo p es residuo cuadrático módulo p.
d.) El producto de un residuo cuadrático y otro no cuadrático módulo p, es un residuo no cuadrático
módulo p.
Prueba: Ejercicio.

Ejemplo 6.7
 
2
= rems (2(5−1)/2 , 5) = rems (4, 5) = −1 por el teorema 6.3 a.).
5

Ejemplo 6.8
El criterio de Euler, bajo el símbolo de Legendre, nos da un criterio rápido para decidir
si a = −1 es o no es residuo cuadrático módulo p.


−1
a.) a = −1 no es residuo cuadrático módulo 3 pues
= (−1)(3−1)/2 = −1
3

111


b.) a = −1 es residuo cuadrático módulo 229 pues

−1
229



= (−1)(229−1)/2 = (−1)114 = 1.

Ejemplo 6.9
En este ejemplo vamos a aver como se aplican algunas de las propiedades del símbolo
de Legendre.

a.) ¿Es 10 residuo cuadrático del primo 3 ?

Solución:

−10
3





=

−1
3



10
3



 
1
=
= −1 por el teorema (6.3), c.).
3

b.) ¿Es 63 residuo cuadrático del primo 11 ?
Solución:



63
11





=


=


=

8
11



2
11



2
11



por (6.3), c.)
22
11


por (6.3), d.)

·1

= −1 · 1

por (6.3), a.)
por cálculo directo.

por tanto 63 no es residuo cuadrático módulo 11.

Ejemplo 6.0 (continuación).
c.) ¿Es 72 residuo cuadrático del primo 229 ?
Solución: Por el corolario (6.1),


72
229





=

23 · 32
229





=

2
229

3 

3
229

2



=1·

2
229



· 1 = −1

112

RESIDUOS CUADRÁTICOS

Ejemplo 6.10
Probar que hay una cantidad infinita de primos de la forma 4k + 1.
Solución: Por contradiccón, supongamos que solo hay una cantidad finita
P = { p1 , p2 , ..., ps } de primos de la forma 4k + 1. Sea N = (2p1 p2 · · · ps )2 + 1. Observemos que si pi ∈ P, N = k0 pi + 1, es decir, los pi ’s no dividen N. Como N es de la
forma 4k + 1 y no es un pi , es compuesto. Entonces sería divisible por un primo p 6∈ P.
Por tanto, −1 es residuo cuadrático módulo p y p debería ser de la forma 4k + 1.
Contradicción.

6.3.1

Lema de Gauss

El lema de Gauss es una herramienta teórica que al igual que el criterio de Euler, nos provee de
método para calcular el símbolo de Legendre vía un conteo de signos.
La idea es la siguiente: Si p es primo impar y mcd ( a, p) = 1, entonces
Z p = {0, a · 1, a · 2, ..., ( p − 1) · a}
Los números a · 1, a · 2, ..., a ·
sentación simétrica, tenemos

p−1
son distintos módulo p. Si consideramos Z p en repre2

p−1
} ⊆
{ a · 1, a · 2, ..., a ·
2



p−1
p−1
−
, ..., −1, 0, 1, ...,
2
2



Por ejemplo, si p = 13 y a = 3, tenemos

3·i
rem(3 · i, 13)

3·1
3

3·2
6

3·3
−4

3·4
−1

3·5
2

3·6
5

Tabla 6.3. Representación simétrica de 3 · i, i = 1, ..., 6

En representación simétrica los números aparecen con una copia positiva y otra negativa, es
decir, aparece el 1 y el −1, el 2 y el −2, etc. Pero, al pasar cada elemento del conjunto
{ a · i, i = 1, ..., ( p − 1)/2} a representación simétrica, solo aparece una copia: aparece el 1 o
el −1, el 2 o el −2, etc.
Ahora, sacando a factor común a y los signos, tenemos
a( p−1)/2 · 1 · 2 · · ·

p−1
p−1
p−1
(−1)ω = a · 1 · a · 2 . . . a ·
≡ 1 · 2···
mod p,
2
2
2

por tanto, cancelando: a( p−1)/2 ≡ (−1)ω (mod p). Así, el número ω de signos “−” en { a·, a ·
p−1
} define si a es residuo cuadrático o no.
2, ..., a ·
2

113

Lema 6.1 (Lema de Gauss).
Sea p primo impar y mcd ( a, p) = 1. Si ω es la cantidad de enteros en el conjunto

{ a · 1 mod p, a · 2 mod p, ..., a ·

p−1
mod p}
2

que son más grandes que ( p − 1)/2 (negativos en representación simétrica), entonces
 
a
= (−1)ω
p
p−1
· a , p)}. En R no hay elementos con2
gruentes pues mcd ( a, p) = 1. Vamos a denotar con r1 , r2 , ..., rk los elementos de R que son
≤ ( p − 1)/2 y s1 , s2 , ..., sω los elementos de R que son > ( p − 1)/2. Por tanto, k + ω = ( p − 1)/2.
Prueba: : Sea R = { rem( a, p), rem(2 · a, p), ..., rem(

Los ( p − 1)/2 enteros r1 , r2 , ..., rk , p − s1 , p − s2 , ..., p − sω son positivos y ≤ ( p − 1)/2. Todos
estos números son distintos módulo p : En efecto, ya conocemos que r1 , r2 , ..., rk , s1 , s2 , ..., sω son
distintos módulo p, como si 6≡ s j (mod p) entonces p − si 6≡ p − s j (mod p). También p − si 6≡
r j (mod p) si i 6= j, 1 ≤ i, j ≤ ( p − 1)/2; para probarlo, supongamos que p − si ≡ r j (mod p),
entonces −si ≡ r j (mod p) =⇒ si + r j ≡ 0 (mod p) pero esto es imposible pues 0 < si + r j ≤
( p − 1)/2. Esto demuestra que

{r1 , r2 , ..., rk , p − s1 , p − s2 , ..., p − sω } = {1, 2, ..., ( p − 1)/2}.
Entonces
1 · 2 · · · ( p − 1)/2

≡ r1 · r2 · · · rk · ( p − s1 ) · ( p − s2 ) · · · ( p − sω ) (mod p)
≡ r1 · r2 · · · rk · −s1 · −s2 · · · − sω (mod p), pues p ≡ 0
sacamos los ω signos “−” a factor común,

≡ (r1 · r2 · · · rk · s1 · s2 · · · sω )(−1)ω (mod p),
≡ ( a · 1 · a · 2 · · · a · ( p − 1)/2)(−1)ω (mod p),
sacamos a a factor común,

≡ ( a( p−1)/2 (1 · 2 · · · ( p − 1)/2)(−1)ω (mod p),
cancelamos,
1
a( p−1)/2

≡ a

( p−1)/2

(−1)ω (mod p), es decir,

≡ (−1)ω (mod p).

 
a
Ahora, por el criterio de Euler,
= (−1)ω .
p
Nota: En la práctica, en vez de contar los signos negativos, contamos los residuos rem( a · i, p) >
p/2. Usamos p/2 en vez de ( p − 1)/2 pues
p−1
p
p−1
p+1
< <
+1=
.
2
2
2
2
El siguiente ejemplo ilustra el cálculo. Recordemos que la importancia del lema es de orden
teórico no computacional.

114

RESIDUOS CUADRÁTICOS

Ejemplo 6.11
¿Es a = 63 residuo cuadrático módulo p = 11 ?
Solución:
{63 · i, i = 1, ..., 5} = {8, 5, 2, 10, 7}. Hay ω = 3 números > Jp/2K = 5. Por tanto
 
63
= (−1)3 = −1. ∴ 63 no es residuo cuadrático módulo 11.
11
Ya sabemos cómo decidir si ±1 es residuo cuadrático módulo p. Podemos aplicar el lema de
Gauss para decidir si 2 es residuo cuadrático módulo p.

Teorema 6.4
Si p es primo impar, entonces
 

2
2
1
= (−1)( p −1)/8 =
−1
p
En particular, si a es par,

si p ≡ ±1 (mod 8)
si p ≡ ±3 (mod 8)

(6.1)



 
a/2
a
2
= (−1)( p −1)/8
.
p
p

 
2
contamos los números en {2 · i, i = 1, ..., ( p − 1)/2} tales que 2 · i >
p
p/2, es decir, i > p/4 (aquí no hay que hacer reducción módulo p pues 0 ≤ 2i ≤ p − 1 ). Entonces 2i > p/2 si Jp/4K < i ≤ ( p − 1)/2. Por lo tanto,

Prueba: Para calcular

ω=

p − 1 r pz
−
.
2
4

Esto nos da
r pz
 
(
p − 1)/2 −
2
4
= (−1)
p
q py
Aquí lo que interesa es saber si ( p − 1)/2 − 4 es par o impar, así que hacemos una reducción
módulo 2 :
p − 1 r p z p2 − 1
≡
−
(mod 2).
(6.2)
2
4
8
Para probar esto último usamos el hecho de que, como p es primo impar, ∃ k ∈ Z tal que
p = 8k + r con r = 1, −1, 3 o −3. Luego,





2k
2k − 1
=

2k
4


2k − 1

r pz

si
si
si
si

r=1
r = −1
r=3
r = −3

En estos cuatro casos se cumple (6.2) y además si r = ±1,
impar.

p2 − 1
p2 − 1
es par y si r = ±3,
es
8
8

115

Aquí solo vamos a probar los casos r = 3 y r = −1, los otros casos son similares.
Si p = 8k + 3, entonces
p − 1 r pz
= 1 + 4k − 2k = 1 + 4k ≡ 1 (mod 2)
−
2
4
p2 − 1
= 1 + 6k + 8k2 ≡ 1 (mod 2). Esto prueba (6.2) para este caso.
8
 
p2 − 1
2
2
Como
es impar,
= (−1)( p −1)/8 = −1 si p ≡ 3 (mod 8)
8
p
Si p = 8k − 1, entonces
p − 1 r pz
= 4k − 1 − (2k − 1) = 2k ≡ 0 (mod 2)
−
2
4
p2 − 1
= −2k + 8k2 ≡ 0 (mod 2). Esto prueba (6.2) para este caso.
8
 
2
p2 − 1
2
es par,
Como
= (−1)( p −1)/8 = 1 si p ≡ −1 (mod 8).
8
p

La idea de la congruencia es muy útil: es más fácil verificar la congruencia que calcular la potencia.
Ejemplo 6.12
a.) ¿Es 2 residuo cuadrático módulo 97 ?

Solución: Sí,

2
97



= 1 pues 97 ≡ 1 (mod 8)

b.) ¿Es 2 residuo cuadrático módulo 229 ?

Solución: No,

6.3.2

2
97



= −1 pues 229 ≡ 3 (mod 8)

Ley de Reciprocidad Cuadrática.

   
p
q
La ley de reciprocidad cuadrática establece una sorprendente relación entre
y
. Esta
q
p
ley fue conjeturada, basándose en evidencia numérica, por Euler en 1783 y Lagrange en 1785.
Legendre le dio la forma actual a esta ley, pero no pudo dar una prueba completa. La primera
prueba rigurosa fue dada por Gauss en a la edad de 18 años. Hasta el 2004 se conocían 190

116

RESIDUOS CUADRÁTICOS

pruebas diferentes. Gauss llamó a este teorema “Aureum Theorema”. Su importancia en la teoría
de números no tienen discusión. Al respecto, Hecke afirmó al respecto: “La teoría de números
moderna comenzó con el descubrimiento de la Ley de Reciprocidad Cuadrática”.
La prueba del teorema sigue es la tercera prueba que dio Gauss. La prueba se basa e un argumento geométrico.
s
{
4·q
Primero veamos un ejemplo concreto. Sea p = 11 y q = 7. El número
= 2 cuenta la
p
4·q
cantidad de números ≤
. Geométricamente corresponde a la cantidad de pares ordenados
p
con componentes enteros (llamados punto reticulares) sobre la parte positiva de la recta x = 4 y
4·q
q
.
por debajo de la recta y = x. Estos puntos son de la forma (4, y) con y ≤
p
p

}
1

2

3

4

5

Tabla 6.4. Puntos reticulares (4, y) con y ≤ 4 ·
11/7

La suma

( p−1)/2 s

∑

k =1

k·q
p

{

1

2

3

4

Tabla 6.5. Puntos reticulares en ABCD

= 7 corresponde a los puntos reticulares en el polígono ABCD de la

figura (6.5).
Podemos cambiar el punto
s
{de vista y ver las cosas desde el eje Y de una manera totalmente
3· p
3· p
simétrica: El número
= 4 cuenta la cantidad de números ≤
. Geométricamente corq
q
responde a la cantidad de de puntos reticulares sobre la parte derecha de la recta y = 3 y por
p
3· p
debajo de la recta x = y. Estos puntos son de la forma ( x, 3) con x ≤
.
q
q
{
(q−1)/2 s
k·p
La suma ∑
= 8 corresponde a los puntos reticulares en el polígono APQR de la
q
k =1
figura (6.1).

117

3

2

1

4

Figura 6.1. Puntos reticulares en APQR

Finalmente, la figura (6.1) también nos sugiere que
( p−1)/2 s

∑

k =1

k·q
p

{

+

(q−1)/2 s

∑

k =1

k·p
q
s

{

= 7 + 8 = 15 =
{

q−1
. La prueba se puede hacer de
2
s
{
p q−1
manera directa y está en los ejercicios. Note que, por simetría, si q > p, entonces
=
q 2
p−1
.
2
Observemos además, que si p > q entonces

q p−1
p 2

p−1 q−1
·
2
2

=

Ahora que hemos establecido el significado geométrico de estas sumas, consideremos el siguiente lema,

Lema 6.2
Sean p, q primos impares distintos. Entonces,
( p−1)/2 s

∑

k =1

k·q
p

{

+

(q−1)/2 s

∑

k =1

k·p
q

{

=

p−1 q−1
·
2
2

Prueba: Sea p > q. El número Jk · q/pK cuenta la cantidad de números ≤ (k · q)/p. Geométricamente corresponde a la cantidad de puntos reticulares sobre la parte positiva de la recta x = k y
por debajo de la recta y = q/p x. Estos puntos son de la forma (k, y) con y ≤ k · q/p.
Cuando x = ( p − 1)/2, la cantidad de puntos es y = (q − 1)/2 pues
q−1
q p−1
q−1
≤
<
+ 1.
2
p 2
2
( p−1)/2

La suma S( p, q) =

∑

k =1

de la figura (6.2).

Jk · q/pK corresponde a la suma de los puntos reticulares en el polígono ABCD

118

RESIDUOS CUADRÁTICOS

...

...

...

...

...
...

Figura 6.2. Puntos reticulares
(q−1)/2

De manera simétrica, la suma S(q, p) =

∑

k =1

Jk · p/qK corresponde a la suma de los puntos

reticulares en el polígono APQR de la figura (6.2).
Hay que notar que no hay puntos reticulares sobre la recta y =

q
x pues mcd ( p, q) = 1.
p

Finalmente, la suma de los puntos reticulares en el polígono ABCR se puede expresar de dos
p−1 q−1
formas:
·
y S(q, p) + S( p, q).
2
2

Teorema 6.5 (Ley de Reciprocidad Cuadrática).
Sea p y q primos impares distintos. Entonces
  
p −1 q −1
p
q
= (−1) 2 2
q
p
 
 
p −1 q −1
p
q
En particular,
= (−1) 2 2
.
q
p
p−1
· q, p)}. Vamos a denotar con r1 , r2 , ..., rk
2
los elementos de R que son > p/2. Claramente

Prueba: Sea R = { rem(q, p), rem(2 · q, p), ..., rem(
los elementos de R que
 son
 ≤ p/2 y s1 , s2 , ..., sω
q
k + ω = ( p − 1)/2 y
= (−1)ω .
p

Los elementos de R son todos distintos. Si i, j ∈ R y i 6= j, entonces i 6≡ p − j (mod p). Así, los
( p − 1)/2 números r1 , r2 , ..., rk , p − s1 , p − s2 , ..., p − sω son todos distintos e inferiores a p/2, por
tanto estos números corresponden a los números 1, 2, ..., ( p − 1)/2 en algún orden. Entonces
k

∑ rk

i =1

( p−1)/2

ω

+

∑ ( p − si )

=

i =1

=

Por tanto,

∑

i

i =1

( p − 1)( p + 1)
8

119

k

∑ ( p − si ) =

i =1

Sea S( p, q) =

k

ω

∑ rk +

i =1

( p−1)/2
Jk · q/pK ,
∑ k =1

S1 =

ω

∑ rk + ωp − ∑ si =

i =1

∑ik=1 rk

i =1

y S2 =

∑iω=1 si .

p2 − 1
8

Con esta notación,

p2 − 1
= S1 + ω · p − S2
8

(6.3)

Por el algoritmo de la división,
kq = Tkq/pU · p + tk con 0 ≤ tk < p.
Entonces,
( p−1)/2

∑

( p−1)/2

∑

k·q=

k =1

k =1

( p−1)/2

Tkq/pU · p +

∑

tk .

k =1

Esto es,
( p−1)/2

q·

∑

k

=

p · S( p, q) + S1 + S2

p2 − 1
8

=

p · S( p, q) + S1 + S2

k =1

q·

(6.4)

Ahora restando (6.3) con (6.4) obtenemos,
p2 − 1
= p · (S( p, q) − ω ) + 2S2
8
S( p,q)−ω
S( p,q) = (−1)ω .
De aquí se sigue que S( p, q) − ω 
es par.
 Por tanto, (−1)  = 1; es decir (−1)
q
q
= (−1)ω , entonces
= (−1)S( p,q) . De manera similar,
Pero, el lema de Gauss dice que
p
p
 
p
= (−1)S(q,p) . En conclusión,
q
  
p
q
= (−1)S(q,p) · (−1)S( p,q)
q
p

( q − 1) ·

= (−1)

p −1 q −1
2 · 2

, por el lema de Gauss.

El corolario que sigue es una reformulación de la Ley de Reciprocidad Cuadrática en términos
de congruencias.
Corolario 6.2 Sea p y q primos impares distintos. Entonces
  
p

  
si p ≡ 1 (mod 4) o q ≡ 1 (mod 4)

q
q
 
=
p

p

si p ≡ q ≡ 3 (mod 4)

q
Prueba: Ejercicio.

120

RESIDUOS CUADRÁTICOS

Ejemplo 6.13
¿Es 152 residuo cuadrático módulo 43 ?
Solución: 152 ≡ 23 (mod 43), entonces


153
43





=
=
=

=
=
=


23
43
 
43
, pues 43 ≡ 23 ≡ 3 (mod 4), (Corolario 6.2)
−
23
 
20
, pues 43 ≡ 20 (mod 23)
−
23
 
 2  
5
5
2
·
=−
−
23
23
23
 
23
−
pues 5 ≡ 1 (mod 4)
5
 
 
2
2
−
= −1 pues
= (−1)(25−1)/8 = 1.
5
5

Ejemplo 6.14
Muestre que si p = 2n + 1 es primo =⇒ 3 es raíz primitiva módulo p .
Solución: p 6≡1 (
mod 3) y, como p es primo, p 6≡ 0 (mod 3). Así, p ≡ 2 (mod 3). Por
 p
2
n −1
=
tanto,
= −1. Ahora, por el criterio de Euler, 32 ≡ −1 (mod p) y también
3
3
n
32 ≡ 1 (mod p). Sea ahora Ord p (3) = s, entonces s|2n ⇒ s = 2k con k ≤ n. Si k < n,
entonces
 k  2n − k −1
n −1
1 ≡ 32
≡ 32 ≡ −1 (mod p),
lo cual es una contradicción. ∴ 3 es raíz primitiva.

Ejemplo 6.15

Sea p primo > 3. Muestre que si p ≡ 1 (mod 4) y p ≡ 1 (mod 3) entonces
Solución: Por la Ley de Reciprocidad Cuadrática,

 
3
=1
p

121

 
p −1 3−1  p 
p −1  p 
3
= (−1) 2 2
= (−1) 2
p
3
3
y como p = 4k + 1, entonces,
 
 p  p
3
=
.
= (−1)2k
p
3
3
Ahora, como p ≡ 1 (mod 3) entonces
     
3
1
p
=
=
=1
p
3
3

6.4

Símbolo de Jacobi.

El símbolo de Jacobi es una extensión del símbolo de Legendre pero solo decide siun 
número es
a
solo que
un residuo no cuadrático. La notación es la misma, el símbolo de Jacobi se denota
m
esta vez m debe ser impar y mcd ( a, m) = 1. No hay peligro de confusión pues si m es primo
impar, el símbolo de Jacobi coincide con el símbolo de Legendre. Si m no es primo, estamos en
el contexto del símbolo de Jacobi.

Definición 6.3 (Símbolo de Jacobi).
k

Sea m entero positivo impar con descomposición prima m =

∏ pi i ,
e

y sea a entero tal que

i =1

mcd ( a, m) = 1. El símbolo de Jacobi se define por
!
a
k   ei
a
a
=
=
∏ pi
ei
k
m
p
∏ i =1
i =1
i


En esta definición, formalmente

a
pi


corresponde al símbolo de Legendre.

Ejemplo 6.16


2
15



  
2
2
=
= (−1)(−1) = 1 (aunque 2 no es residuo cuadrático módulo 15!)
3
5

Si m es primo, el símbolo de Jacobi coincide con el símbolo de Legendre.
Si m no es primo, el símbolo de Jacobi no decide si a es residuo cuadrático
m: 2
 módulo

2
no es residuo cuadrático módulo 15 pero, usando el símbolo de Jacobi,
= 1.
15
Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

122

RESIDUOS CUADRÁTICOS

a
El símbolo de Jacobi si decide residuos no cuadráticos. Si
= −1, a no es residuo
m
a
cuadrático módulo m. Esto es así pues si
= −1, entonces por definición, si m es
m
 
a
compuesto, hay un divisor primo impar pi de m tal que
= −1. Si suponemos que a
pi
es residuo cuadrático módulo m tendríamos una contradicción pues x2 ≡ a (mod m) =⇒
x2 ≡ a (mod pi ).

El símbolo de Jacobi simplifica el cálculo del símbolo de Legendre cuando a es compuesto
impar y p primo, como veremos más adelante.

Teorema 6.6 Propiedades del símbolo de Jacobi
Sea m un entero positivo impar, a, b, n enteros con mcd ( a, m) = mcd (b, m) = 1 entonces,

a.)
b.)
c.)
d.)
e.)

 a   rem( a, m) 
=
m
m
    
ab
a
b
=
m
m
m
 2
 
a
1
= 1. En particular,
=1
m
m


−1
= (−1)(m−1)/2
m
 
2
2
= (−1)(m −1)/8
m

f.) Ley generalizada de reciprocidad cuadrática.
es impar y mcd (m, n) = 1

n
m

=

m
n

(−1)(m−1)(n−1)/4 si también n

Ejemplo 6.17



391
corresponde al símbolo de Legendre pues 439 es primo. Como
439
mcd (391, 439) = 1, podemos usar la ley generalizada de reciprocidad cuadrática
calculando como símbolo de Jacobi.

EJERCICIOS



391
439



= (−1)

(439−1)(391−1)/4



439
391

123


(Reciprocidad cuadrática generalizada)

 



rem(439, 391)
48
439
=
=−
391
391
391
 2 





4
3
3
391
−
=−
= −(−1)(391−1)(3−1)/4
391
391
391
3
 
1
=1
3


= −1 ·
=
=

EJERCICIOS
6.1
6.2
6.3

Calcule los residuos cuadráticos módulo 9.
p −1  
a
Muestre que si p es primo impar, ∑
=0
p
a =1
Use el símbolo de Jacobi para verificar si 48 no es residuo cuadrático módulo 391.

6.4 Use el símbolo de Legendre para verificar que si q es el más pequeño residuo no cuadrático
módulo p (primo impar), entonces q debe ser primo.


−1
= 1 ⇐⇒ p ≡ 1 (mod 4).
6.5 Muestre que
p
6.6 Sea p es primo impar. Muestre que p − 1 es residuo cuadrático módulo p, si y solo si
p ≡ 1 (mod 4). Ayuda: Verifique que si x2 ≡ p − 1 (mod p), entonces x2 ≡ −1 (mod p).
 
a
6.7 Sea p es primo impar y
= 1. Muestre que p − a es residuo cuadrático módulo p, si
p
y solo si p ≡ 1 (mod 4).
a
a
6.8 Muestre que
= 1 si a ≡ ±1 (mod 5), y
= −1 si a ≡ ±2 (mod 5). Ayuda: recipro5
5
cidad cuadrática y reducción módulo 5.
Sea n > 1. Muestre que si p es factor primo de n2 + 1, entonces p ≡ 1 (mod 4).
 
a
6.10 Sea p es primo impar y
= 1. Muestre que p − a es no es residuo cuadrático módulo
p
p, si y solo si p ≡ 3 (mod 4).
 
a
6.11 Sea p primo impar. Muestre que si
= 1, entonces el inverso de a es residuo
p
cuadrático módulo p.
6.9

6.12 Sea p primo y p - A. Si Ax2 + Bx + C ≡ 0 (mod p), muestre que (2Ax + B)2 ≡ B2 −
4AC (mod p) Ayuda: En Ax2 + Bx + C ≡ 0 (mod p) multiplique por 4A y agrupe.
6.13

Resolver la congruencia 3x2 − 4x + 7 ≡ 0 (mod 13)

Muestre que 3x2 + 7x + 5 ≡ 0 (mod 13) no tiene solución.
p − 1 r pz
p2 − 1
6.15 Si p es primo impar, probar que
−
≡
(mod 2) para los casos p =
2
4
8
8k + 1, p = 8k − 3.
6.14

124

RESIDUOS CUADRÁTICOS

6.16 Sea p primo impar, mcd ( a, p) = 1 y b raíz primitiva módulo p. Sea a ≡ bs (mod p).
Muestre que si s es par, entonces a es residuo cuadrático; sino, a no es residuo cuadrático.
6.17
6.18
6.19
6.20
q−1
2
6.21
6.22

Usar el criterio de Euler para determinar si a = 54 es residuo cuadrático módulo p = 97.
a
¿Qué puede decir de
?
2
¿Es 2 residuo cuadrático módulo 3181 ?
s
{
q p−1
q−1
. Ayuda: Muestre que
Sean p > q ambos primos impares. Muestre que
=
p 2
2
q p−1
q−1
≤
<
+ 1.
p 2
2
¿Es 3797 residuo cuadrático módulo 7297 ?


 
−1
1
¿
=−
?
17
17

 
3
6.23 Sea p primo > 3. Muestre que si p ≡ 3 (mod 4), entonces
= −1 si p ≡ 2 (mod 3).
p
Ayuda: Ley de Reciprocidad Cuadrática.
 
3
6.24 Sea p primo impar.
= 1 si y solo si p ≡ 1 (mod 12).
p
6.25 Sea p primo impar. Muestre que la congruencia x2 + 3 ≡ 0 (mod p) tiene solución si y
solo si p es un primo de la forma 3h + 1.
6.26
6.27

Probar que x ( p−1)/2 ≡ 1 (mod p) tiene ( p − 1)/2 soluciones módulo p.
Sea p1 , ..., ps primos de la forma 8k + 7 y sea N = (4p1 p2 · · · ps )2 − 2.
a) Probar, usando residuos cuadráticos, que los divisores primos impares de N tienen la
forma 8k + 1 o 8k + 7.
b) Probar que no todos los divisores primos impares de N tienen la forma 8k + 1
c) Probar que hay infinitos primos de la forma 8k + 7.

EJERCICIOS

125

Versión actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

7

ESTIMACIONES,
ESTADÍSTICAS Y
PROMEDIOS

El propósito de este capítulo es estudiar comportamiento “típico” de algunas funciones aritméticas para tomar decisiones a la hora de crear heurísticas para resolver algún problema. Por
ejemplo, nos interesa tener estimaciones para poder responder preguntas tales como: ¿La mayoría de los números tienen factores primos pequeños?, ¿Los números altamente compuestos son
escasos?, ¿Cuál es el tamaño típico del factor más grande de un número?, etc.

7.1

Funciones Aritméticas

La función aritmética τ (n) cuenta cuántos divisores positivos, primos y compuestos, tiene n.
Por ejemplo, los divisores de 8 son 1, 2, 4; así τ (8) = 4. La función σ (n) es definida como la
suma de los divisores, tanto primos como compuestos, de n. Por ejemplo, σ(8) = 1 + 2 + 4 = 7.
Formalmente,
τ (n) = ∑ 1 y σ(n) = ∑ d
d|n

d|n

Sea s(n) = σ (n) − n, es decir, s(n) es la suma de divisores propios de n (a veces se usa el
arcaísmo “parte alícuota” en vez de divisor propio). Decimos que un entero n es deficiente si
s(n) > n, es abundante si s(n) > n y que es perfecto si s(n) = n. Por ejemplo, s(8) = 7 < 8, así
que 8 es deficiente. s(12) = 16, así 12 es abundante. Los divisores de 6 son 1, 2, 3 y 6, por tanto
s(6) = 1 + 2 + 3 + 6 − 6 = 6, por tanto 6 es perfecto.
τ y σ se calculan fácil si n es potencia de un primo.
Lema 7.1
Sea p primo y n = pk , , entonces τ (n) = k + 1 y σ (n) =

p k +1 − 1
.
p−1

Prueba: Los divisores de d de pk son 1, p, p2 , ..., pk . Hay k + 1 divisores. La suma es
1 + p + p2 + ... + pk =

1 − p k +1
p k +1 − 1
=
1− p
p−1

En el siguiente lema se muestra que τ y σ son multiplicativas, esto nos permite calcular τ y σ
si conocemos la descomposición prima de n.

Lema 7.2
Si mcd (m, n) = 1, entonces τ (nm) = τ (n)τ (m) y σ (nm) = σ (n)σ (m)
Prueba: La a idea la podemos ver con un ejemplo: Sea n = 9 y n = 4, ambos son primos relativos.
Ahora, hacemos un arreglo rectangular como el que está a la izquierda de la tabla (7.1). Las
únicas filas en consideración son las filas que inician con un divisor de 9. Luego, solo marcamos
las entradas5 di · d j si di |9 y d j |4. Simplificando, lo que nos queda es un arreglo rectangular
τ (9) τ (4).

1
2
3
4
5
6
7
8
9

1
1·1

2
1·2

3·1

3·2

3

4
1·4
3·4

−→

9·1

9·2

1
3
9

1
1·1
3·1
9·1

2
1·2
3·2
9·2

4
1·4
3·4
9·4

9·4

Tabla 7.1. Si mcd (9, 4) = 1, entonces τ (9 · 4) = τ (9)τ (4)

La prueba para σ(nm) es una modificación de la prueba de τ (m)τ (n). Solo necesitamos notar
que σ (nm) es la suma de todas las entradas de la tabla simplificada.
La prueba formal queda como ejercicio.

Teorema 7.1
k

Si la factorización prima de n es p11 · p2k2 · · · pks s , entonces
s

τ (n) = (k1 + 1)(k2 + 2) · · · (k s + 1) y σ (n) = ∏

i =1

k

pi i − 1
pi − 1

k

Prueba: Como p11 , p2k2 , · · · , pks s son primos relativos dos a dos, entonces
   
 
k
τ (n) = τ p11 · τ p2k2 · · · τ pks s = (k1 + 1)(k2 + 2) · · · (k s + 1)
y similarmente para σ (n)

σ y τ son ejemplos de funciones definidas sobre los números naturales. En vez de considerar
este tipo de funciones como objetos aislados, es de mucha ayuda verlas como objetos más generales y estudiar la relación entre ellas por medio de una operación “∗” (llamada convolución).
5 Recordemos

que si mcd (m, n) = 1 y si d|mn, entonces d = ab con a|m y b|n .

127

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

128

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

Una función f definida sobre los números naturales, se llama función aritmética. Por ejemplo,
u(n)
N (n)

= 1 para todo n,
= n para todo n,

1
si n = 1
e(n) =
0
si n > 1

Definición 7.1 (Convolución).
Sean f y g funciones aritméticas. La convolución de f y g, se denotada f ∗ g, es una función
aritmética definida por
f ∗ g(n) = ∑ f (d) g(n/d)
d|n

Como los divisores de n ocurren en pares (es decir, si d|n =⇒ n = dk y entonces (n/d)|n),
podemos escribir
f ∗ g(n) = ∑ f (d) g(c)
c,d
n=cd

Ejemplo 7.1
Calcule N ∗ u
Solución: N ∗ u(n) =

∑

c,d
n=cd

N (d)u(c) = ∑ d · 1 = σ(n)
d|n

Ejemplo 7.2
Calcule u ∗ u
Solución: u ∗ u(n) =

∑

c,d
n=cd

u(d)u(c) = ∑ 1 = τ (n)
d|n

Teorema 7.2
Sean f , g y h funciones aritméticas, entonces
a.) f ∗ g = g ∗ f
b.) ( f ∗ g) ∗ h = f ∗ ( g ∗ h)
c.) f ∗ e = f para cualquier función aritmética f
Prueba: Ejercicio.

129

La función µ de Möbius se define así:
µ (1) = 1,
k

si n > 1 tiene factorización prima n = p11 · p2k2 · · · pks s , entonces

µ (n) =

si k i > 1,
si k i = 1,

0
(−1)s

para algún i = 1, 2, ..., s
para todo i = 1, 2, ..., s

Así, por ejemplo µ (2 · 3 · 13) = (−1)3 = −1 mientras que µ (2 · 32 · 13) = 0.
La función de Möbius es importante porque f = g ∗ u ⇔ g = f ∗ µ . Esta es una fórmula muy
útil y se le llama fórmula de inversión de Möbius.

Lema 7.3
µ ∗ u = e, es decir,

∑µ ( d ) =
d|n



1
0

si n = 1,
si n > 1.

Prueba: Si n = 1, ∑d|1 µ (d) = µ (1) = 1. Para probar el caso n > 1, empecemos con un ejemplo:
Si n = 3 · 53 · 7, los divisores de n que contribuyen con un sumando no nulo se pueden escribir
en pares, 3, 3 · 7, 3 · 5, 3 · 5 · 7, 5, 5 · 7. Los divisores se dividen en dos grupos de igual cardinalidad, los que son divisibles por 7 y los que no. Si d es divisor del primer grupo, d · 7
es divisor del segundo grupo. Observemos que µ (d) = −µ (d · 7), por tanto la suma cancela:
∑d|n µ (d) = µ (3) + µ (3 · 7) + ... = −1 + 1 + 1 − 1 − 1 + 1 = 0. Formalmente,
k

Si n > 1 tiene factorización prima n = p11 · p2k2 · · · pks s ; los únicos divisores d de n que contribuyen
con un sumando no nulo, son los divisores que son productos de primos distintos. Estos divisores d se pueden dividir en dos grupos de igual tamaño; D1 = {d : ps |d} y D2 = {d : ps - d},
es decir, los productos que no tienen a ps y estos mismos agregando ps : d ∈ D1 ⇔ dps ∈ D2 .
Ahora, como µ (d) = −µ (dps ), entonces hay tantos divisores que contribuyen con −1 a la suma
como divisores que contribuyen con 1, como se quería mostrar.

Teorema 7.3 (Fórmula de Inversión).
Sean f y g son funciones aritméticas,
Si f (n) = ∑ g(d), entonces g(n) = ∑ f (d)µ (n/d)
d|n

d|n

e inversamente.
Prueba: Usando la notación de convolución, hay que probar que f = g ∗ u ⇐⇒ g = f ∗ µ .
” =⇒ ” f = g ∗ u =⇒ f ∗ µ = ( g ∗ u) ∗ µ = g ∗ (u ∗ µ ) = g ∗ (µ ∗ u) = g ∗ e = g.

130

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

” ⇐= ” Ejercicio.

Ejemplo 7.3
Muestre que

∑σ(d)µ (n/d) = n para toda n ∈ Z+ .
d|n

Solución: Como σ = N ∗ u, entonces por inversión de Möbius, N = σ ∗ µ , que es lo que
se quería.

7.2

A los números primos les gusta los juegos de azar.

La probabilidad de que un número natural, tomado al azar, sea divisible por p es 1/p.
¿Qué significa “tomar un número natural al azar”?. Los naturales son un conjunto infinito, así
que no tiene sentido decir que vamos a tomar un número al azar. Lo que si podemos es tomar
un número de manera aleatoria en un conjunto finito {1, 2, ..., n} y luego (atendiendo al modelo
frecuentista de probabilidad) ver que pasa si n se hace grande (i.e. n −→ ∞).
Hagamos un pequeño experimento: Fijamos un número p y seleccionamos de manera aleatoria un número en el conjunto {1, 2, ..., n} y verificamos si es divisible por p. El experimento
lo repetimos m veces y calculamos la frecuencia relativa. En la tabla que sigue, hacemos este
experimento varias veces para n, m y p.
n
100000

m

p

Frecuencia relativa

10000

5

0.1944
0.2083
0.2053
0.1993

10000000

100000

5

0.20093
0.19946
0.1997
0.20089

100000000 1000000

5

0.199574
0.199647

Tabla 7.2. Resultado del experimento.

Y efectivamente, parece que “la probabilidad” de que un número tomado al azar en el conjunto
{1, 2, ..., n} sea divisible por p = 5 es 1/5 = 0.2
De una manera sintética: Sea E p (n) = los múltiplos de p en el conjunto {1, 2, ..., n}. Podemos
E p (n)
calcular la proporción de estos múltiplos en este conjunto, es decir, podemos calcular
n

131

para varios valores de n
n
100

Múltiplos de p = 5

Proporción

20

0.2

10230

2046

0.2

100009

20001

0.199992

1000000

199999

0.199999

Tabla 7.3

Parece que en el conjunto {1, 2, ..., n}, la proporción de los múltiplos de p = 5 se aproxima a
1/5, conforme n se hace grande. ¿Significa esto que la probabilidad de que un número natural, tomado al azar, sea divisible por 5 es 1/5 ?. Por ahora, lo único que podemos decir es que
este experimento sugiere que la densidad (o la proporción) de los múltiplos de 5 en {1, 2, ..., n}
parece ser 1/5 conforme n se hace grande. Generalizando,

Definición 7.2
Sea E un conjunto de enteros positivos con alguna propiedad especial y sea E( N ) =
T
E {1, 2, ..., N }. La densidad (o medida relativa) de E se define como
E(n)
n→∞ n

D [ E] = lim
siempre y cuando este límite exista.

¿Es esta densidad una medida de probabilidad en el modelo axiomático?. No, porque resulta no
ser aditiva, como el modelo exige (ver [10]). Aunque en el esquema frecuentista se puede ver la
densidad como la “probabilidad” de que un entero positivo, escogido aleatoriamente, pertenezca
a E, aquí identificamos este término con densidad o proporción. Tenemos,

Teorema 7.4
La densidad de los naturales divisibles por p es

1
, es decir, si E p es el conjunto de enteros
p

positivos divisibles por p, entonces
D [ E p ] = lim

n→∞

E p (n)
1
=
n
p

Prueba: Para calcular el límite necesitamos una expresión analítica para E p (n). Como existen
p, r tales que n = pk + r con 0 ≤ r < p, entonces kp ≤ n < (k + 1) p, es decir, hay exactamente
n−r
k múltiplos positivos de p que son menores o iguales a n . Luego E p (n) = k =
. Por lo
p
E p (n)
(n − r )/p
1
r
1
tanto, D [ E p ] = lim
= lim
= lim −
=
n→∞
n→∞
n→∞ p
n
n
pn
p

132

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

Un hecho de gran importancia es este: Si p, q son primos, ser divisible por p y por q son eventos
T
técnicamente independientes, es decir, D [ E p
Eq ] = D [ E p ] D [ Eq ]. Una de sus consecuencias (no
tan inmediata) es que los divisores primos de n se distribuyen de acuerdo a la ley normal (ver
[10]).

7.3

Orden de Magnitud

Necesitamos un mecanismo flexible para comparar funciones. Esto es necesario, porque a menudo
nos interesa reemplazar funciones complicadas con otras más simples. En la parte práctica, esto
nos permite establecer términos de error en una estimación, de una manera más flexible.
Para comparar dos funciones f y g, es conveniente primero definir la relación “” (se lee
“dominada por”): Decimos que
f ( x )  g( x ) conforme x → ∞
si podemos encontrar una constante C y x0 tal que
f ( x ) ≤ Cg( x ) cuando x > x0
Para establecer esta desigualdad, a menudo es muy útil usar el hecho de que si f es creciente,
entonces a ≤ b cuando f ( a) ≤ f (b). A veces se puede usar la derivada para establecer que f es
creciente (o decreciente) en un intervalo.

Ejemplo 7.4
Muestre que 3x3 − x2 + 1  x3 conforme x → ∞
Solución: Tenemos que encontrar C y x0 tal que x3 − x2 + 1 ≤ Cx3 cuando x ≥ x0 .
Como 1 − x2 < 0 si x > 1, entonces 3x3 − x2 + 1 < 3x3 si x > 1. Por tanto basta tomar
C = 3 y x0 = 1 para que se cumpla la definición.

Ejemplo 7.5
Muestre que exp(

p

log( x ))  x conforme x → ∞

Solución: exp( x ) y log( x )
p
exp( plog( x ))
log( x )
log( x )

son funciones crecientes, entonces

≤ x
≤ log( x )
≤ log2 ( x ),

⇐⇒
⇐⇒
(∗)

(tomando logaritmos)
(cuadrados a ambos lados)

133

ahora, como u ≤ u2 si u ≥ 1, la desigualdad (∗) se cumple si x > e. Por tanto, basta
tomar C = 1, y x0 = e para que se cumpla la definición.

O grande de Landau. En general, nos interesa una manera de decir que f y g son funciones
parecidas en orden excepto por un término de error dominado por una función h. Decimos que
f ( x ) = g( x ) + O(h( x )) si | f ( x ) − g( x )|  h( x )
En particular, si g( x ) ≡ 0,
f ( x ) = O(h( x )) si f ( x )  h( x )
Ejemplo 7.6
Observe que f ( x ) = O(1) significa que f es una función acotada en un intervalo
p ] x0 , ∞ [.
3
2
3
También, usando los dos ejemplos anteriores, 3x − x + 1 = O(3x ) y exp( log( x )) =
O ( x ).

Ejemplo 7.7

Muestre que

x
=1+O
x+1

 
1
.
x

Solución: | x/( x + 1) − 1| = 1/( x + 1) < 1/x si x > 0. Así, tomando C = 1 y x0 = 0, el
término de error es O(1/x ).

Ejemplo 7.8
Sean n, d enteros positivos, Muestre que Jn/dK = n/d + O(1).
Solución: Por el algoritmo de la división, existe k, r ∈ Z tal que n = k · d + r con 0 ≤ r < d
o también n/d = k + r/d. Luego, Jn/dK = k = (n − r )/d. Ahora, |Jn/dK − n/d| = r/d < 1
para cada n ≥ 0. Así, tenemos Jn/dK = n/d + O(1), tomando C = 1.
o pequeña. La definición de O grande requiere la existencia de una constante C tal que f ≤ Cg.
La definición de la o pequeña es similar, solo que esta vez pedimos que 0 ≤ f ≤ Cg para toda
C > 0. En lo que sigue, solo hacemos referencia un par de veces a este concepto, así que solo
vamos a dar la definición.

Definición 7.3
Sea f , g funciones. Decimos que
0 ≤ f ( x ) ≤ c · g( x ) si x > xc .

f = o ( g) si para toda c ∈ R+ , existe xc tal que

134

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

7.4

Teorema de los números primos

Ya sabemos que los primos son infinitos. De aquí en adelante hay una pregunta muy natural:
¿cuántos primos hay entre 2 y x?. Por ejemplo, 2, 3, 5, 7 son los primos inferiores a x = 10, así
que hay 4 primos entre 2 y 10.
La función que se usa para√contar los primos por debajo de x se denota con π ( x ) : Por ejemplo,
π (2) = 1, π (10) = 4 y π ( 1000) = 11.
Para la función π ( x ) no hay una fórmula sencilla. Algunas fórmulas actuales son variaciones
un poco más eficientes que la fórmula recursiva de Legendre (1808).

7.4.1

Fórmula de Legendre para π ( x ).

Esta fórmula esta basada en el principio de Inclusión-Exclusión. Básicamente dice que el conjunto {1, 2, ..., JxK} es la unión del entero 1, los primos ≤ x y los enteros compuestos ≤ x,
JxK = 1 + π ( x ) + #{ enteros compuestos ≤ x }
Un entero compuesto en el conjunto A = {1, 2, ..., JxK} tiene al menos un divisor primo menor o
√
igual a x. Esto nos ayuda a detectar los números compuestos en A : Solo tenemos que contar
√
los elementos de A con un divisor primo ≤ x.
Los números divisibles por p e inferiores a x son los k números p < 2p < ... < k · p ≤ x. Como
kp ≤ x < (k + 1) p, entonces k = Tx/pU. Así, Tx/pU cuenta la cantidad de enteros ≤ x divisibles
por p.
Ahora, ¿ #{ enteros compuestos ≤ x } es igual a al conteo total de los múltiplos de cada primo
√
pi ≤ x ? No, pues este conteo incluye a los propios primos pi , así que hay que reponer con
√
π ( x ) para hacer una corrección. Pero también habría que restar los compuestos que son divisibles por pi y p j pues fueron contados dos veces, pero esto haría que los números divisibles por
pi , p j , pk fueran descontados una vez más de lo necesario así que hay que agregar una corrección
para estos números, y así sucesivamente.

Ejemplo 7.9

√
Si x = 30, los primos menores que T 30U = 5 son 2, 3 y 5.
T30/2U = 15 cuenta {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30}
T30/3U = 10 cuenta {3, 6, 9, 12, 15, 18, 21, 24, 27, 30}
T30/5U = 6 cuenta {5, 10, 15, 20, 25, 30}
En el conteo T30/2U + T30/3U + T30/5U :
se contaron los primos 2, 3 y 5.
Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

135

6, 12, 18, 24, 30 fueron contados dos veces como múltiplos de 2, 3
10, 20, 30 fueron contados dos veces como múltiplos de 2, 5
15, 30 fueron contados dos veces como múltiplos de 3, 5
30 fue contado tres veces como múltiplo de 2, 3 y 5.

Ejemplo 7.0 (continuación).
Finalmente,
#{ enteros compuestos ≤ 30}

= T30/2U + T30/3U + T30/5U

− T30/(2 · 3)U − T30/(2 · 5)U − T30/(3 · 5)U

+ T30/(2 · 3 · 5)U

= 31 − 3 − 5 − 3 − 2 + 1 = 19
El último sumando se agrega pues el 30 fue contado tres veces pero también se resto tres veces.
Observe ahora que en {1, 2, ..., 30} hay 19 compuestos y el 1, así que quedan 10 primos.

Fórmula de Legendre para π ( x ).
Sea pi el i −ésimo primo. La fórmula de Legendre es,

√ 
1 + π (x) = π
x + TxU −

∑



√
pi ≤ x


x
+
pi

∑

√
pi < p j ≤ x

"

x
pi p j

#

−

∑

√
pi < p j < p k ≤ x

"

#
x
+ ···
pi p j p k

√
Para efectos de implementación es mejor poner α = π ( x ) y entonces la fórmula queda
√ 
1 + π (x) = π
x + TxU − ∑

i ≤α



"
#
"
#

x
x
x
+ ∑
− ∑
+ ···
pi
pi p j
pi p j p k
i< j≤α
i < j<k≤α

Ejemplo 7.10
Calcular π (100)
Solución: Como

√

100 = 10, solo usamos los primos {2, 3, 5, 7}.

136

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

1 + π (100)

=

π (10) + T100U

− (T100/2U + T100/3U + T100/5U + T100/7U)

+T100/2 · 3U + T100/2 · 5U + T100/2 · 7U + T100/3 · 5U + T100/3 · 7U + T100/5 · 7U
− (T100/2 · 3 · 5U + T100/2 · 3 · 7U + T100/2 · 5 · 7U + T100/3 · 5 · 7U)

=

+T100/2 · 3 · 5 · 7U

4 + 100 − (50 + 33 + 20 + 14) + (16 + 10 + 7 + 6 + 4 + 2) − (3 + 2 + 0 + 1) + 0 = 26

El problema con esta fórmula es la cantidad de cálculos que se necesita para calcular las correcciones.
Las cantidad de partes enteras Tx/( pi1 pi2 · · · pik )U corresponde a la cantidad de subconjuntos no
vacíos {i1 , i2 , · · · , ik } de {1, 2, ..., α}, es decir, hay que calcular 2α − 1 partes enteras.

√
Si quisieramos calcular π (1033 ), entonces, puesto
que 1033i= 1018 , tendríamos que tener los
h
primos ≤ 1018 y calcular las partes enteras x/( pk1 pk2 ...pk j ) que corresponden al cálculo de
todos los subconjuntos de {1, 2, ..., π (1018 )}. Como π (1018 ) = 24739954287740860, tendríamos
que calcular
224739954287740860 − 1 partes enteras.
que constituye un número nada razonable de cálculos.

7.4.2

Fórmula de Meisel para π ( x ).

La fórmula de Meisel es un re-arreglo de la fórmula de Legendre. Pongamos
Legendre( x, α) =

∑



i ≤α

#
"
#
"

x
x
x
+ ∑
+ ···
− ∑
pi
pi p j
pi p j p k
i< j≤α
i < j<k≤α

√
Así π ( x ) = JxK − 1 + α − Legendre( x, α) donde α = π ( x ), es decir, Legendre( x, α) − α cuenta
la cantidad de números compuestos ≤ x o, en otras palabras, los números ≤ x con al menos un
√
divisor primo inferior a α = x.
Ahora Legendre( x, α) va a tener un significado más amplio: Si α ∈ N,
Legendre( x, α) =

∑

i ≤α



"
#
"
#

x
x
x
− ∑
+ ∑
+ ···
pi
pi p j
pi p j p k
i< j≤α
i < j<k≤α

es decir, Legendre( x, α) − α cuenta los compuestos ≤ x que son divisibles por primos ≤ pα . La
resta es necesaria pues la manera de contar cuenta también los primos p1 , p2 , ..., pα
Ahora, dividamos los enteros en cuatro grupos: {1}, {primos ≤ x }, C3 ∪ C4 = los compuestos
≤ x.
JxK = 1 + π ( x ) + #C3 + #C4

137

#C3 : Es la cantidad de números compuestos ≤ x con al menos un divisor primo ≤ pα , es decir
Legendre( x, α) − α.
#C4 : son los compuestos ≤ x cuyos divisores primos son > pα : Aquí es donde entra en juego
la escogencia de α para determinar la cantidad de factores primos de estos números.
Sea pi el i −ésimo primo. Sean pα y p β tal que p3α ≤ x < p3α+1 y p2β ≤ x < p2β+1 . En otras pal√
√
abras: α = π ( 3 x ) y β = π ( x ).
Consideremos la descomposición prima de n ∈ C4 , n = pi1 · pi2 · · · pik con α < pi1 < pi2 < ... < pik
y k ≥ 2. Como pkα+1 ≤ pi1 · pi2 · · · pik ≤ x < p3α+1 =⇒ k = 2.
Así que estos números en C4 son de la forma pα+k p j ≤ x, a + k ≤ j, k = 1, 2, ...
Pero la cantidad de números pα+k p j es igual a la cantidad de p0j s tal que p j ≤ x/pα+k : π ( x/pα+k ) −
( α + k ).
Además α < α + k ≤ β pues si α + k = β, p β · p β = p2β ≤ x pero p β+1 p j ≥ p2β+1 > x.
Así, usando la fórmula ∑in=−11 i = n(n − 1)/2,

#C4 =

∑

{π ( x/pi ) − (i − 1)} =

α <i ≤ β

1
1
β( β − 1) − α(α − 1) + ∑ π ( x/pi )
2
2
α <i ≤ β

√
¿Cuál es la ganancia? Mientras que con la fórmula de Legendre necesitamos conocer π ( x )
√
√
y calcular con primos ≤ x, con la fórmula de Meisel solo necesitamos conocer hasta π ( 3 x ) y
√
√
calcular con primos ≤ 3 x < x.

Ejemplo 7.11
Calcule π (100) usando la fórmula de Meisel.

√
√
Solución: Como α = π ( 3 100) = 2 y β = π ( 100) = 4, solo vamos a usar los primos
p1 = 2, p2 = 3, p3 = 5, p4 = 7.
Legendre(100, 2)

= T100/2U + T100/3U + T100/2 · 3U

= 50 + 33 − 16 = 67

Meisel(100, 2, 4)

= π (100/5) + π (100/7)
= π (20) + π (4) = 8 + 6 = 14

Así, π (100) = 100 + 6 − 0 − 67 − 14 = 25

138

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

Mathematica (Wolfram Research Inc.) implementa π ( x ) con el comando PrimePi[ x ] hasta x ≈
8 × 1013 . En esta implementación, si x es pequeño, se calcula π ( x ) usando colado y si x es
grande se usa el algoritmo Lagarias-Miller-Odlyzko.

7.5

Estimación de π ( x ). Teorema de los números primos.

El cálculo de π ( x ) de manera directa es bastante complicado y requiere mucho esfuerzo computacional. En general, no podemos responder de manera exacta todo el tiempo. Curiosamente,
hay fórmulas relativamente simples para responder con una aproximación del valor de π ( x )
para valores grandes de x. Legendre y Gauss iniciaron el estudio de esta estimación contando
primos en intervalos de longitud adecuada y calculando proporciones, en busca de un ley que
gobernara esta distribución.
La frecuencia relativa π (n)/n calcula la proporción de primos en el conjunto A = {1, 2, ..., n}.
Aunque la distribución de los primos entre los enteros parece irregular, el comportamiento
promedio si parece ser agradable. Como dijimos antes, basándose en un estudio empírico de
tablas de números primos, Legendre y Gauss (en 1792, a la edad de 15 años) conjeturan que la
1
ley que gobierna el cociente π (n)/n es aproximadamente igual a
.
ln(n)
En [9] se indica que Gauss y Legendre llegaron a este resultado, de manera independiente,
estudiando la densidad de primos en intervalos que difieren en potencias de diez: Notaron que
la proporción de primos en intervalos centrados en x = 10n decrece lentamente y disminuye
aproximadamente a la mitad cada vez que pasamos de x a x2 . Este fenómeno es muy bien
modelado por 1/ ln( x ) pues 1/ ln( x2 ) = 0.5/ ln( x ).
n

π (n)

π (n)/n

1/ ln(n)

107

664579

0.0664579

0.0620420

1011

4118054813

0.0411805

0.0394813

1012

37607912018

0.0376079

0.0361912

Tabla 7.4

Acerca de este descubrimiento, Gauss escribió a uno de sus ex-alumnos, Johann Franz Encke, en
1849
“Cuando era un muchacho considere el problema de cuántos primos había hasta un punto dado. Lo que
encontré fue que la densidad de primos alrededor de x es aproximadamente 1/ ln( x ). ”

La manera de interpretar esto es que si n es un número “cercano” a x, entonces es primo con
“probabilidad” 1/ ln( x ). Claro, un número dado es o no es primo, pero esta manera de ver las
cosas ayuda a entender de manera muy intuitiva muchas cosas acerca de los primos.

139

Ejemplo 7.12
pto Como Jln(1000)K = 7, podemos usar un dado de 6 caras para decidir si un número
n cercano a 1000, es (probablemente) primo

Primo !

Para decidir con un dado si un número n cercano a 10 000 es probablemente primo,
debemos contruir un dado de 8 lados pues Jln(10 000)K = 9.

Primo!

Lo que afirma Gauss es lo siguiente: Si ∆x es “pequeño” comparado con x (en el mundillo
asintótico esto quiere decir que ∆x/x → 0 conforme x → ∞) entonces
1
π ( x + ∆x ) − π ( x )
≈
∆x
ln( x )

(π ( x + ∆x ) − π ( x ))/∆x es la densidad de primos en le intervalo [ x, x + ∆x ] y 1/ ln( x ) es el
promedio estimado en este intervalo. Por esto decimos: 1/ ln( x ) es la “probabilidad” de que
un número n, en las cercanías de x, sea primo. Para hacer un experimento, podemos tomar
√
∆x = x (que claramente es dominada por x),

x

π ( x + ∆x ) − π ( x )

π ( x + ∆x ) − π ( x )
∆x

1
ln( x )

10

2

0.632

0.434

100

4

0.4

0.217

1000

5

0.158

0.144

10000

11

0.11

0.108

100000000000

12491

0.0395

0.039

1000000000000

36249

0.0362

0.036

Tabla 7.5. Densidad de primos en le intervalo [ x, x + ∆x ] con ∆x =

√

x

Hadamard y de la Vallée Poussin probaron en 1896, usando métodos basados en análisis complejo, el

140

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

Teorema 7.5 (Teorema de los Números Primos).
Sea Li( x ) =

Z x
2

dt
π (x)
. Entonces π ( x ) ∼ Li( x ), es decir limx→∞
=1
ln(t)
Li( x )

La conjetura de Legendre era π ( x ) ∼ x/ ln( x ). Esta expresión se usa mucho cuando se hacen
estimaciones “gruesas”:

Teorema 7.6
Li( x ) ∼ x/ ln( x ), es decir limx→∞

7.5.1

π (x)
=1
x/ ln( x )

La función Zeta de Riemann

Este tema está en el ámbito de la teoría analítica de números. Aquí solo podemos hacer una excursión algo descriptiva con solo algunos cálculos concretos que involucran a la función “zeta”
de Riemann. Los resultados que se mencionan aquí fueron tomados de [9] y [2].
La aproximación a π ( x ) dada por Gauss y Legendre fue encontrada por métodos empíricos.
Riemann fue el primero en deducir de manera sistemática relaciones entre los números primos y
las funciones matemáticas conocidas. El punto de partida de Riemann fue la relación descubierta
por Euler
∞

ζ (s) =

1
1
= ∏
s
n
1
−
p−s
p primo
n =1

∑

donde el producto es tomado sobre todos los primos.
Para entender esta fórmula debemos aplicar series geométricas,
1
= 1 + p−s + ( p−s )2 + ...
1 − p−s
Así,

p

1
1
−
p−s
primo

∏

= (1 +

1
1
+ 2s + ...)
2s
2

1
1
+ 2s + ...)
3s
3
1
1
·(1 + s + 2s + ...)
5
5
···

·(1 +

(7.1)

141

Ejemplo 7.13
Veamos un ejemplo concreto. Si s = 1 entonces
∞

ζ (1) =

1
1
= ∏
n
1
−
p −1
p primo
n =1

∑

= (1 +

1
1
+ ...)
+
2 22

1
1
+ 2 + ...)
3 3
1
1
·(1 + + 2 + ...)
5 5
1
1
·(1 + + 2 + ...)
7 7
···

·(1 +

Así, el sumando

1 1
1
1
1
= · 2 · 2 · 1 · 1··· .
se obtiene como
450
2 3
2 · 32 · 52
5

El producto de los dos primeros factores sería,
1
1
1
1
1
+ 2
+ 2+ 3+
p2
p
p
p2
p2 p1
p2
2 1
1
1
1
1
1
+ 3 +
+
+ 2+
2
p1
p2 p1
p1
p2 p1
p2 p31
1
1
1
1
1
+ 2 2+ 3 2+ 2 3+ 3 3+ 3
p2 p1
p2 p1
p2 p1
p2 p1
p1

(1 + p1−1 + p1−2 + ...)(1 + p2−1 + p2−2 + ...) = 1 +

Luego, ζ (1) =

1

∑ 2α1 3α2 · · · pαnn

donde la suma cubre todas las combinaciones de expo-

nentes αi ≥ 0 y todos los primos pi . El teorema fundamental de la aritmética dice que
∞
1
estos productos en los denominadores son todos los enteros positivos: ζ (1) = ∑ .
n
n =1
Riemann toma esta identidad establecida por Euler y pone a trabajar la teoría de funciones
analíticas (funciones diferenciables de variable compleja). Extiende la relación (7.2), la cual está
restringida a s > 1 por razones de convergencia, a s = σ + it con σ > 0 y s 6= 1 (en este caso
|ζ (1)| = ∞). La nueva función luce así
ζ (s) =

1
1 − 21 − s

∞

(−1)n−1
ns
n =1

∑

(7.2)

Esta función converge para todos los s 6= 1 con σ > 0 si s 6= 1. Para calcular ζ (s) se usa la
fórmula de Euler-Maclaurin
N −1

ζ (s)

≈

∑

n =1

+

n−s +

1
1
N 1− s + N − s
s−1
2

1 −s−1 s(s + 1)(s + 2) −s−3 s(s + 1)(s + 2)(s + 3)(s + 4) −s−5
N
−
N
+
N
,
12
720
30240

142

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

Por ejemplo, tomando N = 1000,
ζ (2) ≈ 1.6449340668482264... ≈ π 2 /6 = 1.6449340668482262...
ζ (1/2 + 37.586178 · i ) = −8.910197857314728 × 10−8 − 2.9437792720132805 × 10−7 i
En realidad, 0.5 + 37.586178158825675... · i es el sexto cero no trivial de ζ, es decir, ζ (1/2 + 0.5 +
37.586178158825675... · i ) = 0. A este respecto, la famosa hipótesis de Riemann dice que todos los
ceros no triviales de ζ (s) son de la forma s = 1/2 + it. La importancia de esta hipótesis se debe
a que la estimación del error en varias fórmulas relacionadas con la distribución de los números
primos depende del conocimiento de regiones extensas libres de ceros de la función ζ (s). En
particular,

√
π ( x ) = Li( x ) + O( x ln x )
Para obtener una fórmula para π ( x ), Riemann define la función f ( x ) = π ( x ) + 1/2π ( x1/2 ) +
1/3π ( x1/3 ) + ..., con x > 1 y no entero. Sorprendentemente,
∞

π (x) =

µ (n)
f ( x1/n )
n
n =1

∑

(7.3)

En 1859 Riemann hace la conjetura
f ( x ) = Li( x ) − ∑ Li( x ρ ) − ln 2 +
ρ

Z ∞
x

dt/(t(t2 − 1) ln t)

donde la suma corre sobre todos los ceros no triviales ρ de ζ (s), contando multiplicidad. Esto
fue probado por Mangoldt en 1895. Ahora, cambiando f ( x1/n ) por Li( x1/n ) en (7.3), Riemann
obtiene
∞

Ri( x ) =

µ (n)
Li( x1/n ) ∼ π ( x )
n
n =1

∑

En esta fórmula, es conveniente calcular Li( x ) = Ei( Log(z)) donde Ei(z) = −

Z ∞
−z

e−t /t dt; suponiendo

que tenemos una buena implementación de esta función, por ejemplo en ([24]).
La función Ri(n), n ∈ Z+ , se puede calcular usando la serie de Gram (1893),
∞

Ri(n) = 1 +

(log n)k

∑ k! · kζ (k + 1),

k =1

esta serie exhibe convergencia muy veloz; sin embargo, la aproximación a π ( x ) es aceptable si
x < 109 .
¿Qué tan bien se puede aproximar π ( x )? El teorema de los números primos indica que
π ( x ) ∼ Li( x ), es decir, el error relativo


 Li( x ) − π ( x ) 

 −→ 0 conforme x −→ 0.


Li( x )
Efectivamente, conforme x es grande, Li( x ) se aproxima más y más a π ( x ). Si x no es muy
grande, se puede tener un error porcentual pequeño y un error real de varios millones, que aún
así, es despreciable respecto a la magnitud de π ( x ). En la tabla (7.7) se hace una comparación

143

entre π ( x ) Li( x ). Los valores de π ( x ) se obtuvieron de tablas especiales mientras que Li( x ) se
calculó con Ei ( x ).

x

π (x)

Li( x )

Li( x ) − π ( x )

π ( x ) − Li( x )
Li( x )

1013

346065536839

346065645810.

108 971

−3.14 × 10−7

1018

24739954287740860

24739954309690415.

21949555

8.87 × 10−7

1022

201467286689315906290

201467286691248261498.

1932355207

9.59 × 10−12

Tabla 7.6. Comparando π ( x ) con Li( x )

Una mejora notable se obtiene si cambiamos Li( x ) por Ri( x ),
x

Li( x ) − π ( x )

Ri( x ) − π ( x )

1013

108971.

−5773

1018

21949555.

−3501366

1022

1932355207.

−127132665

Tabla 7.7. Comparando π ( x ) con Ri( x )

7.5.2

Teorema de Mertens.

En este apartado vamos a aplicar algunos cálculos aproximados para establecer un resultado
muy curioso: Típicamente, los números grandes tienen factores primos pequeños.
Observemos que en el conjunto {1, 2, 3, ..., 9} solo 3, 6 y 9 son divisibles por 3. En términos de
proporciones, una tercera parte. La tabla que sigue muestra las proporciones al variar n. Es ésta
tabla, dn denota la cantidad de enteros positivos ≤ n que son divisibles por 3.

n
8680
76333
554615

dn /n ≈ 1/3
0.33329493087557605
0.33332896650203714
0.333332131298288

Tabla 7.8. Proporción de números divisibles por 3 .

Como 1/p es la proporción aproximada de números, en el conjunto {1, 2, ..., n}, divisibles por p,
1 − 1/p sería la proporción de números en este conjunto que no son divisibles por p.
Aquí estamos asumiendo demasiado porque esta proporción no es exactamente 1/p. Este número
solo es una
 aproximación.

 Si “ser divisible por p” es un evento independiente de “ser divisible
1
1
1−
sería la proporción de números en el conjunto {1, 2, ..., n}, que no son
por q”, 1 −
p
q
divisibles por p ni por q.

144

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

En general,

∏

2≤ p≤ G,
p primo,



1
1−
p


sería una estimación de la proporción de números en el conjunto

{1, 2, ..., n}, que no son divisibles por ninguno de los primos menores o iguales a G. Esto si tiene
utilidad práctica, como veremos más adelante.

Ejemplo 7.14
Hagamos un experimento. Sea dn = #{m ≤ n : m es divisible por 2, 3, 5, o 7}.

n

dn

dn /n

103790

80066

0.7714230658059543

949971

732835

0.7714288120374201

400044

308605

0.7714276429592745

117131

90359

0.7714354013881893

124679

96181

0.7714290297483939

Tabla 7.9

La proporción de números naturales ≤ n divisibles por 2, 3, 5 es ≈ 0.7714. Así,
1 − 0.7714 = 0.2286 es la proporción de números en {1, 2, ..., n} que no son divisibles por
los primos 2, 3, 5 y 7.





1
1
1
1
Y efectivamente, 1 −
1−
1−
1−
= 0.228571.
2
3
5
7

Si intentamos calcular el producto para cantidades cada vez grandes de primos, rápidamente
empezaremos a tener problemas con el computador. En vez de esto, podemos usar el

Teorema 7.7 (Fórmula de Mertens).


1
e−γ
∏ 1 − p = ln(x) + O(1/ ln(x)2 )
2≤ p≤ x,
p primo

γ es la constante de Euler

Para efectos prácticos consideramos la expresión

∏

2≤ p≤ x,
p primo



1
1−
p



∼

e−γ
0.5615
≈
si x −→ ∞
ln( x )
ln( x )

(7.4)

145

Ejemplo 7.15
Veamos la fórmula en acción,

∏√

x

primos

(1 − 1/p)

p≤ x

2e−γ
ln( x )

100000

0.0965

0.0975

100000000000000

0.034833774529614024

0.03483410793219253

Tabla 7.10

También, multiplicando (7.4) por 2, la fórmula

G

∏



3 ≤ p,
p primo

1
1−
p



∼

1.12292
2e−γ
≈
ln( G )
ln( G )

nos daría la proporción aproximada de números impares que no tienen un factor primo ≤ G.

Ejemplo 7.16
En este ejemplo se muestra que los números grandes sin factores primos pequeños no
son el caso típico.
G

Proporción approx de impares
sin factores primos ≤ G.

100

0.243839

1000

0.162559

10000

0.121919

100000

0.0975355

1000000

0.0812796

10000000

0.0696682

100000000

0.0609597

1000000000

0.0541864

10000000000

0.0487678
Tabla 7.11

Esta tabla nos informa que “típicamente”, los números grandes tienen factores primos
pequeños.

146

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

7.6

Números Armónicos
∞

Aunque la serie armónica

1

∑k

n

es divergente, la función Hn =

1

∑k

es muy útil en teoría

k =1

k =1

analítica de números.
Lema 7.4
Existe una número real γ, llamada constante de Euler, tal que
Hn = ln(n) + γ + O (1/n) .
Prueba: Hay que mostrar que ∃C tal que 0 < Hn − ln(n) − γ < C · 1/n para n > n0 . Usando
integral de Riemann,
n −1

1
∑k=
k =1

Z n
1
1

x

dx + En i.e. Hn−1 = ln(n) + En

(a)

(b)

Figura 7.1. Comparando el área ln(n) con la suma Hn .

Geométricamente, Hn−1 corresponde a la suma de las áreas de los rectángulos desde 1 hasta n
y En la suma de las áreas de las porciones de los rectángulos sobre la curva y = 1/x.
En el gráfico (b) de la figura 7.1 vemos que En ≤ 1 para toda n ≥ 1, así que En es una función
de n, que se mantiene acotada y es creciente, por lo tanto esta función tiene un límite, el cual
vamos a denotar con γ. Así, lim En = γ. En particular, para cada n fijo, γ > En .
n→∞

Como γ − En corresponde a la suma (infinita) de las áreas de las regiones sombreadas en la
figura 7.6, se establece la desigualdad
γ − En < 1/n
de donde
0 < γ − ( Hn−1 − ln(n)) < 1/n.
Ahora restamos 1/n a ambos lados para hacer que aparezca Hn , tenemos
1
> Hn − ln(n) − γ > 0
n
que era lo que queríamos demostrar.

...

147

Aunque en la demostración se establece Hn − ln(n) − γ < 1/n, la estimación del error O(1/n)
corresponde a una función dominada por un múltiplo de 1/n. Veamos ahora algunos cálculos
que pretender evidenciar el significado de O(1/n).

n

Hn

ln(n)

| Hn − ln(n) − γ|

1/n
5.88235294 × 10−6

170000

12.62077232

12.62076938

2.94117358 × 10−6

180000

12.67793057

12.67792779

2.77777520 × 10−6

5.55555555 × 10−6
5.26315789 × 10−6
5. × 10−6

190000

12.73199764

12.73199501

2.63157663 × 10−6

200000

12.78329081

12.78328831

2.49999791 × 10−6

Observando las dos últimas columnas se puede establecer una mejor estimación del error con
1
1
1
!
y todavía mejor con
−
2n
2n 12n2
1
1
−
2n
12n2

n

Hn

ln(n) + γ +

100000

12.090146129863427

12.090146129863427

150000

12.495609571309556

12.495609571309554

200000

12.783290810429621

12.783290810429623

También, de estas tablas se puede obtener la aproximación γ ≈ 0.577216

Lema 7.5
n

n

k =1

k =1

∑ τ (k) = nH (n) + O(n) y ∑ τ (k)

= n ln(n) + O(n).

Prueba: Como τ (k) = ∑ 1, ∑nk=1 τ (k) = ∑nk=1 ∑d|k 1
d|k

La idea ahora es usar argumentos de divisibilidad para usar la expansión del ejemplo 7.3. Si
d|k entonces k = d · c ≤ n. Esto nos dice que el conjunto de todos los divisores positivos de los
números k inferiores o iguales a n, se puede describir como el conjunto de todos los pares (c, d)
con la propiedad cd ≤ n (por supuesto, se puede hacer una demostración formal probando la
doble implicación “⇐⇒”).
Ahora, cd ≤ n ⇐⇒ d ≤ n ∧ c ≤ n/d. Entonces podemos escribir,
n

∑ τ (k) = ∑ 1 = ∑ ∑

k =1

La suma

∑

c≤n/d

sumandos, i.e.

c,d
cd≤n

1

d≤n c≤n/d

1 corre sobre los enteros positivos menores o iguales que n/d. Esto nos da Jn/dK

∑

c≤n/d

1 = Jn/dK . Finalmente, usando el ejemplo 7.3,

148

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

n

∑ τ (k)

=

∑ [n/d]

d≤n

k =1

=

∑ {n/d + O(1)}

d≤n

=

∑ n/d

+

d≤n

= n

∑ 1/d

∑ O (1)

d≤n

+

d≤n

∑ O (1)

d≤n

= n Hn + O(n)
En los ejercicios se pide mostrar, usando la figura 7.1, que Hn = log(n) + O(1). Usando este
hecho,
n

∑ τ (k) = n Hn + O(n) = n {ln(n) + O(1)} + O(n) = n ln(n) + O(n).

k =1

(Los pequeños detalles que faltan se completan en los ejercicios)

7.7

Acerca de los factores de un número grande

Los siguientes teoremas, los cuales podemos ver en ([8]), nos dan información acerca de qué se
podría esperar cuando se intenta factorizar un número grande. Aquí hay que tener cuidado: Las
interpretaciones de los teoremas no son del todo rigurosas, solamente son argumentos heurísticos para obtener estimaciones gruesas.
Teorema 7.8
Sea πk ( x ) el número de enteros ≤ x que tienen exactamente k factores primos diferentes, k ≥ 2.
Entonces
6 x (ln ln x )k−1
πk ( x ) ∼ 2
= π ∗ ( x ) cuando x −→ ∞
π ln x (k − 1)!
La aproximación π ∗ ( x ) de πk ( x ) funciona si k = (1 + o (1)) ln ln x, es decir, si k está en un
vecindario de ln ln x. Por ejemplo, si tomamos x = 10100 y k = 15, la proporción de números
compuestos (de la totalidad de los compuestos inferiores a x ) no da ≈ 0.15%. Esto no dice que
los números cercanos a x = 10100 , con 15 o más factores, no son muy populares.
Otro teorema útil es el siguiente,
Teorema 7.9
“Normalmente”, el número de factores primos diferentes de N es aproximadamente, ln ln N
En este teorema,“Normalmente” significa que la mayoría de los enteros cercanos a N tienen una
cantidad de factores primos entre (1 − ε) ln ln N y (1 + ε) ln ln N con ε > 0.

149

Ahora, siguiendo un argumento heurístico, podemos concluir que típicamente, la cantidad de
dígitos del factor primo más grande de N es aproximadamente un 63% de la cantidad de dígitos de N. Si P es el factor primo más grande de N, puesto que log N es proporcional a la
cantidad de dígitos de N, esta estimación se puede poner como log P ≈ 0.63 log N.
La heurística es muy sencilla, si N tiene s factores, N/P tendría s − 1 ≈ ln ln N/P = ln ln N +
ln(1 − ln P/ ln N ) = s + ln(1 − ln P/ ln N ). Entonces, tomando logaritmo, 1 − ln P/ ln N ≈ 1/e.
Luego, ln P ≈ (1 − 1/e) ln N = 0.632 ln N.
En particular, para el segundo factor primo P2 de N, típicamente tendríamos log P2 ≈ 0.23 log N.
Para terminar, vamos a hablar un poco del teorema de Erdös-Kac. El teorema del límite central
dice que si una población (continua o discreta) tiene media µ y varianza finita σ2 , la media
muestral X tendrá una distribución que se aproxima a la normal.

Teorema 7.10 (Limite Central)
Si tenemos X1 , X2 , ..., Xn variables aleatorias independientes, idénticamente distribuidas, con
media µ y varianza σ2 , entonces, si n es suficientemente grande, la probabilidad de que
√
√
µ + α σ n y nµ
µ + β σ n es
Sn = X1 + X2 + ... + Xn esté entre nµ
1
√
2π

Z β

e

−t2 /2

dt

α

Ejemplo 7.17
Si lanzamos una moneda limpia unas 10000 veces, uno esperaría que aproximadamente
5000 veces salga “cara”. Si denotamos con Xi = 1 el evento “en el lanzamiento i sale
cara”, como la probabilidad√que asumimos para el evento “sale cara” es 1/2, entonces
µ = n · 0.5 = 5000 y σ = n · 0.25 = 5. Luego, para calcular la probabilidad de que
nµ
el número de caras esté entre 4850 y 5150, debemos calcular los límites α y β. Por
razones de ajuste del caso
de corrección de 1/2.
√discreto al caso continuo, se usa un factor √
Resolviendo, 5000 + (α) 50 = 4850 − 0.5 =⇒ α = −3.01 5000 + (α) 50 = 5150 + 0.5 =⇒
β = 3.01
1
√
2π

Z 3.01
−3.01

e

−t2 /2

dt = 0.997388

Así, la probabilidad de que el número de caras esté entre 4850 y 5150 es de 0.997388
Si ω (n) denota la cantidad de factores primos de n, esta función se puede denotar como una
suma de funciones ρ p (n), estadísticamente independientes, definidas por

ρ p (n) =

1
0

si
si

p|n
p-n

150

ESTIMACIONES, ESTAD˝STICAS Y PROMEDIOS

Esto sugiere que la distribución de los
√ valores de ω (n) puede ser dada por la ley normal (con
media ln ln n y desviación estándar ln ln n ).
Mark Kac y Paul Erdös probaron que la densidad del conjunto de enteros
√ n para el cual
el√número de divisores primos ω (n) está comprendido entre ln ln n + α ln ln n y ln ln n +
β ln ln n, es
β −t2 /2
1
√
e
dt
2π α
es decir, el número de divisores primos está distribuido de acuerdo a la ley normal.

Z

Teorema 7.11
Denotamos con N ( x, a, b) la cantidad de enteros n en {3, 4, ..., x } para los cuales
α≤

ω (n) − ln ln n
√
≤β
ln ln n

Entonces, conforme x → ∞,
1
N ( x, a, b) = ( x + o ( x )) √
2π

Z β

e

−t2 /2

dt

α

EJERCICIOS
7.1

Muestre que 7x3 − 12x + 9  x3 conforme x → ∞. Ayuda: Use la derivada.

7.2

Si f , g : N −→ R+ , muestre que Máx{ f (n), g(n)} = O( f (n) + g(n)).

7.3

Muestre que 2n+1 = O(2n ) pero 22n 6= O(2n )

7.4

Muestre que f ∈ O( g) no implica necesariamente que g ∈ O( f )

7.5 Si f (n) ≥ 1 y lg[ g(n)] ≥ 1 entonces muestre que si f ∈ O( g) =⇒ lg[ f ] ∈ O(lg[ g])
Ayuda: Use la hipótesis para concluir que lg f (n) ≤ lg c + lg g(n) ≤ (lg c + 1) lg g(n).
7.6

Usando la figura 7.1, muestre que Hn = log(n) + O(1).

7.7

Muestre que

∑τ (d)µ (n/d) = 1
d|n

EJERCICIOS

151

Versión actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

Parte II

INTRODUCCION A LA TEORIA
ALGORITMICA DE NUMEROS.

235711
131719
232931
235711

8

ALGORITMOS PARA EL
MCD

“...tal parece que ni siquiera un procedimiento tan venerable como el algoritmo de
Euclides puede soportar el progreso”
Donald Knuth ([18], pág 340).

El cálculo del máximo común divisor (mcd) de dos enteros grandes (y también de dos polinomios) es omnipresente en el cálculo con racionales, criptografía de clave pública y álgebra
computacional. De hecho los cálculos algebraicos usuales gastan más de la mitad del tiempo
de ejecución en el cálculo del máximo común divisor de enteros frecuentemente muy grandes
([16]). Como los cálculos son muy demandantes, se requiere algoritmos muy eficientes para el
cálculo del mcd.
Antes de la década de los 70’s, el cálculo se hacía con el algoritmo de Euclides clásico o con la
versión mejorada de Lehmer6 (1938). El algoritmo de Euclides (además de su gran valor teórico)
es sencillo de enunciar e implementar y es muy eficiente, pero hay algoritmos igual de sencillos
y más rápidos. Si los números vienen codificados en binario, teóricamente habría una mejora del
60% ([22]) en la eficiencia. Estos algoritmos se usan desde hace unos cuarenta años atrás. El más
popular es el algoritmo “binario” para el cálculo del mcd (algunos autores le llaman “algoritmo
binario de Euclides). Este algoritmo fue descubierto por el físico Israelí J. Stein en 1961. D. Knuth
hace la observación de que este algoritmo podría tener un pedigrí muy distinguido pues parece
ser que ya era conocido en la antigua China (un siglo d.C.). Este último algoritmo solo usa restas,
prueba de paridad y divisiones por dos (mucho menos costosas que las divisiones que requiere
el algoritmo de Euclides). Desde el punto de vista del computador la división por dos (y también
la multiplicación por 2) se hace en representación binaria, así que solo se requiere un desplazamiento de bits. Por ejemplo, 344 = (101011000)2 , 344/2 = (10101100)2 y 2 · 344 = (101011000)2 .
Refiriéndose al algoritmo binario Donald Knuth decía en 1980, “...parece que ni siquiera un procedimiento tan venerable como el algoritmo de Euclides puede soportar el progreso” ([18], pág
340).
Al igual que hay un algoritmo extendido de Euclides también hay una versión extendida del
algoritmo binario más eficiente y también hay una versión para polinomios (Z[ x ] es tanto un
dominio Euclidiano como un “dominio de Stein”). De nuevo aquí, mientras que el algoritmo de
6 Esta

variante del algoritmo de Euclides se aplica para calcular el mcd( a, b) si a y b son números muy grandes. La idea
es aplicar el algoritmo de Euclides usando, en los primeros pasos, Ta/10k U y Tb/10k U en vez de a y b . Una descripción
completa se puede ver en [18], págs 345-348.

153

154

ALGORITMOS PARA EL MCD

Euclides requiere, en general, división por polinomios de grado mayor o igual a uno, el algoritmo binario solo requiere dividir por x. Sin embargo, el cálculo del máximo común divisor de
dos polinomios con coeficientes enteros no se hace con ninguno de estos algoritmos, más bien se
usan algoritmos modulares (Mathematica) o el llamado “algoritmo heurístico para polinomios”
(Maple).
El algoritmo de Euclides es muy adecuado para el tratamiento teórico que se hace en los libros
de álgebra y teoría de números. Además es muy eficiente para el cálculo. El algoritmo binario
y sus variantes (algunas más eficientes que el algoritmo original), aparece de manera natural en
el contexto de la teoría algorítmica de números porque aquí si importa ganar en eficiencia. En
todo caso, no estaría del todo mal si en los libros de teoría de números, además de incluir notas
históricas, apareciera un epílogo contando por donde va la novela en nuestros días.
En este trabajo se muestran cuatro algoritmos: El algoritmo clásico de Euclides, el algoritmo
de Euclides con “menor resto”, el algoritmo binario y el algoritmo LSBGCD (left-shift binary
algorithm) que vendría a ser como una versión binaria del algoritmo de Euclides. Como las implementaciones son sencillas, se implementan en la hoja electrónica de OpenOffice.org, usando
el lenguaje OOoBasic.

8.1

Parte entera.

La función parte entera superior de un número x, denotada ceil(x), devuelve el menor entero
mayor o igual a x, es decir,
VxW = Mín{n ∈ Z | n ≥ x }.
Por ejemplo, Ceil(2.25)=3, Ceil(2)=2 y Ceil(-2.25)=-2. La función parte entera inferior, denotada Floor(x), devuelve el más grande entero menor o igual a x, es decir,
TxU = Máx{n ∈ Z | n ≤ x }.
Por ejemplo, Floor(2.8)=2, Floor(-2)=-2 y Floor(-2.3)=-3.
Notemos que VxW = TxU si y sólo si x es entero, en otro caso VxW = TxU + 1.
El entero “más cercano” a x ≥ 0 es Tx + 1/2U ([17],pág 70,ejercicio 5). En la sección 8.4 usaremos
la fórmula (para x ≥ 0 ),

Tx + 1/2U =


 TxU

si

pfrac( x ) ≤ 1/2



si

pfrac( x ) > 1/2

TxU + 1

(8.1)

donde la parte fraccionaria, denotada “pfrac”, de un número real x ≥ 0 se define con la ecuación

x = TxU + pfrac( x ).

155

Por ejemplo, 2.71 = 2 + 0.71 ⇒ pfrac( x ) = 0.71. En la figura (8.1) se muestra la fórmula desde el
punto de vista geométrico.

Figura 8.1

Aspectos computacionales. En OOoBasic tenemos la división entera a\b (con barra invertida)
y la función Int.
Int( x ) = TxU
a\b =

e Int( x ) + 1 = VxW

 Ta/bU si a/b ≥ 0


Por ejemplo, -7\2= −3 y 3\2= 1.

8.2

Va/bW si

a/b < 0

División con menor resto.

El teorema de la división7 establece que si a, b ∈ Z con b 6= 0, existen q, r ∈ Z únicos tales que
a = b · q + r con 0 ≤ r ≤ |b|.
A q se le llama cociente y r se le llama resto y, por supuesto, r = a − bq

Esta manera de enunciar este teorema es muy apropiada para fines teóricos. Que el resto sea
positivo es adecuado, como vimos, para mostrar unicidad.
Sin embargo el resto no tiene porque ser positivo, por ejemplo si a = 144 y b = 89,
144

= 89 · 1 + 55,

resto r2 = 55 < b = 89

144

= 89 · 2 − 34,

resto r1 = 34 < b = 89

Cuando calculamos por ejemplo el máximo común divisor de dos números usando el algoritmo
de Euclides, el número de pasos se reduce si tomamos el resto más pequeño en cada paso. Esto
no afecta el algoritmo.
7 Extrañamente

a veces a este teorema se le llama “algoritmo de la división”. En el contexto computacional, el algoritmo
de a división se refiere a los pasos para dividir u por v en el caso de que u y v estén representados en base b . En este
caso, el algoritmo calcula Tu/vU.

156

ALGORITMOS PARA EL MCD

Veamos los cálculos. Recordemos que


 sgn(b) = 1


sgn(b) = −1

si

b > 0,

si

b < 0.

Teorema 8.1
Sean a, b ∈ Z con b 6= 0. Sea q ∈ Z definido como

 q = Ta/bU

si

b > 0,



si

b < 0, y a/b ∈
/Z

(8.2)

q = Ta/bU + 1

entonces la división con resto se puede hacer de dos maneras,

 a.) a = bq + r2


con 0 ≤ r2 < |b|

b.) a = b(q + sgn(b)) − r1

con 0 ≤ r1 < |b|

Además, si a ≥ 0, b > 0 y r = mín{r1 , r2 }, entonces r = | a − b · Ta/b + 1/2U|

¿Cómo llegamos a este resultado? Vamos a ver cómo.
Cálculo de q y ri Sean a, b ∈ Z con b 6= 0. Usando el principio del buen orden se puede
establecer que existe q ∈ Z tal que bq es el múltiplo de b más cercano a a por la izquierda (ver
figura 8.2). Por tanto,
bq ≤ a < bq + b si b > 0

y

bq ≤ a < b(q − 1) si b < 0.

Figura 8.2

Entonces, podemos expresar a en términos de bq con resto positivo o en términos de bq + |b| =
b(q + sng(b)) con resto negativo (esta fórmula funciona para b positivo o negativo).
Recordemos que q = Ta/bU si b > 0 y q = Va/bW si b < 0. Para usar un mismo q, usamos el
hecho de que si a/b ∈
/ Z, entonces Va/bW = Ta/bU + 1 (si a/b ∈ Z el resto sería cero). Por tanto,

 q = Ta/bU

si

b>0



si

b<0

q = Ta/bU + 1

Entonces tenemos (sin importar el signo de a y b ),

(8.3)

157


 a.) a = bq + r2


b.) a = b(q + sgn(b)) − r1

con

0 ≤ r2 < | b |

con

0 ≤ r1 < | b |

Ejemplo 8.1
a.) Si a = 144 y b = 89,

144

= 89 · 1 + 55,

con resto r2 = 55 < b = 89

144

= 89 · 2 − 34,

con resto r1 = 34 < b = 89

b.) Si a = 144 y b = −89, entonces q = T144/(−89)U + 1 = −2 + 1 = −1 y q + sgn(b) =
−2. Entonces,

144

= −89 · −1 + 55,

con resto r2 = 55 < |b| = 89

144

= −89 · −2 − 34,

con resto r1 = 34 < |b| = 89

Cálculo del menor resto. En la sección 8.4 vamos a necesitar el teorema de la división pero
con el menor resto. Para simplificar los cálculos, queremos calcular el menor resto usando una
fórmula directa. Como se observa en la figura 8.3, uno de los restos es menor que |b|/2. Si
r = Mín{r1 , r2 } entonces, existe q0 ∈ Z tal que
a = bq0 ± r con 0 ≤ r ≤ |b|/2.

Figura 8.3

Para los cálculos que vamos a hacer aquí solo necesitamos tratar el caso en que a ≥ 0 y b > 0.
Para comparar los restos a − b · Ta/bU y b · (Ta/bU + 1) − a usamos el hecho de que a/b =
Ta/bU + pfrac( a/b).

158

ALGORITMOS PARA EL MCD

El menor resto es a − b · Ta/bU si pfrac( a/b) ≤ 1/2. En efecto,
a − b · Ta/bU
2a

2a/b
pfrac( a/b)

≤ b · (Ta/bU + 1) − a
≤ 2b · Ta/bU + b

≤ 2Ta/bU + 1, como a/b = Ta/bU + pfrac( a/b),
≤ 1/2.

De manera análoga, a − b · Ta/bU ≥ b · (Ta/bU + 1) − a si pfrac( a/b) ≥ 1/2.
Así,

el menor resto es r =


 a − b · Ta/bU


si

pfrac( a/b) ≤ 1/2,

| a − b · (Ta/bU + 1)| si pfrac( a/b) > 1/2.

Como habíamos establecido antes (ecuación 8.2),

Ta/b + 1/2U =


 Ta/bU

si

pfrac( a/b) ≤ 1/2,



si

pfrac( a/b) > 1/2,

Ta/bU + 1

entonces,
el menor resto es r = | a − b · Ta/b + 1/2U|.

Aspectos computacionales. En OOoBasic de Libreoffice “el resto” se calcula con la función
binaria Mod. Se implementa como a Mod b= a − b · (a\b) y tenemos
a = b · a\b + a Mod b
Por ejemplo, si a = −144 y b = −89 entonces a\b= 1 y a Mod b= −55.
Si a Mod b< 0 y queremos el resto r2 positivo, la figura 8.3 nos sugiere r2 = a Mod b + |b|, en
este caso,
a = b · (a\b − sgn(b)) + a Mod b+|b|

El menor resto se calcula como r = | a − b · Ta/b + 1/2U| =Abs(a-b*Int(a/b-1/2)).

159

8.3

Algoritmo de Euclides II.

El algoritmo de Euclides encuentra el máximo común divisor de dos enteros. Este algoritmo usa
divisiones y restas y está basado principalmente en las identidades

mcd ( a, b) = mcd (b, a − bq), mcd (r, 0) = r,

de tal manera que si a = bq + r1 y b = r1 q1 + r2 con 0 ≤ r2 < r1 < b,

mcd ( a, b) = mcd (b, r1 ) = mcd (r1 , r2 ),

es decir, conforme aplicamos esta relación, cambiamos el cálculo del mcd de dos números a y b
por el mcd de dos números más pequeños. El proceso es finito y se detiene cuando encontramos
un resto nulo8 .
Formalmente: Sean a y b números naturales, b 6= 0. Aplicando el algoritmo de la división se
obtiene una sucesión finita r1 , r2 , ..., rn definida por

a
b
r1
r n −2
r n −1

= bq1 + r1 ,
= r1 q2 + r2 ,
= r2 q3 + r3 ,
..
.

0 ≤ r1 < r0
0 ≤ r2 < r1
0 ≤ r3 < r2

= r n −1 q n + r n ,
= r n q n +1 + 0

0 ≤ r n < r n −1

rn = mcd ( a, b) pues mcd ( a, b) = mcd (b, r1 ) = mcd (r1 , r2 ) = ... = mcd (rn , 0) = rn .

Ejemplo 8.2
Vamos a aplicar el algoritmo de Euclides para calcular mcd (89, 144). Aquí estamos aplicando el algoritmo sobre dos números consecutivos de Fibonacci. Este tipo de pares son
los que le demandan mayor esfuerzo al algoritmo de Euclides ([13],págs 68-69) pues
siempre q = 1.
8 La

versión original de Euclides no es esta, en ese tiempo no había noción del cero ni se consideraba a la unidad como un
divisor. Para los griegos antiguos dos enteros positivos eran o ambos iguales a la unidad o eran primos relativos o tenían
un máximo común divisor. La versión original ([18],pág 336) sería (sin usar lenguaje geométrico): Sean a, b mayores que
la unidad. Si b divide a a , el mcd es b , si el resto de dividir a por b es la unidad, los números son primos relativos, en
otro caso reemplace el par de valores ( a, b) por (r, b).

160

ALGORITMOS PARA EL MCD

144
89
55
34
21
13
8
5
3
2

=
=
=
=
=
=
=
=
=
=

89 · 1 + 55
55 · 1 + 34
34 · 1 + 21
21 · 1 + 13
13 · 1 + 8
8·1+5
5·1+3
3·1+2
2·1+1
1·2+0

=⇒

mcd (89, 144)

=
=
=
=
=
=
=
=
=
=

mcd (89, 55)
mcd (55, 34)
mcd (34, 21)
mcd (21, 13)
mcd (13, 8)
mcd (8, 5)
mcd (5, 3)
mcd (3, 2)
mcd (2, 1)
mcd (1, 0) = 1.

mcd (89, 144) = 1.

8.3.1

Algoritmo e implementación.

La implementación de este algoritmo se hace solo con fines ilustrativos. El algoritmo funciona
bien si usamos r =a Mod b. Pero, para seguir el algoritmo al pie de la letra, vamos a usar restos
positivos. Se necesitan tres variables: c para el nuevo dividendo, d para el nuevo divisor y r
para el resto (positivo). La función que calcula q la llamamos cquo, es decir, q=cquo(a,b). La
función que calcula el resto positivo la llamamos crem, r=crem(a,b).

Algoritmo 8.1: Máximo común divisor: Algoritmo de Euclides
Datos: a, b ∈ Z, b 6= 0.
Salida: mcd ( a, b)
1 if a = 0 then
2
return mcd ( a, b) = |b|

7

c = | a |, d = | b | ;
while d 6= 0 do
r =crem(c, d);
c = d;
d = r;

8

return mcd ( a, b) = |c|;

3
4
5
6

161

Ejemplo 8.3
Veamos como funciona el algoritmo, calculamos mcd (89, 144),
c

144

=

.

c

89

d

crem(c,d)

d

crem(c,d)

d

crem(c,d)

55 ·1+

=

34 ·1+

=

21 ·1+

.

c

34

crem(c,d)

=

.

c

55

d

89 ·1+

.

55
34
21
13

..
.
c

2

d

= 1 ·2 + 0

mcd (89, 144) = 1.

Implementación en LibreOffice. La función crem necesita la función cquo.

[Descargar]

Function cquo(a,b) As Long
Dim q As Long
If b=0 then
msgbox "Error, b=0"
Exit Function
End If
q = Int(a/b)
If b<0 Then
End If
cquo = q
End Function

q = q+1

162

ALGORITMOS PARA EL MCD

Function crem(a,b) As Long
crem = a-b*cquo(a,b) ’rem resto positivo
End Function
Function mcdEuclides(a,b) As Long
Dim c As Long, d As Long, r As Long
If a=0 Then
c = abs(b)
Else
c=a : d=b
While d<> 0
r= crem(c,d)
c = d
d = r
Wend
End If
mcdEuclides = abs(c)
End Function

8.4

Algoritmo de Euclides con menor resto.

En la versión “clásica” del algoritmo de Euclides, el resto ri está entre 0 y ri−1 . Podemos hacer
una pequeña variación para que cada nuevos resto ri esté entre 0 y ri−1 /2 con lo que, en general, podría haber una reducción en el número de divisiones. Kronecker estableció en 1901 que
el número de divisiones en el algoritmo “con menor resto” es menor o igual que el número de
divisiones en el algoritmo clásico de Euclides.

Como mcd ( a, b) = mcd (| a|, |b|) vamos a suponer que a ≥ 0 y b > 0. Recordemos que
a = b · Ta/bU + r2 . 0 ≤ r2 < b
a = b · (Ta/bU + 1) − r1 . 0 ≤ r1 < b
Para mejorar un poco el desempeño del algoritmo de Euclides, escogemos en cada paso el menor
resto, es decir, r = Mín{r1 , r2 } = Mín{| a − b · Ta/bU|, | a − b · (Ta/bU + 1)|}. De esta manera
r ≤ b/2.
El algoritmo de Euclides sigue siendo válido pues si tomamos el menor resto r en cada paso,
mcd ( a, b) = mcd (b, r ) y de nuevo obtenemos una sucesión decreciente de restos, el último resto
no nulo |rn | es el mcd de a y b. Por supuesto,
r = Mín{r1 , r2 } = a − b · Ta/b + 1/2U.

163

Ejemplo 8.4
Vamos a aplicar el algoritmo de Euclides, usando el menor resto, para calcular
mcd (89, 144). Como mcd ( a, b) = mcd (| a|, |b|), en cada paso usamos dividendo y
divisor positivo.

144
89
34
13
5
2

=
=
=
=
=
=

89 · 2 − 34
34 · 3 − 13
13 · 3 − 5
5·3+2
2·2+1
1·2+0

=⇒

mcd (89, 144)

=
=
=
=
=
=

mcd (89, 34)
mcd (34, 13)
mcd (13, 5)
mcd (5, 2)
mcd (2, 1)
mcd (1, 0) = 1

mcd (89, 144) = 1.

8.4.1

Implementación.

La implementación es la misma que la del algoritmo de Euclides clásico. Solo vamos a cambiar la
función crem(a,b) por la nueva función srem(a,b)= a − b · Ta/b + 1/2U. El valor absoluto no es
necesario porque lo que interesa en el algoritmo es que los restos disminuyan (en valor absoluto).

’-------- LibreOffice Basic
Function mcdMenorResto(a,b) As Long
Dim c As Long, d As Long, r As Long
If a=0 Then
c = b
Else
c=a
d=b
While d<> 0
r = c-d*Int(c/d+1/2) ’rem q= Int(c/d+1/2)
c = d
d = r
Wend
End If
mcdMenorResto = Abs(c)
End Function

Por ejemplo, si imprimimos cada paso de la implementación con a = −144 y b = −89, se obtiene

164

ALGORITMOS PARA EL MCD

-144 = -89*2

+ 34

mcd(-144,-89)= mcd(89,34)

-89

=

34*-3

+ 13

= mcd(34,13)

34

=

13*3

- 5

= mcd(13,5)

13

=

-5*-3

- 2

= mcd(5,2)

-5

=

-2*3

+ 1

= mcd(2,1)

-2

=

+ 0

= mcd(1,0)=1

8.5

1*-2

Algoritmo binario.

El algoritmo binario opera con la misma idea, cambiar mcd ( a, b) por el mcd de dos números
eventualmente más pequeños, solo que esta vez solo restamos y dividimos por 2. El algoritmo
opera con las siguientes teoremas,


a b
Regla 1. Si a, b son pares, mcd ( a, b) = 2 mcd
,
2 2

Regla 2. Si a es par y b impar, mcd ( a, b) = mcd



a
,b
2






| a − b|
| a − b|
Regla 3. Si a, b son impares, mcd ( a, b) = mcd
, b = mcd
,a
2
2



La regla 3 se aplica como mcd ( a, b) = mcd


| a − b|
, Mín{ a, b} . La prueba de estas reglas están
2

al final de esta sección.
El algoritmo procede así: Supongamos que a, b ∈ Z, a ≥ 0, b > 0. Si a y b son pares, aplicamos
la regla 1, digamos s veces, hasta que alguno de los dos sea impar. Al final hay que multiplicar
por 2s como compensación por haber usado la regla 1, s veces. Si todavía a o b es par, aplicamos la regla 2 hasta que ambos queden impares. Siendo los dos impares, aplicamos la regla 3
| a − b|
y luego alternamos las reglas 2 y 3 conforme el cociente
sea par o impar.
2

Ejemplo 8.5
Vamos a aplicar el algoritmo de binario para calcular mcd (89, 144) y mcd (8, 48).
Recordemos que aquí la ganancia no esta en la disminución del número de pasos (de

165

hecho podrían ser más pasos que los que utiliza el algoritmo de Euclides) sino en operar
dividiendo por 2.

mcd (89, 44)

mcd (8, 48)

= mcd (22, 89),
= mcd (11, 89),
= mcd (39, 11),
= mcd (14, 11),
= mcd (7, 11),
= mcd (2, 7),
= mcd (1, 7),
= mcd (3, 1),
= mcd (1, 1),
= mcd (0, 1),
= 1
=
=
=
=
=
=
=

2·
4·
8·
8·
8·
8·
8

mcd (4, 24),
mcd (2, 12),
mcd (1, 6)
mcd (1, 3),
mcd (1, 1),
mcd (0, 1),

por Regla 2
por Regla 2
por Regla 3
por Regla 3
por Regla 2
por Regla 3
por Regla 2
por Regla 2
por Regla 3
por Regla 3

por Regla 1
por Regla 1
por Regla 1
por Regla 2
por Regla 3
por Regla 3

Por supuesto, en cálculo manual terminamos cuando obtenemos mcd (0, d) = d o
mcd (1, d) = 1.

El algoritmo funciona pues la aplicación de las reglas va produciendo una sucesión de pares
tal que si ( a0 , b0 ) y ( a00 , b00 ) son dos pares consecutivos, entonces 0 ≤ a0 b0 < a00 b00 . Este un proceso finito que nos lleva hasta el par mcd (0, d). Para ver esto, observemos que la regla 1 y la
regla 2 siempre llevan a la regla 3. Al aplicar esta regla al nuevo par ( a, b), si a = b nos queda
b−a
< b/2 < b,
mcd (0, mín{ a, b}) y terminamos; sino, supongamos que 0 < a < b, entonces
2
b
−
a
es decir, en esta regla 3 cambiamos a y b por a0 = a y b0 =
< b, por tanto el nuevo
2
0
0
0
0
par ( a , b ) cumple a b < ab. El algoritmo termina cuando obtenemos el par (0, d) y entonces
mcd ( a, b) = 2s · mcd (0, d) = 2s · d.

8.5.1

Algoritmo e Implementación.

En la primera parte del algoritmo,si a y b 6= 0 son pares, se dividen ambos por dos hasta que
uno de los dos sea impar.
Luego, mientras a 6= 0, si uno es par y el otro impar, aplicamos la regla dos hasta ambos sean
impares. Una vez que los dos son impares, aplicamos la regla tres. Las reglas dos y tres se aplican mientras a = Abs( a − b)/2 no se anule.

166

ALGORITMOS PARA EL MCD

Aquí suponemos que a, b ∈ Z, a ≥ 0, b > 0. La división por 2, denotada quo ( a, 2) en el algoritmo, se hace con la división entera usual a\2.

Algoritmo 8.2: Algoritmo binario para el mcd
Datos: a, b ∈ Z, a ≥ 0, b > 0
Salida: mcd ( a, b)
1 g = 1;
2 while rem( a, 2) = 0 And rem( b, 2) = 0 do
3
a = quo ( a, 2), b = quo (b, 2);
4
g = 2g //removiendo potencias de 2
5

while a 6= 0 do // Ahora, a o b es impar

6
7
8
9
10
11

if rem( a, 2) = 0 then
a = quo ( a, 2)
else if rem(b, 2) = 0 then
b = quo (b, 2)
else ; // ambos impares

12
13
14

t = quo (| a − b|, 2) ;
if a ≥ b then ; // reemplazamos máx{ a, b} con quo (| a − b|, 2)

15
16
17
18

a=t
else
b=t

19
20

return g · b;

Implementación en LibreOffice. La implementación es directa. Usamos a\b para la división
por dos y ‘a Mod 2=0’ como prueba de paridad.

[Descargar]

167

Function mcdBinario(u,v) As Long
Dim t As Long,

g As Long, a As Long, b As Long

g=1
a=Abs(u) : b=Abs(v)
While a Mod 2=0 And b Mod 2 = 0
a=a\2
b=b\2
g=2*g
Wend
While a <> 0
a Mod 2 = 0 Then

If

a=a\2
b Mod 2 =0

ElseIf

Then

b=b\2
Else

t=Abs(a-b)/2
If

a >= b Then
a=t

Else b=t
End If
End If
Wend
mcdBinario=g*b
End Function

Prueba de las reglas. La prueba de las reglas es como sigue.

a b
,
. Por el teorema de Bezout, d es la
2 2
mínima combinación lineal positiva de a y b. Si d = ax + by > 0, como a y b son pares, d es par
d
a
b
y podemos dividir a ambos lados por 2,
= x + ≥ d0 por ser d0 es la mínima combinación
2
2
2
lineal positiva de a/2 y b/2. Por tanto d ≥ 2d0 . De manera análoga se prueba que 2d0 ≥ d, con
lo cual se concluye d = 2d0 .

Prueba de la regla 1. Sean d = mcd ( a, b) y d0 = mcd




a
Prueba de la regla 2. Sean d = mcd ( a, b) y
= mcd
, b . Como d|b y b es impar, d es
2
a
k
impar. Si a = kd, como a es par y d impar, tenemos que k es par, entonces = d, por tanto
2
2
d|( a/2) y d|b, es decir, d ≤ d0 . Ahora como d0 |( a/2), a/2 = k0 d0 , es decir a = 2k0 d0 , por tanto
d0 | a, entonces d0 | a y d0 |b, así d0 ≤ d. ∴ d = d0 .
d0




| a − b|
Prueba de la regla 3. Sean d = mcd ( a, b) y
= mcd
, b . Como d| a y d|b entonces
2
d|| a − b|. Como a es impar, d es impar pero | a − b| es par ( a y b son impares), luego si
| a − b|
k
| a − b| = kd, k debe ser par, así que podemos dividir por dos a ambos lados,
= d.
2
2
Por tanto d|(| a − b|/2) y d|b, entonces d ≤ d0 . De manera similar, si b = k0 d0 y | a − b| = 2k00 d0 ,
sustituyendo b en la última ecuación obtenemos que d0 | a. Por tanto d0 ≤ d y entonces d = d0 .
d0



168

ALGORITMOS PARA EL MCD

8.6

Algoritmo LSBGCD (left-shift binary algorithm)

Este algoritmo debe su nombre al hecho de que se hace multiplicación por 2. En representación
binaria el efecto de multiplicar por dos es un desplazamiento (en una posición), de la representación binaria original, hacia la izquierda.
En este algoritmo se encuentra s ∈ N tal que
2s · b ≤ a ≤ b · (2s+1 ) y, como en el algoritmo de Euclides con menor resto, se toma r como el menor
resto entre a − 2s · b y b · 2s+1 − a.
0

De esta manera tenemos en el primer paso a = b · 2s ± r =⇒ mcd ( a, b) = mcd (b, r ); donde s0
es s o s + 1 dependiendo que cual resto sea el menor.
Ejemplo 8.6
Sea a = 55367 y b = 28731. En cada paso tomamos el menor resto r = mín{ a − 2s · b, b ·
2s +1 − a } .
55367
28731
4789
2095
599
301
83
13
3
1

=
=
=
=
=
=
=
=
=
=

28731 · 21 − 2095
2095 · 24 − 4789
2095 · 21 + 599
599 · 22 − 301
301 · 21 − 3
3 · 27 − 83
3 · 25 − 13
3 · 22 + 1
1 · 21 + 1
1 · 20 + 0

=⇒

mcd (55367, 28731)

=
=
=
=
=
=
=
=
=
=

mcd (28731, 2095)
mcd (2095, 4789)
mcd (2095, 599)
mcd (599, 301)
mcd (301, 3)
mcd (3, 83)
mcd (3, 13)
mcd (3, 1)
mcd (1, 1)
mcd (1, 0) = 1

Como se observa, la sucesión de restos no es una sucesión estrictamente decreciente, pero cada
resto ri está en un intervalo [0, di ] y el nuevo resto ri+1 está en en un intervalo [0, di+1 ] ⊂ [0, di ] ,
es decir, cada nuevo ri+1 está en un intervalo cada vez más pequeño.
Esto es así pues si a > b, a = b · 2s1 + r1 =⇒ 0 ≤ r1 < b · 2s1 . Si r1 > 0. En el siguiente paso
tendríamos dos casos posibles,
a.) si b > r1 entonces b = r1 · 2s2 + r2 =⇒ 0 ≤ r2 < r1 · 2s2 < b · 2s1 . Si r2 > 0, la última desigualdad se cumple pues si r1 · 2s2 ≥ b · 2s1 entonces b = r1 · 2s2 + r2 ≥ b · 2s1 + r2 (⇒⇐).
b.) si r1 > b entonces r1 = b · 2s2 + r2 =⇒ 0 ≤ r2 < b · 2s2 < b · 2s1 . Si r2 > 0, la última desigualdad se cumple pues si b · 2s2 ≥ b · 2s1 entonces r1 = b · 2s2 + r2 ≥ b · 2s1 + r2 , por tanto
a = b · 2s1 + r1 ≥ b · 2s1 + b · 2s1 + r2 > b · 2s1 +1 en contradicción con la escogencia de s1 (ver
figura 8.6).
Si llamamos a los nuevos dividendos d1 = b, d2 , d3 , etc., entonces en el n−ésimo resto tendríamos
0 ≤ rn < dn · 2sn < dn−1 · 2sn−1 < ... < b · 2s1

169

Es decir, cada nuevo resto ri está en un intervalo [0, di · 2si ] cada vez más pequeño. Como el
número de intervalos es finito, la sucesión de restos es finita y por tanto en algún momento
rn+1 = 0.
Este algoritmo no es tan rápido como el algoritmo binario, pero su versión extendida si es más
eficiente que la versión extendida de Euclides y la versión extendida del algoritmo binario.

8.6.1

Algoritmo e Implementación.

El algoritmo es como sigue,

Algoritmo 8.3: Algoritmo LSBGCD

6

Datos: a, b ∈ Z+ y a > b
Salida: mcd ( a, b)
while b 6= 0 do
Calcule s tal que b · 2s ≤ a < 2s+1 b;
t = Mín{ a − b · 2s , b · 2s+1 − a};
a = b; b = t;
if a < b then
Intercambiar( a, b)

7

return a

1
2
3
4
5

Implementación en LibreOffice. Necesitamos una función Min(a,b). Aunque podemos usar
la función Mín de Calc (vía createUnoService("com.sun.star.sheet.FunctionAccess")), aquí no
vamos a usar esta posibilidad, más bien usamos una función sencilla.

Function Min (a,b) As Long
Dim m As Long
m=a
If a>b Then m=b
End If
Min= m
End Function

’------ LibreOffice Basic

170

ALGORITMOS PARA EL MCD

Function LSBMCD(u,v) As Long
Dim a As Long, b As Long, t As Long, aux As Long
Dim s As Integer
a=Abs(u) : b=Abs(v)

rem debe ser a>b

While b<>0
s=0
While b*2^s <=a
s=s+1
Wend
s = s-1 : t=Min(a-b*2^s,b*2^(s+1)-a) : a = b : b = t
If a<b Then

aux=a

: a=b : b=aux

End If
Wend
LSBMCD = a
End Function

8.7

Algoritmo Extendido de Euclides.

Como ya habíamos visto, el máximo común divisor mcd ( a, b) se puede expresar como una
combinación lineal de a y b.
Teorema 8.2 (Identidad de Bézout)
Si a, b son dos enteros no ambos cero, existen sn , tn ∈ Z (no únicos) tales que sn a + tn b =
mcd ( a, b) donde sn y tn se definen recursivamente como
sj

= s j−2 − q j−1 s j−1, para j = 2, 3, ..., n

s0

= 1, s1 = 0

tj

= t j−2 − q j−1 t j−1, para j = 2, 3, ..., n

t0

= 1, t1 = 0

donde qk−1 es el cociente en el k−ésimo paso en el algoritmo de Euclides. En particular rk =
rk−2 − rk−1 qk−1 y rk = sk a + tk b.
Como se ve, la implemntación a partir del teorema es directa.

8.8

Inversos multiplicativos en Zm

Si mcd ( a, m) = 1 entonces a tiene inverso x = a−1 , es decir, ax ≡ 1 (mod m). Este inverso es
único módulo m. Entonces, determinar el inverso de a módulo m es equivalente a resolver la
congruencia ax ≡ 1 (mod m). Si mcd ( a, m) = 1, existen s, t ∈ Z tal que sa + tm = 1, con lo que

171

tenemos la solución x = s. En la práctica tomamos a−1 = rem(s, m).

Algoritmo 8.4: Inverso Multiplicativo mod m.
Datos: a ∈ Zm , m > 1
Salida: a−1 si mcd ( a, m) = 1.
1 Calcular s, t tal que sa + tm = mcd ( a, m ) ;
2 if mcd ( a, m ) > 1 then
3
a−1 no existe
4 else
5
return rem(s, m)

Java: Para calcular el inverso multiplicativo (si existe) se puede usar el método modInverse() de
la clase BigInteger. Por ejemplo, el código que sigue calcula e imprime en consola el inverso de
5 módulo 7

BigInteger b = new BigInteger("5");
System.out.println(b.modInverse(new BigInteger("7")));

172

ALGORITMOS PARA EL MCD

Versión actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

9
9.1

NÚMEROS PRIMOS Y
FACTORIZACIÓN.

Introduccción

En estos capítulos vamos a usar LibreOffice Basic para cálculos pequeños y Java para cálculos
un poco más grandes.
Java. Suponemos que tiene Java instalado en su sistema. En Java, cada algoritmo será un método
en la clase Teoria_Numeros.class. Las corridas las hacemos en la consola (terminal). Los algoritmos son implementados como métodos públicos y estáticos en esta clase.
Recordemos que los métodos públicos y estáticos los podemos llamar en la clase y desde
otras clases (que estén en el mismo folder) sin tener que construir un objeto “Teoria_Numeros”.
Todos los programa se pueden descargar aquí
Esta clase importa la clase “BigInteger”. También vamos a implementar y usar una clase BigRational.
La plantilla de esta clase sería algo como,

import java.math.BigInteger;
import java.util.*;
public class Teoria_Numeros
{
static final BigInteger ZERO=new BigInteger("0");
static final BigInteger ONE=new BigInteger("1");
static final BigInteger TWO=new BigInteger("2");
static final BigInteger THREE=new BigInteger("3");
static final BigInteger FOUR=new BigInteger("4");
//--------------------- M\’etodos---------------------------------//
//----------------------------------------------------------------//
public static void main(String[] args)
{
BigInteger a

= new BigInteger("34423453453535424");

BigInteger b

= new BigInteger("-13444354332434344");

173

174

NÚMEROS PRIMOS Y FACTORIZACIÓN.

BigInteger p,q;
BigInteger ls[]

= new BigInteger[3];

System.out.println("\n\n"+ a);
//-------------------------------------------------------------//-------------------------------------------------------------System.out.println("\n\n");
}//fin main
}//fin de la clase

Compilar y correr un prorama Java. Para hacer las cosas super sencillas, abrimos un editor
de textos (Bloc de Notas en Windows o Gedit en Ubuntu, por ejemplo) y pegamos el código
y salvamos el archivo como Teoria_Numeros.java. Digamos que guardamos este archivo en la
carpeta ‘tn/java’. En Linux haríamos las cosas así:
Abrimos una terminal y vamos a la carpeta que tiene el archivo Teoria_Numeros.java, en
mi caso, está en el ‘Escritorio’. Usamos el comando cd para ir a ese directorio,
walter-2@walter2-desktop:~$cd /home/walter-2/Escritorio/tn/java

[Enter]

Compilamos con javac nombre.java
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac Teoria_Numeros.java

[Enter]

“Corremos el programa” con ‘java nombre’ (sin extensión). En nuestro caso imprime el
‘número grande’ a definido en el código.
walter-2@walter2-desktop:~/Escritorio/tn/java$ java Teoria_Numeros

Figura 9.1. Compilando y corriendo la la clase Teoria_Numeros.java

[Enter]

175

9.2

Criba de Eratóstenes.

Para efectos de factorización es necesario tener una lista con los “primeros primos” porque ‘casi
todos los números’ tiene factores primos pequeños. Esto lo hacemos con la criba de Eratóstenes.
Ya habíamos implementado este algoritmo en la sección (2.3). Solo vamos a proceder a la implementación en Java.
Implementación en Java. Vamos a agregar un método a nuestra clase Teoria_Numeros. El
método recibe el número natural n > 2 y devuelve un vector con los números primos ≤ n. Para
colar los números compuestos usamos un arreglo

boolean [] esPrimo = new boolean[(n-3)/2].

Al final llenamos un vector con los primos que quedan.

import java.math.BigInteger;
import java.util.*;
public class Teoria_Numeros
{ static final BigInteger ZERO=new BigInteger("0");
static final BigInteger ONE=new BigInteger("1");
static final BigInteger TWO=new BigInteger("2");
static final BigInteger THREE=new BigInteger("3");
//--------------------- M\’etodos---------------------------------//
public static Vector Primos(int n)
{

Vector
int k

salida = new Vector(1);
= 1;

int max = (n-3)/2;
boolean[]

esPrimo

= new boolean[max+1];

for(int i = 0; i <= max; i++)
esPrimo[i]=true;
for(int i = 0; (2*i+3) <= n/(2*i+3); i++)
{
k = i+1;
if(esPrimo[i])
{
while( 2*k+1<= n/(2*i+3) )
{
esPrimo[((2*k+1)*(2*i+3)-3)/2]=false;
k++;
}
}
}

176

NÚMEROS PRIMOS Y FACTORIZACIÓN.

salida.addElement(new Integer(2));
for(int i = 0; i <=max; i++)
{ if(esPrimo[i])
salida.addElement(new Integer(2*i+3));
}
salida.trimToSize();
return salida;
}//Fin M\’todo Primos
//----------------------------------------------------------------//
public static void main(String[] args)
{
System.out.println("\n\n");
//-------------------------------------------------------------n = 20;

int

Vector primos;
primos = Primos(n);
//Cantidad de primos <= n
System.out.println("Primos <="+ n+": "+primos.size()+"\n");
//Imprimir vector (lista de primos)
for(int p = 1; p < primos.size(); p++)
{
Integer num = (Integer)primos.elementAt(p);
System.out.println(""+(int)num.intValue());
}
//-------------------------------------------------------------System.out.println("\n\n");
}//fin main
}//fin de la clase

Una corrida con n = 20 nos da la salida en terminal que sigue,
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac Teoria_Numeros.java
Note: Teoria_Numeros2.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
walter-2@walter2-desktop:~/Escritorio/tn/java$ java
Primos <=20: 8
3
5
7
11
13
17
19
walter-2@walter2-desktop:~/Escritorio/tn/java$

Teoria_Numeros

177

Uso de la memoria. En teoría, los arreglos pueden tener tamaño máximo Integer.MAX_INT =
231 − 1 = 2 147 483 647 (pensemos también en la posibilidad de un arreglo multidimensional!).
Pero en la práctica, el máximo tamaño del array depende del hardware de la computadora.
El sistema le asigna una cantidad de memoria a cada aplicación; para valores grandes de n
puede pasar que se nos agote la memoria (veremos el mensaje “OutOfMemory Error”). Podemos
asignar una cantidad de memoria apropiada para el programa “cribaEratostenes.java” desde la
línea de comandos, si n es muy grande. Por ejemplo, para calcular los primos menores que
n = 100 000 000, se puede usar la instrucción
walter-2@walter2-desktop:~/Escritorio/tn/java$ java -Xmx1000m -Xms1000m Teoria_Numeros

Esta instrucción asigna al programa una memoria inicial (Xmx) de 1000 MB y una memoria
máxi-ma (Xms) de 1000 MB (siempre y cuando existan tales recursos de memoria en nuestro
sistema).
En todo caso hay que tener en cuenta los siguientes datos

n
Primos ≤ n
10
4
100
25
1 000
168
10 000
1 229
100 000
9 592
1 000 000
78 498
10 000 000
664 579
100 000 000
5 761 455
1 000 000 000
50 847 534
10 000 000 000
455 052 511
100 000 000 000
4 118 054 813
1 000 000 000 000
37 607 912 018
10 000 000 000 000
346 065 536 839

9.3

Primos entre m y n.

Para encontrar todos los primos entre m y n (con 3 ≤ m < n ) procedemos como si estuvieramos
colando primos en la lista {2, 3, ..., n}, solo que esta vez, eliminamos los múltiplos que están entre
√
m y n : Eliminamos los múltiplos de los primos p para los cuales p2 ≤ n (o también p ≤ n ),
que están entre m y n.

Múltiplos de p entre m y n. Para los primos p inferiores a
p entre m y n.
Si m − 1 = pq + r, 0 ≤ r < p =⇒ p(q + 1) ≥ m

√

n, buscamos el primer múltiplo de

178

NÚMEROS PRIMOS Y FACTORIZACIÓN.

Así, los múltiplos de p mayores o iguales a m son
p(q + 1), p(q + 2), p(q + 3), ... con q = quo(m − 1, p)

Ejemplo 9.1
Para encontrar
√ los primos entre m = 10 y n = 30, debemos eliminar los múltiplos de los
primos ≤ 30 ≈ 5. Es decir, los múltiplos de los primos p = 2, 3, 5.

Como 10 − 1 = 2 · 4 + 1, el 2 elimina los números 2(4 + k ) = 8 + 2k, k ≥ 1; es decir
{10, 12, ..., 30}
Como 10 − 1 = 3 · 3 + 0, el 3 elimina los números 3(3 + k ) = 9 + 3k, k ≥ 1; es decir
{12, 15, 18, 21, 24, 27, 30}
Como 10 − 1 = 5 · 1 + 4, el 5 elimina los números 5(1 + k ) = 5 + 5k, k ≥ 1; es decir
{10, 15, 20, 25.}
Finalmente nos quedan los primos 11, 13, 17, 19, 23, 29.

9.3.0.1 Algoritmo e implementación Como antes, solo consideramos los impares entre m y
n. Recordemos que si x ∈ R y si n ≤ x < n + 1 con n ∈ Z, entonces la parte entera de x es n .
Se escribe JxK = n.
Sean n, m números naturales tales que 3 ≤ m < n. Sea A el conjunto de números impares entre
m y n.
El primer impar de A es 2 ·

r

El último impar de A es 2 ·

q n −3 y

m +1−3
2

2

z

+3

+3

n
r
z
q 3 yo
∴ El conjunto de impares entre m y n es A = 2 · i + 3 : i = m+21−3 , · · · , n−
.
2
Si ponemos min = quo(m + 1 − 3, 2) y max = quo(n − 3, 2), los impares entre m y n son los
elementos del conjunto {2 · i + 3 : i = min, ..., max }
Como antes, usamos un arreglo booleano esPrimo(i) con i = min, ..., max. esPrimo(i) representa
al número 2 · i + 3.

179

Ejemplo 9.2

Si m = 11 y 20, J(m + 1 − 3)/2K = 4 y J(n − 3)/2K = 8. Luego, el,primer impar es
2 · 4 + 3 = 11 y el último impar es 2 · 8 + 3 = 19.

√
Para aplicar el colado necesitamos los primos ≤ n. Esta lista de primos la obtenemos con la
función Eratostenes(isqrt(n)). Aquí hacemos uso del método BIsqrt(n)donde n es BigInteger
(Ver Apéndice ??). Para cada primo pi en la lista,

a.) si m ≤ p2i , tachamos los múltiplos impares de pi como antes,

1
2
3
4
5

if m ≤ p2i then
k = ( pi − 1)/2 ;
while (2k + 1) pi ≤ n do
esPrimo[((2k + 1) pi − 3)/2] =False;
k = k + 1;

Note que si k = ( pi − 1)/2 entonces (2k + 1) pi = p2i
b.) si p2i < m, tachamos desde el primer múltiplo impar de pi que supere m :
Los múltiplos de pi que superan m son pi (q + k) con q = quo(m − 1, p). De esta lista solo
nos interesan los múltiplos impares. Esto requiere un pequeño análisis aritmético.

Como pi es impar, pi (q + k) es impar solo si q + k es impar. Poniendo q2 = rem(q, 2)
entonces (2k + 1 − q2 + q) es impar si k = q2 , q2 + 1, ... . En efecto,


2k + 1 − q2 + q =

2k + 1 + q
2k + q

si
si

q es par. Aquí k = q2 = 0, 1, ...
q es impar. Aquí k = q2 = 1, 2, ...

Luego, los múltiplos impares de pi que superan m son los elementos del conjunto

{(2k + 1 − q2 + q) · pi : q2 = rem(q, 2) y k = q2 , q2 + 1, ...}

La manera de tachar los múltiplos impares de pi es

180

1
2
3
4
5
6

NÚMEROS PRIMOS Y FACTORIZACIÓN.

if p2i < m then
q = (m − 1)/p; q2 = rem(q, 2); k = q2 ; mp = (2k + 1 − q2 + q) · pi ;
while mp ≤ n do
esPrimo[(mp − 3)/2] =False;
k = k + 1;
mp = (2k + 1 − q2 + q) · pi

Algoritmo 9.1: Colado de primos entre m y n.
Datos: n, m ∈ N con m < n.
Salida: Primos entre m y n
√
1 Primo() = una lista de primos ≤
n;
2 min = ( m + 1 − 3) /2; max = ( n − 3) /2 ;
3 esPrimo [i ], i = min, ..., max ;
4 for j = min, ..., max do
5
esPrimo [ j] =True;
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22

23
24
25
26

np = cantidad de primos en la lista Primos;
Suponemos Primo(0) = 2;
for i = 1, 2, ..., np do
if m ≤ p2i then
k = ( pi − 1)/2 ;
while (2k + 1) pi ≤ n do
esPrimo[((2k + 1) pi − 3)/2] =False;
k = k + 1;
if p2i < m then
q = (m − 1)/p ;
q2 = rem(q, 2) ;
k = q2 ;
mp = (2k + 1 − q2 + q) · pi ;
while mp ≤ n do
esPrimo[(mp − 3)/2] =False;
k = k + 1;
mp = (2k + 1 − q2 + q) · pi
Imprimir ;
for j = min, ..., max do
if esPrimo [ j] =True then
Imprima 2 · ( j + min) + 3

Ahora podemos armar el algoritmo completo.
Implementación en Java. Vamos a agregar el método Primos(m, n) a nuestra clase “Teoria_Numeros”.
El método recibe dos naturales 0 ≤ m < n y devuelve un vector con los números primos entre
m y n.

181

Como antes, usamos un arreglo booleano esPrimo(i) con i = 0, ..., max − min + 1 donde min =
(m + 1 − 3)/2 y max = (n − 3)/2.

√
Si p es primo y p ≤ n, entonces si s · p es un múltiplo impar de p entre m y n, debemos
poner esPrimo((s*p-3)/2-min)=false
Notemos que, esPrimo(i) representa al impar 2 · (i + min) + 3.
public class Teoria_Numeros
{
...
//--------------------- M\’etodos---------------------------------//
...
public static Vector Primos(int m, int n)
{
Vector

salida = new Vector(1);

int k,mip,p,q,q2;
int min = (m+1-3)/2;
int max = (n-3)/2;
int total = max-min+1;
int sqrtn = BIsqrt(new BigInteger(""+n)).intValue();
boolean[]

esPrimo

= new boolean[max+1];

Vector primos;
primos = Primos(sqrtn);
if(0<= m && m < 3)
return Primos(n);
for(int i = 0; i < total; i++)
esPrimo[i]=true;
//primos(0)=2, inicia en primos(1)=3
for(int i = 1; i< primos.size() ; i++)
{ p =((Integer)primos.elementAt(i)).intValue();

182

NÚMEROS PRIMOS Y FACTORIZACIÓN.

if(p*p<m)
{ q=(m-1)/p;
q2=q%2;
k=q2;
mip=(2*k+1-q2+q)*p;
while(mip<=n)
{
esPrimo[(mip-3)/2-min]=false;
k= k+1;
mip=(2*k+1-q2+q)*p;
}
}
}
//Imprimir
for(int i = 0; i < total; i++)
if(esPrimo[i])
salida.addElement(new Integer(2*(i+min)+3));
salida.trimToSize();
return salida;
}// Primos n,m
public static BigInteger BIsqrt(BigInteger n)
{

BigInteger DOS

= new BigInteger("2");

BigInteger xkm1 = n.divide(DOS);
BigInteger xk

= n;

if(n.compareTo(BigInteger.ONE)< 0)
return xkm1=n;
while(xkm1.compareTo(xk)<0)
{
xk=xkm1;
xkm1=xkm1.add(n.divide(xkm1));
xkm1=xkm1.divide(DOS);
}
return xkm1;
}//BIsqrt
//----------------------------------------------------------------//
public static void main(String[] args)
{
System.out.println("\n\n");
//-------------------------------------------------------------//primos entre m,n
int m

= 20;

int n = 50;
Vector primosmn;
primosmn = Primos(m,n);
for(int j = 0; j < primosmn.size(); j++)
{

Integer num = (Integer)primosmn.elementAt(j);
System.out.println(""+(int)num.intValue());

}
//-------------------------------------------------------------System.out.println("\n\n");
}//fin main
}//fin de la clase

183

La corrida, usando n = 20 y m = 50, entrega el siguiente resultado,
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac
walter-2@walter2-desktop:~/Escritorio/tn/java$ java

Teoria_Numeros.java
Teoria_Numeros

23
29
31
37
41
43
47
walter-2@walter2-desktop:~/Escritorio/tn/java$

9.4

Factorización por ensayo y error.

El método más sencillo de factorización (y muy útil) es el método de factorización por ensayo y
error (FEE). Este método va probando con los posibles divisores de n hasta encontrar un factor
de este número.
En vez de probar con todos los posibles divisores de n (es decir, en vez de usar fuerza bruta)
podemos hacer algunos refinamientos para lograr un algoritmo más eficiente en el sentido de
reducir las pruebas a un conjunto de números más pequeño, en el que se encuentren los divisores
pequeños de n.

9.4.1

Probando con una progresión aritmética.

Como estamos buscando factores pequeños de n, podemos usar el teorema,

Teorema 9.1
Si n ∈ Z+ admite la factorización n = ab, con a, b ∈ Z+ entonces a ≤

√

n o b≤

√

n.

Del teorema anterior se puede deducir que

• Si n no tiene factores d con 1 < d ≤

√

n, entonces n es primo.

√
• Al menos uno de los factores de n es menor que
n (no necesariamente todos). Por ejem√
plo 14 = 2 · 7 solo tiene un factor menor que 14 ≈ 3.74166).

De acuerdo al teorema fundamental de la aritmética, cualquier número natural > 1 factoriza, de
manera única (excepto por el orden) como producto de primos. Esto nos dice que la estrategia

184

NÚMEROS PRIMOS Y FACTORIZACIÓN.

√
óptima de factorización sería probar con los primos menores que n. El problema es que si n
es muy grande , el cálculo de los primos de prueba duraría siglos (sin considerar los problemas
de almacenar estos números).
Recientemente (2005) se factorizó un número de 200 cifras9 (RSA-200). Se tardó cerca de 18 meses
en completar la factorización con un esfuerzo computacional equivalente a 53 años de trabajo de
un CPU 2.2 GHz Opteron.

9.4.2

Algoritmo.

Identificar si un número es primo es generalmente fácil, pero factorizar un número (grande)
arbitrario no es sencillo. El método de factorización de un número N probando con divisores
primos (“trial division”) consiste en probar dividir N con primos pequeños. Para esto se debe
previamente almacenar una tabla suficientemente grande de números primos o generar la tabla
cada vez. Como ya vimos en la criba de Eratóstenes, esta manera de proceder trae consigo problemas de memoria. En realidad es más ventajoso proceder de otra manera.

Para hacer la pruebas de divisibilidad usamos los enteros 2, 3 y la sucesión 6k ± 1, k =
1, 2, ... .
Esta elección cubre todos los primos e incluye divisiones por algunos números compuestos
(25,35,...) pero la implementación es sencilla y el programa suficientemente rápido (para
números no muy grandes) que vale la pena permitirse estas divisiones inútiles.

En general, debemos decidir un límite G en la búsqueda de divisores. Si se divide únicamente por divisores primos ≤ G, se harían π ( G ) ≈ G/ ln G divisiones. Si se divide por 2 ,
G/3
= 3/ ln G
3 y 6k ± 1 se harían aproximadamente G/3 divisiones10 de las cuales
G/ ln G
6
son divisiones útiles. Si G = 10 , tendríamos ≈ 22% divisiones útiles. En este caso, un
ciclo probando divisiones por primos únicamente es ≈ 1/0.22 = 4.6 veces más lento11 .
Cuando se juzga la rapidez de un programa se toma en cuenta el tiempo de corrida en el
peor caso o se toma en cuenta el tiempo promedio de corrida (costo de corrida del programa
si se aplica a muchos números). Como ya sabemos (por el Teorema de Mertens) hay un
porcentaje muy pequeño de números impares sin divisores ≤ G, así que en promedio,
nuestra implementación terminará bastante antes de alcanzar el límite G (el “peor caso”
no es muy frecuente) por lo que tendremos un programa con un comportamiento deseable.

Detalles de la implementación.
9 Se

trata del caso más complicado, un número que factoriza como producto de dos primos (casi) del mismo tamaño.
Pues los números naturales ( ≤ G ) son de la forma 6k + m con m ∈ {0, 1, ..., 5} y solo estamos considerando m = 1, 5,
es decir una tercera parte.
11 Aún si se almacena previamente una tabla de primos en forma compacta, esto consume tiempo [9]
10

185

• Para la implementación necesitamos saber cómo generar los enteros de la forma 6k ± 1.
Alternando el −1 y el 1 obtenemos la sucesión

5, 7, 11, 13, 17, 19, ...
que iniciando en 5, se obtiene alternando los sumandos 2 y 4. Formalmente, si mk = 6k − 1
y si sk = 6k + 1 entonces, podemos poner la sucesión como

7, 11, 13, ..., mk , sk , mk+1 , sk+1 , ...
Ahora, notemos que sk = mk + 2 y que mk+1 = sk + 4 = mk + 6. La sucesión es
7, 11, 13, ..., mk , mk + 2, mk + 6, mk+1 + 2, mk+1 + 6, ...
En el programa debemos probar si el número es divisible por 2 , por 3 y ejecutamos el ciclo
p = 5;
While

p ≤ G Do {
Probar divisibilidad por p
Probar divisibilidad por p + 2
p= p+6}

√
N }.
• En cada paso debemos verificar si el divisor de prueba p alcanzó el límite Mín
{
G,
√
Si se quiere evitar el cálculo de la raíz, se puede usar el hecho de que si p > N entonces
p > N/p.

Algoritmo 9.2: Factorización por Ensayo y Error.
√
Datos: N ∈ N, G ≤ N
Salida: Un factor p ≤ G de N si hubiera.
1 p = 5;
2 if N es divisible por 2 o 3 then
3
Imprimir factor;
4 else
5
while p ≤ G do
6
if N es divisible por p o p + 2 then
7
Imprimir factor;
8
break;
9
end
10
p= p+6
11
end
12 end
Implementación en Java. El programa que sigue es una clase independiente. Si se quiere, se
pueden tomar los métodos y agregarlo a la clase Teoria_Numeros.java

186

NÚMEROS PRIMOS Y FACTORIZACIÓN.

Creamos una clase que
√ busca factores primos de un número N hasta un límite G. En el programa, G = Mín { N, G }.
Usamos un método reducir(N,p) que verifica si p es factor, si es así, continua dividiendo por p
hasta que el residuo no sea cero. Retorna la parte de N que no ha sido factorizada.
El método Factzar_Ensayo_Error(N, G) llama al método reducir(N,p) para cada p = 2, 3, 7, 11, 13, ....
hasta que se alcanza el límite G.

import java.util.Vector;
import java.math.BigInteger;
public class Ensayo_Error
{

private Vector

salida = new Vector(1);

static BigInteger Ge

= new BigInteger("10000000");//10^7

BigInteger

UNO

= new BigInteger("1");

BigInteger

DOS

= new BigInteger("2");

BigInteger

TRES

= new BigInteger("3");

BigInteger

SEIS

= new BigInteger("4");

BigInteger

Nf;

pos
= 1; //posici\’on del exponente del factor
_
public Ensayo Error(){} //Hay que crear el objeto
int

public BigInteger reducir(BigInteger Ne, BigInteger p)
{

int exp = 0, posAct = pos;
BigInteger residuo;
residuo =

Ne.mod(p);

if(residuo.compareTo(BigInteger.ZERO)==0)
{ salida.addElement(p); //p es objeto BigInteger
salida.addElement(BigInteger.ONE); //exponente
pos = pos+2; //posici\’on del siguiente exponente (si hubiera)
}
while(residuo.compareTo(BigInteger.ZERO)==0)
{Ne

=

residuo =

Ne.divide(p); // Ne = Ne/p
Ne.mod(p);

exp=exp+1;
salida.set(posAct, new BigInteger(""+exp)); //p es objeto BigInteger
}
return Ne;
}//

187

public Vector Factzar_Ensayo_Error(BigInteger Ne, BigInteger limG)
{
BigInteger p

= new BigInteger("5");

Nf = Ne;
Nf = reducir(Nf, DOS);
Nf = reducir(Nf, TRES);
while(p.compareTo(limG)<=0)
{
Nf= reducir(Nf, p);

//dividir por p

Nf= reducir(Nf, p.add(DOS)); //dividir por p+2
p = p.add(SEIS); //p=p+6
}
if(Nf.compareTo(BigInteger.ONE)>0)
{
salida.addElement(Nf); //p es objeto BigInteger
salida.addElement(BigInteger.ONE); //exponente
}
return salida;
}
public static void main(String[] args)
{
BigInteger limG;
BigInteger Nduro

= new BigInteger("2388005888439481");

BigInteger N

= new BigInteger("27633027771706698949");
= new Ensayo_Error();

Ensayo_Error Obj
Vector

factores;

factores = Obj.Factzar_Ensayo_Error(N); //factoriza
//Imprimir vector de factores primos
System.out.println("\n\n");
System.out.println("N = "+N+"\n\n");
System.out.println("Hay " +factores.size()/2+" factores primos <= " + Ge+"\n\n");
System.out.println("N = "+Obj.print(factores)+"\n\n");
System.out.println("\n\n");
}
}

Al ejecutar este programa en terminal con N = 367367653565289976655797, la salida es
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac Ensayo_Error.java
walter-2@walter2-desktop:~/Escritorio/tn/java$ java Ensayo_Error
N = 27633027771706698949

188

NÚMEROS PRIMOS Y FACTORIZACIÓN.

Hay 3 factores primos <= 10000000
N = 37^2 * 3671^3 * 408011^1
walter-2@walter2-desktop:~/Escritorio/tn/java$

Implementación en LibreOffice. Se puede hacer una implemetación el LibreOffice, pero por
supuesto, como no disponemos de una clase ‘BigInteger’, solo se pueden factorizar números no
más allá de diez dígitos.

[Descargar]

REM

***** BASIC
Option Explicit

*****

Sub Main
Dim N, G, k
Dim factores As String
Dim factorizacion() As Long
N =

Celda("A4").Value

G =

Celda("B4").Value

G = Sqr(N)
If N < 0 Then
MsgBox ("Debe introducir un n\’umero natural")
Else
factorizacion() = FactorizacionEE(N, G)
If UBound(factorizacion) = 0 Then
Celda("C4").setString("")
Celda("A6").setString("Este n\’umero es primo")
Else

189

For k = 0 To UBound(factorizacion)
If k = 0 Then
factores = Trim(str(factorizacion(k)))
Else
factores = factores +"."+Trim(Str(factorizacion(k)))
End If
Next
Celda("A6").setString(" ")
Celda("C4").setString(factores)
End If
End If
End Sub
Function FactorizacionEE(N, g)
Dim salir As Boolean
Dim factor As Long
Dim factores() As Long
Dim p As Long, i As Long
Dim j As Long, prueba
Dim exp As Long, k
i = 0
j = 0
ReDim factores(i)
p = 5
Do
If N Mod 2 = 0 Then
factor = 2
N = N / 2
ElseIf N Mod 3 = 0 Then
factor = 3
N = N / 3
Else
While salir = False
If N Mod p = 0 Then
factor = p
N = N / p
salir = True
Else
p = p + 2
End If
If salir = False And N Mod p = 0 Then
factor = p
N = N / p
salir = True
Else
p = p + 4
End If
If salir = False And p > g Then
salir = True
factor = 0
End If
Wend
End If

190

NÚMEROS PRIMOS Y FACTORIZACIÓN.

If factor = 0 Then
ReDim Preserve factores(i)
factores(i) = N
i = i + 1
Exit Do
Else
If i - 1 < 0 Then
ReDim Preserve factores(i)
factores(i) = factor
i = i + 1
Else
ReDim Preserve factores(i)
factores(i) = factor
i = i + 1
End If
p = 5
salir = False
End If
Loop Until N = 1
FactorizacionEE = factores
End Function

9.5

Método de factorización “rho” de Pollard.

En el método de factorización
por ensayo y error, en su versión más cruda, probamos con todos
√
los números entre 2 y N para hallar un factor de N. Si no lo hallamos, N es primo. Con el
método de factorización “rho” de Pollard podríamos encontrar factores más rápido de tal manera que los factores pequeños que van quedando se pueden factorizar con el método de ensayo y
error.

√
En el método “rho” de Pollard, en vez de hacer estos ≈ √N pasos (en el peor caso), vamos a
escoger una lista aleatoria de números, más pequeña que N, y probar con ellos.
A menudo se construyen sucesiones seudo-aleatorias x0 , x1 , x2 , ... usando una iteración de la forma
xi+1 = f ( xi ) (mod N ), con x0 = random(0, N − 1). Entonces { x0 , x1 , ...} ⊆ Z N . Por lo tanto los
xi ’s se empiezan a repetir en algún momento.
La idea es esta: Supongamos que ya calculamos la sucesión x0 , x1 , x2 , ... y que es “suficientemente
aleatoria”. Si p es un factor primo de N y si



xi
xi

≡ x j (mod p)
≡
/ x j (mod N )

191

entonces, como xi − x j = kp, resulta que MCD( xi − x j , N ) es un factor no trivial de N.
Claro, no conocemos p, pero conocemos los xi ’s, así que podemos revelar la existencia de p con
el cálculo del MCD: En la práctica se requiere comparar, de manera eficiente, los xi con los x j
hasta revelar la presencia del factor p vía el cálculo del MCD( xi − x j , N ).


 xi

≡ x j (mod p)



≡
/ x j (mod N )

xi

=⇒ mcd ( xi − x j , N ) es factor no trivial de N

Si x0 , x1 , x2 , ... es “suficientemente aleatoria”, hay una probabilidad muy alta de que encontremos
pronto una “repetición” del tipo xi ≡ x j (mod p) antes de que esta repetición ocurra (mod N).

Antes de entrar en los detalles del algoritmo y su eficiencia, veamos un ejemplo.

Ejemplo 9.3
Sea N = 1387. Para crear una sucesión “seudoaleatoria” usamos f ( x ) = x2 − 1 y x1 = 2.
Luego,

x0
x i +1

= 2
= xi2 − 1 (mod N )

es decir,

{ x0 , x1 , x2 , ...} =

{2, 3, 8, 63, 1194,
1186, 177, 814, 996, 310, 396, 84, 120, 529, 1053, 595, 339,
1186, 177, 814, 996, 310, 396, 84, 120, 529, 1053, 595, 339, ...}

Luego, “por inspección” logramos ver que 1186 ≡
/ 8 (mod N ) y luego usamos el detector
de factores: mcd (1186 − 8, N ) = 19. Y efectivamente, 19 es un factor de 1387. En este
caso detectamos directamente un factor primo de N.

Por supuesto, no se trata de comparar todos los xi ’s con los x j ’s para j < i. El método de factorización “rho” de Pollard, en la variante de R. Brent, usa un algoritmo para detectar rápidamente
un ciclo en una sucesión ([28]) y hacer solo unas cuantas comparaciones. Es decir, queremos detectar rápidamente xi ≡ x j (mod p) usando la sucesión xi+1 = f ( xi ) (mod N ) (que alcanza un
ciclo un poco más tarde) y el test mcd ( xi − x j , N ).

192

NÚMEROS PRIMOS Y FACTORIZACIÓN.

√
Típicamente necesitamos unas O( p) operaciones. El argumento es heurístico. Básicamente lo
que se muestra es que, como en el problema del cumpleaños, dos números xi y x j , tomados de
manera aleatoria, son congruentes módulo p con probabilidad mayor que 1/2, después de que
√
hayan sido seleccionados unos 1.177 p números.
√
Aunque la sucesión xi+1 = f ( xi ) (mod N ) cae en un ciclo en unas O( N ) √operaciones, es muy
√
probable que detectemos xi ≡ x j (mod p) en unos O( p) pasos. Si p ≈ N entonces encontraríamos un factor de N en unos O( N 1/4 ) pasos. Esto nos dice que el algoritmo “rho” de
Pollard factoriza N 2 con el mismo esfuerzo computacional con el que el método de ensayo y
error factoriza N.

9.5.1

Algoritmo e implementación.

La algoritmo original de R. Brent compara x2k −1 con x j , donde 2k+1 − 2k−1 ≤ j ≤ 2k+1 − 1. Los
detalles de cómo esta manera de proceder detectan rápidamente un ciclo en una sucesión no se
ven aquí pero pueden encontrarse en [28] y [25].

Ejemplo 9.4
Sean N = 3968039, f ( x ) = x2 − 1 y x0 = 2. Luego,
mcd ( x1 − x3 , N )
mcd ( x3 − x6 , N )
mcd ( x3 − x7 , N )
..
.
mcd ( x63 − x96 , N )
mcd ( x63 − x97 , N )
mcd ( x63 − x98 , N )
mcd ( x63 − x99 , N )
mcd ( x63 − x100 , N )
mcd ( x63 − x101 , N )
mcd ( x63 − x102 , N )
mcd ( x63 − x103 , N )

=
=
=
..
.
=
=
=
=
=
=
=
=

1
1
1
..
.
1
1
1
1
1
1
1
1987

N = 1987 · 1997.

El algoritmo que vamos a describir aquí es otra variante del algoritmo de Brent ([29]) que es más
sencillo de implementar.
Después de hacer la implemetación vamos a ver un refinameinto muy sencillo.
Se calcula MCD( xi − x j , N ) para i = 0, 1, 3, 7, 15, ... y j = i + 1, ..., 2i + 1 hasta que, o xi = x j (mod N )
(en este caso se debe escoger una f diferente o un x0 diferente) o que un factor no trivial de N
sea encontrado.

193

Observe que si i = 2k − 1 entonces j = 2i + 1 = 2k+1 − 1, es decir el último j será el ‘nuevo’ i.
Por tanto, en el algoritmo actualizamos xi al final del For, haciendo la asignación xi = x2i+1 = x j .

Algoritmo 9.3: Método rho de Pollard (variante de R. Brent)
Datos: N ∈ N, f , x0
Salida: Un factor p de N o mensaje de falla.
1 salir=false;
2 k = 0, x0 = Random(2, N − 1);
3 x i = x0 ;
4 while salir=False do
5
i = 2k − 1 ;
6
for j = i + 1, i + 2, ..., 2i + 1 do
x j = f ( x0 ) (mod N ) ;
7
if xi = x j then
8
9
salir=True;
10
Imprimir “El método falló. Reintentar cambiando f o x0 ”;
11
Exit For;

16

g = mcd ( xi − x j , N ) ;
if 1 < g < N then
salir=True;
Imprimir N = N/g · g ;
Exit For;

17

x0 = x j ;

12
13
14
15

18
19

xi = x j ;
k + +;

Implementación en Java. La implementación sigue paso a paso el algoritmo.De nuevo aquí
hacemos un programa independiente. Naturalmente, se puede incluir como un conjunto de
métodos en Teoria_Numeros.java
La corrida de prueba se hace con un número relativamente grande, claro no de varios cientos de
dígitos... para eso se necesita otros métodos.

194

NÚMEROS PRIMOS Y FACTORIZACIÓN.

import java.math.BigInteger;
public class rhoPollard
{
rhoPollard(){}
public BigInteger f(BigInteger x)
{
return x.multiply(x).add(BigInteger.ONE);//x^2+1
}
void FactorPollard(BigInteger N)

public
{

int i, k;
BigInteger xi,xj;
BigInteger g

= BigInteger.ONE;

BigInteger x0

= new BigInteger(""+2);;

boolean salir

= false;

k = 0;
xi= x0;
xj= x0;
while(salir==false)
{ i=(int)(Math.pow(2,k)-1);
for(int j=i+1; j<=2*i+1; j++)
{
xj=f(x0).mod(N);
if(xi.compareTo(xj)==0)//si son iguales
{salir=true;
System.out.print("Fallo"+"\n\n");
break;
}
g= N.gcd(xi.subtract(xj));
if(g.compareTo(BigInteger.ONE)==1 && g.compareTo(N)==-1)//1<g<N
{salir=true;
System.out.print("Factor = "+g+"\n\n");
break;
}
x0=xj;
}
xi=xj;
k++;
}
System.out.print(N+" =

"+g+" . "+N.divide(g)+"\n\n");

}
public static void main(String[] args)
{
System.out.print("\n\n");
rhoPollard obj = new rhoPollard();
BigInteger N = new BigInteger("10001449242860005111762859");
obj.FactorPollard(N);
System.out.print("\n\n");
}
}//

EJERCICIOS

195

El resultado de la corrida es,
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac rhoPollard.java
walter-2@walter2-desktop:~/Escritorio/tn/java$ java rhoPollard

Factor = 7368787
10001449242860005111762859 =

7368787 . 1357272132151466057

walter-2@walter2-desktop:~/Escritorio/tn/java$

Refinamiento. En general, hay muchos casos en los que MCD( xi − x j , N ) = 1. En vez de calcular todos estos MCD(z1 , N ), MCD(z2 , N ), ..., calculamos unos pocos MCD( Qk , N ), donde Qk =
∏kj=1 z j (mod N ). Brent sugiere escoger k entre ln N y N 1/4 pero lejos de cualquiera de los dos
extremos ([28]). Riesel ([9]) sugiere tomar k como un múltiplo de 100.

Ejemplo 9.5
Sean N = 3968039, f ( x ) = x2 − 1 y x0 = 2. Luego, tomando k = 30
30

Q30 = ∏ z j (mod N ) = 3105033,

mcd ( Q30 , N )

=

∏ z j (mod N ) = 782878,

mcd ( Q60 , N )

= 1987

1

j =1
60

Q60 =

j=31

EJERCICIOS
9.1

Implementar una variante con el producto Qk = ∏kj=1 z j (mod N ).

9.6

Pruebas de Primalidad.

Para decidir si un número n pequeño es primo, podemos usar el método de ensayo y error para
√
verificar que no tiene divisores primos inferiores a n.
Para un número un poco más grande, la estrategia usual es primero verificar si tiene divisores
primos pequeños, sino se usa el test para seudoprimos fuertes de Miller-Rabin con unas pocas
bases pi (con pi primo) y usualmente se combina con el test de Lucas. Esta manera de proceder
decide de manera correcta si un número es primo o no, hasta cierta cota 10 M . Es decir, la combinación de algoritmos decide de manera correcta si n < 10 M Sino, decide de manera correcta

196

NÚMEROS PRIMOS Y FACTORIZACIÓN.

solamente con una alta probabilidad y cabe la (remota) posibilidad de declarar un número compuesto como primo.
Aquí solo vamos a tratar rápidamente la prueba de Miller-Rabin.

9.7

Prueba de primalidad de Miller-Rabin.

Iniciamos con test de primalidad de Fermat, por razones históricas. Esta prueba se basa el el
teorema,

Teorema 9.2 (Fermat)
Sea p primo. Si MCD( a, p) = 1 entonces a p−1 ≡ 1 (mod p).

Este teorema nos dice que si n es primo y a es un entero tal que 1 ≤ a ≤ n − 1, entonces
an−1 ≡ 1 (mod n).
Por tanto, n es compuesto si encontramos 1 ≤ a ≤ n − 1 tal que an−1 ≡
/ 1 (mod n).

Definición 9.1
Sea n compuesto. Un entero 1 ≤ a ≤ n − 1 para el que an−1 ≡
/ 1 (mod n), se llama “testigo de
Fermat” para n.

Un testigo de Fermat para n sería un testigo de no-primalidad. De manera similar, un número
1 ≤ a ≤ n − 1 para el que an−1 ≡ 1 (mod n), apoya la posibilidad de que n sea primo,

Definición 9.2
Sea n un entero compuesto y sea a un entero para el cual 1 ≤ a ≤ n − 1 y an−1 ≡ 1 (mod n).
Entonces se dice que n es un seudoprimo respecto a la base a. Al entero a se le llama un
“embaucador de Fermat” para n.

Por ejemplo, n = 645 = 3 · 5 · 43 es un seudoprimo en base 2 pues 2n−1 ≡ 1 (mod n).
Es curioso que los seudoprimos en base 2 sean muy escasos. Por ejemplo, hay 882 206 716 primos inferiores a 2 × 1010 y solo hay 19685 seudoprimos en base 2 inferiores a 2 × 1010 . Esto

EJERCICIOS

197

nos dice que la base 2 parece ser muy poco “embaucadora” en el sentido de que si tomamos un
número grande n de manera aleatoria y si verificamos que 2n−1 ≡ 1 (mod n), entonces es muy
probable que n sea primo. También los seudoprimos en base 3 son muy escasos y es altamente
improbable que si tomamos un número grande n de manera aleatoria, este sea compuesto y que
a la vez sea simultáneamente seudoprimo en base 2 y base 3.
Es decir, si un número n pasa los dos test 2n−1 ≡ 1 (mod n) y 3n−1 ≡ 1 (mod n); es muy probable que sea primo.
Sin embargo, hay enteros n compuestos para los cuales an−1 ≡ 1 (mod n) para todo a que
cumpla MCD( a, n) = 1. A estos enteros se les llama números de Carmichael.
Por ejemplo, n = 561 = 3 · 11 · 17 es número de Carmichael. Aunque este conjunto de números
es infinito, son más bien raros (poco densos). En los primeros 100 000 000 números naturales hay
2051 seudoprimos en base 2 y solo 252 números de Carmichael.
Nuestra situación es esta: Es poco probable que un número compuesto pase varios test de “primalidad” an−1 ≡ 1 (mod n) excepto los números de Carmichael, que son compuestos y pasan
todos estos test.
Hay otro test, llamado “test fuerte de seudo-primalidad en base a” en el cual los números de
Carmichael no pasan. Además, si tomamos k números de manera aleatoria a1 , a2 , ..., ak y si n
pasa este test en cada una de las bases ai , podemos decir que la probabilidad de que nos equivoquemos al declarar n como primo es menor que 1/4k . Por ejemplo, si k = 200 la probabilidad
de que nos equivoquemos es < 10−120

Teorema 9.3
Sea n un primo impar y sea n − 1 = 2s r con r impar. Sea a un entero tal que MCD( a, n) = 1.
j
Entonces, o ar ≡ 1(mod n) o a2 r ≡ −1(mod n) para algún j, 0 ≤ j ≤ s − 1.

Con base en el teorema anterior, tenemos

Definición 9.3
Sea n impar y compuesto y sea n − 1 = 2s r con r impar. Sea 1 ≤ a ≤ n − 1.
j

a.) Si ar ≡/1(mod n) y si a2 r ≡/ − 1(mod n) para 0 ≤ j ≤ s − 1, entonces a es llamado un
testigo fuerte (de no-primalidad) de n.
j

b.) Si ar ≡ 1( mod n) y si a2 r ≡ −1(mod n) para 0 ≤ j ≤ s − 1, entonces n se dice un seudoprimo fuerte en la base a. Al entero a se le llama “embaucador fuerte”.

Así, un seudoprimo fuerte n en base a es un número que actúa como un primo en el sentido
del teorema 9.3.

198

NÚMEROS PRIMOS Y FACTORIZACIÓN.

Teorema 9.4 (Rabin)
Si n es un entero compuesto, a lo sumo
cadores fuertes de n.

1
de todos los números a, 1 ≤ a ≤ n − 1, son embau4

Supongamos que tenemos un número compuesto n. Tomamos k números { a1 , a2 , ..., ak } de manera aleatoria y aplicamos el test fuerte de seudo-primalidad a n con cada uno de de estas bases
ai . Entonces, hay menos que un chance en cuatro de que a1 no sea testigo de no-primalidad de
n, y menos que un chance en cuatro de que a2 no sea testigo de no-primalidad de n, etc. Si
n es primo, pasa el test para cualquier a < n. Si cada ai falla en probar que n es compuesto,
1
entonces la probabilidad de equivocarnos al decir que n es primo es inferior a k .
4
9.7.1

Algoritmo e implementación.

Algoritmo 9.4: Miller-Rabin
Datos: n ≥ 3 y un parámetro de seguridad t ≥ 1.
Salida: “n es primo” o “ n es compuesto”.
s
1 Calcule r y s tal que n − 1 = 2 r, r impar;
2 for i = 1, 2, ..., t do
3
a = Random(2, n − 2);
4
y = ar (mod n);
5
if y 6= 1 y y 6= n − 1 then
6
j = 1;
7
while j ≤ s − 1 y y 6= n − 1 do
8
y = y2 (mod n);
9
if y = 1 then
10
return “Compuesto”;
11
12
13

14

j = j + 1;
if y 6= n − 1 then
return “Compuesto”;
return “Primo”;

Todo primo impar n − 1 se puede expresar como n − 1 = 2 j r, con r impar.
El algoritmo 9.4 verifica si en cada base a se satisface la definición 9.3. En la línea 9, si y = 1,
j
j −1
/ ± 1 (mod n) entonces n es
entonces a2 r ≡ 1 (mod n). Puesto que este es el caso cuando a2 r ≡
compuesto. Esto es así pues si x2 ≡ y2 (mod n) pero si x ≡
/ ± y (mod n), entonces MCD( x − y, n)
es un factor no trivial de n. En la línea 12, si y 6= n − 1, entonces a es un testigo fuerte de n.
Si el algoritmo 9.4 declara compuesto a n entonces n es definitivamente compuesto, por el
teorema 9.3. Si n es primo, es declarado primo. Si n es compuesto, la probabilidad de que el
algoritmo lo declare primo es inferior a 1/4t .

EJERCICIOS

199

El algoritmo 9.4 requiere, para n − 1 = 2 j r con r impar, t(2 + j) ln n pasos. t es el número de
bases.
Una estrategia que se usa a veces es fijar las bases. Se toman como base algunos de los primeros
primos en vez de tomarlas de manera aleatoria. El resultado importante aquí es este: Si p1 , p2 , ..., pt
son los primeros t primos y si ψt es el más pequeño entero compuesto el cual es seudoprimo
para todas las bases p1 , p2 , ..., pt , entonces el algoritmo de Miller-Rabin, con las bases p1 , p2 , ..., pt ,
siempre responde de manera correcta si n < ψt . Para 1 ≤ t ≤ 8 tenemos

t
1
2
3
4
5
6
7
8

ψt
2047
1 373 653
25 326 001
3 215 031 751
2 152 302 898 747
3 474 749 660 383
341 550 071 728 321
341 550 071 728 321

Implementación en Java. En la clase BigInteger de Java ya viene implementado el método
this.modPow(BigInteger r, BigInteger N) para calcular y = ar (mod N). Para calcular r y s
solo se divide N − 1 por dos hasta que el residuo sea diferente de cero.
En esta implementación usamos los primeros ocho primos como bases. Así el algoritmo responde
de manera totalmente correcta si 19 < N < 341550071728321. En todo caso, también podemos
usar el método this.isProbablePrime(int c) que responde correctamente con una probabili1
dad que excede 1 − c .
2
import java.math.BigInteger;
import java.util.*;
public class Miller_Rabin
{
public Miller_Rabin(){}
public boolean esPrimoMR(BigInteger N)
{

//n>3 e impar. Respuesta 100% segura si N <341 550 071 728 321
BigInteger

N1

= N.subtract(BigInteger.ONE);//N-1

BigInteger

DOS

= new BigInteger("2");

int[]

primo

= {2,3,5,7,11,13,17,19};

int

s

= 0;

boolean

esPrimo = true;

BigInteger

a,r,y;

int

j;

200

NÚMEROS PRIMOS Y FACTORIZACIÓN.

while(N1.remainder(DOS).compareTo(BigInteger.ZERO)==0)//n-1 = 2^s r
{

N1=N1.divide(DOS);
s=s+1;

}
r

= N1;

N1 = N.subtract(BigInteger.ONE);
for(int i=0; i<=7; i++)
{

a = new BigInteger(""+primo[i]);
y = a.modPow(r, N);
if( y.compareTo(BigInteger.ONE)!=0 && y.compareTo(N1)!=0)
{ j=1;
while(j<= s-1 && y.compareTo(N1)!=0 )
{

y = y.modPow(DOS, N);
if(y.compareTo(BigInteger.ONE)==0) esPrimo=false;
j++;

}
if(y.compareTo(N1)!=0) esPrimo = false;
}
}
return esPrimo;
}
public static void main(String[] args)
{
System.out.println("\n\n");
BigInteger

N

Miller_Rabin

= new BigInteger("10011572903");
obj = new Miller_Rabin();

System.out.println(N+" es primo = "+obj.esPrimoMR(N)+"\n\n");
System.out.println("\n\n");
}
}

El resultado de compilar y correr este programa es,
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac Miller_Rabin.java
walter-2@walter2-desktop:~/Escritorio/tn/java$ java Miller_Rabin
10011572903 es primo = true
walter-2@walter2-desktop:~/Escritorio/tn/java$

EJERCICIOS
9.2

Esta implementación falla para n = 2, 3, 5, 7, 11, 13, 17, 19. ¿Porqué?

EJERCICIOS

9.3

201

Mejore la implementación anterior.

9.8

Algoritmo Chino del Resto.

El problema clásico conocido como problema chino del resto puede ser establecido como sigue:

Dados los módulos m0 , m1 , ..., mk ∈ Z y los residuos correspondientes ui ∈ Zmi con i = 0, 2..., k;
encontrar un entero u tal que
u ≡ ui (mod mi ), 0 ≤ i ≤ k.

(9.1)

Las condiciones bajo las cuales se puede garantizar la existencia de una solución única para este
problema se establecen en el siguiente teorema,

Teorema 9.5 (Chino del Resto)
Sean m0 , m1 , ..., mk ∈ Z primos relativos dos a dos, i.e. mcd (mi , m j ) = 1 si i 6= j, y consideremos
los k residuos ui ∈ Zmi , 0 ≤ i ≤ k. Para cada entero fijo a existe un único entero u ∈ Z que
satisface las condiciones




 a≤u<a+m





u ≡ ui (mod mi ),

k

con m = ∏mi ;
i =0

0≤i≤k

Ejemplo 9.6

 u
Consideremos
u

u

≡
49 (mod) 99
≡ −21 (mod) 97
≡ −30 (mod) 95

Aquí m = 912285. Si a = 0 tenemos u = 639985.
La unicidad es “módulo m,” es decir, el problema chino del resto tiene infinitas soluciones en Z
k

pero tiene solución única en Zm , con m = ∏mi .
i =0

Para ver la idea de la prueba, vamos a introducir una notación que nos va a servir más adelante.
Consideremos el Homomorfismo modular φm : Z[ x ] −→ Zm [ x ] (m ≥ 2), definido por
ϕm ( x ) = x

202

NÚMEROS PRIMOS Y FACTORIZACIÓN.

ϕm ( a) = rem( a, m) para todo a ∈ Z.
De acuerdo a la definición, ϕm ( A( x )) solo cambia los coeficientes ai por los nuevos coeficientes
ai mod m. Por ejemplo, ϕ5 (3x6 − x4 + 6x3 + x2 − 3x ) = 3x6 + 4x4 + x3 + x2 + 2x.
Si u ∈ Zm entonces ( ϕm0 (u), ϕm1 (u), ...ϕmn (u)) es uno de los m = ∏in=0 mi distintos n + 1− tuples
posibles en Zm0 × Zm1 × ... × Zmn . Si calculamos ( ϕm0 (u), ϕm1 (u), ...ϕmn (u)) para cada u ∈ Zm ,
en algún momento encontraríamos un u ∈ Zm tal que

( ϕm0 (u), ϕm1 (u), ...ϕmn (u)) = (u0 , u1 , ..., un ).
Así, la unicidad de u debe entenderse en el sentido de que u es único en Zm no en Z, es decir
u es único módulo m.
La idea de la prueba del teorema chino del resto nos dice cómo encontrar u. Lamentablemente
no es práctico buscar u de esta manera pues m puede ser muy grande.
9.8.1

Algoritmo e implementación.

El algoritmo usual para resolver este tipo de problemas se llama “algoritmo de Garner” (por
H.L. Garner). La idea central del método de Garner es, a la manera del polinomio interpolante
de Newton, representar u como una combinación lineal de “base mixta”,

n −1

∏ mi

u = v0 + v1 (m0 ) + v2 (m0 m1 ) + ... + vn

!
(9.2)

i =0

con vk ∈ Zmk , k = 0, 1, ..., n.
Si m es impar, la representación simétrica de Zm es Zm = {−

m−1
m−1
, ..., −1, 0, 1, ...,
}
2
2

La representación de u como una combinación lineal de “base mixta” tiene sentido si cada vk ∈
Zmk tiene el mismo tipo de representación, es decir siempre (para cada k ) Zmk = {0, 1, ..., mk − 1}
o siempre Zmk = {v : −mk /2 < v ≤ mk /2}.
Se puede probar que u siempre se puede representar en la forma (9.2) y, escogida un representación igual para todos los Zmk , los coeficientes vi son únicos.
Ejemplo 9.7
Sean m0 = 99, m1 = 97, y m2 = 95. Si u = 639985,
u = 49 + 62 · (m0 ) + 66 · (m0 m1 ).
Encontrar u es lo mismo que encontrar v0 , v1 , ..., vn .
Para i = 0, de la representación (9.2) se deduce u ≡ v0 (mod m0 ). Así que u ≡ u0 (mod m0 ) tiene
solución u = u0 .
Para k ≥ 1, si se han obtenido los coeficientes v0 , v1 , ..., vk−1 , entonces de (9.2),

EJERCICIOS

k −1

∏ mi

u ≡ v0 + v1 (m0 ) + ... + vk

203

!

(mod mk )

i =0

satisface el caso i = k del sistema de congruencias u ≡ ui (mod mi ), 0 ≤ i ≤ n, si se toma vk de
tal manera que
k −1

v0 + v1 (m0 ) + ... + vk

∏ mi

!

≡ uk (mod mk )

i =0

Esta ecuación la podemos resolver para un único vk ∈ Zmk (k ≥ 1),
"
vk ≡

uk − v0 + v1 (m0 ) + ... + vk−1

k −2

∏ mi

i =0

!#!

k −1

∏ mi

! −1

(mod mk )

i =0

El inverso se puede tomar pues ∏ik=−01 mi y mk son primos relativos.
Algoritmo 9.5: Problema Chino del Resto en Z. Algoritmo de Garner

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

Datos: (u0 , u1 , ...un ), (m0 , m1 , ..., mn ) con mi ∈ Z positivos y primos relativos dos a dos y
u i ∈ Zm i .
Salida: u ∈ Zm con m = ∏in=0 mi tal que u ≡ ui (mod mi ), i = 0, 1, ..., n.
Cálculo de inversos;
for k = 1 to n do
producto = ϕmk (m0 ) ;
for i = 1 to k − 1 do
producto = ϕmk (producto · mi ) ;
γk = (producto)−1 (mód mk ) ;
Cálculo de los vk ;
v0 = u0 ;
j = 0;
for k = 1 to n do
temp = vk−1 ;
j = k − 2;
while j ≥ 0 do
temp = ϕmk (temp · m j + v j ) ;
j = j − 1;
vk = ϕmk ((uk − temp)γk ) ;

22

Pasar u a base 10 ;
u = vn ;
j = n − 1;
while j ≥ 0 do
u = u · mj + vj ;
j = j − 1;

23

return u ;

17
18
19
20
21

204

NÚMEROS PRIMOS Y FACTORIZACIÓN.

En este algoritmo, la solución u entra “representada” en términos de los n + 1 residuos u0 , u1 , ..., un
respecto a los n + 1 módulos m0 , m1 , ..., mn . Luego se pasa a una representación v0 , v1 , ..., vn respecto a la base mixta 1, m0 , ..., ∏in=−01 mi y, como paso final, se reconstruye u en base 10.
Para obtener u en el paso final, se usa una multiplicación anidada
u = v0 + m0 (v1 + m1 (v2 + ... + mn−2 (vn−1 + mn−1 (vn ))...))
En este último paso, cada iteración actualiza u como u = u · m j + v j con j = n − 1, n − 2, ..., 0.
Aquí no es necesario poner u = ϕm (u · m j + v j ) pues estas sumas están en el rango correcto,
es decir u · m j + v j ∈ Zm no importa la representación que se haya usado. En efecto, como
m
|vk | ≤ k entonces, de acuerdo a (9.2), |u| ≤ (∏in=0 mi ) /2 = m/2. Si usamos la representación
2
{0, ..., m − 1} de Zm obtenemos de manera similar, u ≤ m − 1.
Implementación en Java.
import java.math.BigInteger;
class PCR
{ PCR(){}
public BigInteger reprSimetrica(BigInteger m, BigInteger p)
{ BigInteger salida;
BigInteger DOS = new BigInteger("2");
salida = m.mod(p);
//representaci\’on sim\’etrica de Z_p =]-p/2,...-1,0,1,...,p/2]
//si salida > p/2 -> salida= - p = -p/2 +i.
if(salida.compareTo(p.divide(DOS))==1)
salida = salida.add(p.negate());
return salida;
}
//Algoritmo Chino del Resto
public static BigInteger Z_ACR(BigInteger Uis[], BigInteger Ms[])
{ //Requiere Ms[i]>2.
int

n

BigInteger u

= Ms.length-1; //Ms[0],...,Ms[n]
= BigInteger.ZERO;

BigInteger producto = BigInteger.ONE;
BigInteger temp;
BigInteger gamma[] = new BigInteger[n+1]; //gamma[1],...,gamma[n]
BigInteger v[] = new BigInteger[n+1];
//para k=1,2,...,n, gamma_k = (Prod mi_{i=0}^{k-1})^{-1} Mod m_k.
for(int k=1; k<=n; k++)
{

producto = Ms[0].mod(Ms[k]);
for(int i=1; i<= k-1; i++)
producto = (producto.multiply(Ms[i])).mod(Ms[k]);
gamma[k] = producto.modInverse(Ms[k]);

}
int j;
v[0]=Uis[0];
for(int k=1; k<=n; k++)

EJERCICIOS

{

205

temp = v[k-1];
j=k-2;
while(j>=0)
{temp = ((temp.multiply(Ms[j])).add(v[j])).mod(Ms[k]);
j=j-1;
}
v[k]= (Uis[k].subtract(temp)).multiply(gamma[k]).mod(Ms[k]);

}
u = v[n];
j = n-1;
while(j >= 0)
{u = (u.multiply(Ms[j])).add(v[j]);
j = j-1;
}
return u;
}
public static void main(String[] args)
{
System.out.print("\n\n");
PCR

obj = new PCR();

BigInteger uis[]={new BigInteger("49"),new BigInteger("-21"),
new BigInteger("-30")};
BigInteger mis[]={new BigInteger("99"),new BigInteger("97"),
new BigInteger("95")};
System.out.println(""+obj.Z_ACR(uis, mis));
System.out.print("\n\n");
}
}

El programa está preparado para resolver

 u
Consideremos
u

u

≡
49 (mod) 99
≡ −21 (mod) 97
≡ −30 (mod) 95

Aquí m = 912285. Si a = 0 tenemos u = 639985. Este resultado se obtuvo después de compilar
y correr el programa,
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac PCR.java
walter-2@walter2-desktop:~/Escritorio/tn/java$ java PCR
639985
walter-2@walter2-desktop:~/Escritorio/tn/java$

206

NÚMEROS PRIMOS Y FACTORIZACIÓN.

Versión actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

EJERCICIOS

207

Bibliografía
[1] R. Carmichael. The Theory of Numbers. 1er Ed. John Wiley and Sons, 1914.
[2] P. Ribenboim. The Little Book of Bigger Primes. Springer, 2004.
[3] T. Koshy. Elementary Number Theory with Applications. 2da. Ed. Academic Press, 2007.
[4] N. Koblitz A course in number theory and cryptography. 2da ed., Springer,1994.
[5] H. Cohen Number theory. Volume I: Tools and Diophantine Equations. Springer, 2007.
[6] H. Cohen A course in computational algebraic number theory. Springer, 1996.
[7] Lindsay N. Childs. A Concrete Introduction to Higher Algebra. Springer-Verlag New York,
1995.
[8] G.H. Hardy, J.E. Littlewood. An Introduction to Theory of Numbers. Oxford Univ. Press.
1938.
[9] Hans Riesel. Prime Numbers and Computer Methods for Factorization. Springer; 2 edition.
1994.
[10] Mark Kac. Statistical Independence in Probability Analysis and Number Theory. John Wiley
and Sons, Inc. 1964.
[11] Harold Stark, An introduction to number theory. The MIT Press, 1987.
[12] M. Atallah, M. Blanton (2010). Algorithms and theory of computation handbook. General concepts and techniques. Chapman & Hall. CRC applied algorithms and data structures series.
2nd ed.
[13] E. Bach, J. Shallit (1996). Algorithmic Number Theory, Vol. 1: Efficient Algorithms. Cambridge,
MA: MIT Press, 1996.
[14] M. O’Neill., “The Genuine Sieve of Eratosthenes”. Journal of Functional Programming.
Published online by Cambridge University Press. October 2008.
[15] Jonathan Sorenson. “An Analysis of Two Prime Number Sieves”. Computer Sciences
Technical Report #1028. Department of Computer Sciences University of WisconsinMadison, June 10. 1991
[16] T. Jebelean (1993). “Comparing several GCD algorithms”. En ARITH-11: IEEE Symposium on Computer Arithmetic. IEEE, New York, 180-185.
[17] D. Knuth (1981). The Art of Computer Programming. Volume 1: Fundamental Algorithms.
Addison-Wesley. 2nd ed.
[18] D. Knuth (1981). The Art of Computer Programming. Volume 2: Seminumerical Algorithms.
Addison-Wesley. 2nd ed.
[19] G. Norton (1987). A shift-remainder GCD algorithm. Proceedings of the 5th international
conference, AAECC-5 on Applied Algebra, Algebraic Algorithms and Error-Correcting
Codes, p.350-356, 1987.
[20] J. Shallit, J. Sorenson (1994). Analysis of a Left-Shift Binary GCD Algorithm. J. Symbolic
Computation (1994) 17, 487-511
[21] A. Stepanov (2007). Notes on Programming. En http://www.stepanovpapers.com
[22] A. Stepanov, P. McJones (2009). Elements of Programming. Addison-Wesley.
[23] A.Weilert (2000). (1 + i )−ary GCD Computation in Z [i ] as an Analogue to the Binary
GCD Algorithm.J. Symbolic Computation (2000) 30, 605-617.
[24] William H. Press et all, NUMERICAL RECIPES. The Art of Scientific Computing. Third
Edition. Cambrifge University Press.
[25] S. Y. Yan. Number Theory for Computing. 2nd edition. Springer. 2001.

[26] Eric Weisstein, “Polygonal Number.” MathWorld–A Wolfram Web Resource. http://
mathworld.wolfram.com/PolygonalNumber.html

[27] Jim
The

Delany, “Geometric Proof of the Tetrahedral Number Formula”.
Wolfram
Demonstrations
Project.
http://demonstrations.wolfram.com/

GeometricProofOfTheTetrahedralNumberFormula/

[28] R. Brent. “An Improved Monte Carlo Factorization Algorithm.” BIT 20 (1980), 176-184.
http://wwwmaths.anu.edu.au/~brent/pub/pubsall.html

[29] R. Brent, J. M. Pollard. “Factorization of the Eighth Fermat Number.” Mathematics of
Computation, vol 36, n 154 (1981), 627-630. http://wwwmaths.anu.edu.au/~brent/pub/
pubsall.html.
[30] Harold M. Edwards. Riemann’s Zeta Function. Dover Publications Inc. 2001.

Solución de los Ejercicios

Soluciones del Capítulo 2
2.1 6|2 · 3 pero 6 - 2 y 6 - 3
2.2 si d| a ∧ d|( a + 1) =⇒ d|( a + 1 − a) Luego, d|1 =⇒ d = ±1.
2.3 Si kd|n =⇒ n = k0 kd =⇒ d|n (⇒⇐)
2.4 Como d| a y d|b =⇒ d|( a − bq) =⇒ d|r
2.5 Como a − r = bq y 0 ≤ r < |b|, bq debe ser uno de los números { a, a − 1, ..., a − |b| + 1}
2.6 d| a y d|( ab + 2) =⇒ d| ab ∧ d|( ab + 2) =⇒ d|2 =⇒ d = 1, ∨ d = 2, pero como a es impar,
d = 1.
2.7 | A3 ∪ B5 ∪ C7 | = | A3 | + | B5 | + |C7 | − | A3 ∩ B5 | − | B5 ∩ C7 | − |C7 ∩ A3 | + | A3 ∩ B5 ∩ C7 | = 1629.

2.9 Si a = 6, b = 3; 3 = mcd (6, 3) 6= mcd (6, 6) 6= mcd (6, 6 − 4 · 3).
2.10 Sean d = mcd ( ab, m), d1 = mcd ( a, m), d2 = mcd (b, m). Por Bezout,

 ax1 + my1 = d1
=⇒ abx + my = d1 d2 =⇒ d|d1 d2

bx2 + my2 = d2
2.11 Sean d = mcd ( ab, m), d1 = mcd ( a, m), d2 = mcd (b, m).
Por Bezout, ax + by = 1, luego axm + bym = m. Como d1 es múltiplo de a y d2 es múltiplo de
m, se sigue axm = k1 d1 d2 . De manera análoga, bym = k2 d1 d2 .
Así, d1 d2 |m ∧ d1 d2 | ab y entonces d1 d2 |d. Usando el ejercicio anterior se concluye que d1 d2 = d.


ax + by
as + ct
xct + sby) + bc(yt) = 1, es decir, mcd ( a, bc) = 1.

2.13 Por Bezout, existen x, y, s, t ∈ Z tal que

= 1
, Multiplicando obtenemos a( axs +
= 1

2.15 Por Bezout ax + by = d =⇒ k1 x + k2 y = 1, por (2.1, 4) mcd (k1 , k2 ) = 1
2.16 ra + sb = d =⇒ rk1 d + sk2 d = d =⇒ rk1 + sk2 = 1 =⇒ mcd (r, s) = 1 por (2.1, 4).
2.17 Sea d = mcd ( a, b), a y b son múltiplos de d, entonces am + bn = h =⇒ k1 dm + k2 dn =
h =⇒ d|h.
2.18 “=⇒ ”: es el ejercicio anterior.
“⇐= ”: Sea d = mcd ( a, b) y sea h = kd. Usando el algoritmo extendido de Euclides podemos
calcular x1 , y1 ∈ Z tal que ax1 + by1 = d =⇒ ax1 k + by1 k = kd = h. Luego, la solución de la
ecuación diofántica es x = x1 k y y = y1 k.
2.19 Por el algoritmo extendido de Euclides, 1 = 365 · −699 + 1876 · 136 luego 24 = 365 · −16776 +
1876 · 3264
p
2.20 Seap k2 − kp = d ∈ N. Luego k2 − kp − d2 = 0 de donde
p ± p2 + 4 · 1 · d2
(∗)
k=
2
p
k es entero, así que p2 + 4d2 debe ser cuadrado perfecto, sea p2 + 4d2 = a2 , entonces
p = ( a − 2d)( a + 2d)
como p es primo, solo tenemos las dos posibilidades siguientes,
1. p = ( a − 2d) y p = ( a + 2d)
2. p2 = a + 2d y a − 2d = 1 pues a + 2d ≥ a − 2d.
En el primer caso d = 0 (y a = p). Entonces k = 0 o k = p
En el segundo caso, resolvemos el sistema y obtenemos d = ( p2 − 1)/2 (y a = ( p2 + 1)/2 ). Como
a, d son naturales, este caso se cumple si p es impar, es decir p 6= 2. Sustituyendo d en (∗) y
resolviendo queda k = ( p + 1)/2 y k = −( p − 1)/2.
Note que si p = 2 solo puede suceder el primer caso y queda k = 0 o k = 2.
2.21 Para n = 2 es cierto, por el lema de Euclides.
Si es cierto para n = k y pi |(q1 q2 · sqk ) · qk+1 , por el lema de Euclides, pi |(q1 q2 · sqk ) o pi |qk+1 .
Aplicando la hipótesis de inducción en el primer caso pi |q j para algún j ∈ {1, 2, ..., k }, sino
p i | q k +1 .
209

210

SOLUCIÓN DE LOS EJERCICIOS

βj

α

2.26 Sean a = ∏i pi i , m = ∏ j q j y n = ∏s rsδs la descomposición prima de estos números. Luego,
como mn y ak son iguales, su descomposición prima es la misma excepto por el orden de los
factores, i.e.
k · αi

βj

δ
∏ j q j ∏ s r s s = ∏i pi

βj

k · αi

Entonces para cada j, q j = pi
kαd

∏d pd

j

j

k · αis

y para cada s, rsδs = pis

k
t
. Luego, m = ∏t pkα
t = x y n=

= yk .

2.29 Hay un k ∈ Z tal que p − 3 = 4k, entonces p − 7 = 4(k − 1), por tanto 4| p − 7. Usando
la misma idea, comprobamos que 3| p − 7. Como mcd (3, 4) = 1, mcm (3, 4) = 12 y entonces
12| p − 7.
2.31 Si p1 , p2 , p3 son primos, mcd ( p1 p2 , p2 p3 , p1 , p3 ) = 1 y mcd ( pi p j , p j pk ) 6= 1. También, si
a = 2 · 3 · 5, b = 5 · 7 · 11 y c = 11 · 2, mcd ( a, b, c) = 1
mcd ( a, b) = 5
mcd ( a, c) = 2
mcd (b, c) = 11
2.32 Sea d = mcd ( a, a + 1). Como d| a ∧ d|( a + 1) =⇒ d|1. Luego, d = 1.
Otra manera: d = mcd ( a − 1, a) =⇒ d ≤ a − ( a − 1) = 1 pues d es la mínima combinación lineal
positiva de a y a − 1.
2.33 m = mcd ( a, b) = mcm ( a, b) =⇒ m| a ∧ m|b ∧ a|m ∧ b|m =⇒ a = b (por ser ambos
positivos).
2.34 Sea d = mcd (mg, g), entonces d| g =⇒ d ≤ g. Pero g| g ∧ g| gm, entonces g = d.
2.35 mcd ( a, b) = mcd ( a, k a) = a según el ejercicio anterior. mcm ( a, b) =

ab
= b.
a

2.36
“=⇒ ”: g| x y g|y =⇒ g|s.
“⇐= ”: g|s =⇒ s = kg = (k − 1) g + g. Así, si x = (k − 1) g y y = g entonces s = x + y y mcd ( x, y) =
mcd ((k − 1) g, g) = g, por ser g positivo.
a c
ad + bc
+ =
∈ Z, entonces bd|( ad + bc). Como ad + bc = bd se tiene que b|( ad + bc)
b d
bd
y d|( ad + bc). Luego, b| ad ∧ d|bc. Finalmente, como mcd ( a, b) = mcd (c, d) = 1 se concluye que
b|d ∧ d|b, es decir | a| = |b|.

2.37 Si

2.38 Sea d = mcd ( a, b) y m = mcd ( a, b, ax + by). Como d| a ∧ d|b =⇒ d|( ax + by) y por tanto
d|m.
Luego, como m| a ∧ m|b =⇒ m|d.
∴ d = m, por ser ambos positivos.
2.39 d = mcd ( a, a + 2) =⇒ d| a ∧ d|( a + 2) =⇒ d|2 =⇒ d = 1 ∨ d = 2.
9.1 Muestre que si n = pq, con p, q factores no triviales de n y p|(y − x ) y n - (y − x ), entonces
1 < mcd (y − x, n) < n.
2.40 Usar la factorización prima de N y deducir que sus factores no son los pi0 s.

SOLUCIÓN DE LOS EJERCICIOS

211

2.41 Sea dm = mcd (ma, mb) y d = mcd ( a, b). Por Bezout, existen x, y, s, t ∈ Z tal que
dm = amx + bmy = m( ax + by) = m(kd) pues d|( ax + by). Luego, md|dm .
d = as + bt =⇒ md = (ma)s + (mb)t =⇒ dm |md.
md|dm ∧ dm |md =⇒ |dm | = |md| =⇒ dm = |m|d, por ser dm y d positivos.
2.42 d|(2( a + 2b) − (2a + b)), i.e. d|3b.
d|(2(2a + b) − ( a + 2b)), i.e. d|3a
Luego d| mcd (3a, 3b) =⇒ d|3 mcd ( a, b) =⇒ d|3 por ejercicio(2.41). Luego, d = 1 o d = 3.
2.43 Asuma que A es entero. Sea 2α la más grande potencia de 2 que es ≤ n, i.e. 2α ≤ n pero
2α · 2 > n .
β

Considere todas las máximas potencias pi i , de los primos impares pi , que no exceden n, es decir,
β

β +1

pi i ≤ n pero pi i

> n. Sea P es producto de todas estas potencias, P = ∏ pi i .
β

i

Consideremos el producto


1
2α −1 P 2α −1 P
2α −1 P
2α −1 P
1 1
= 2α −1 P +
+
+ ... +
+ ... +
.
2α−1 P 1 + + + ... +
α
2 3
n
2
3
2
n
Analizamos ahora cada fracción

2α −1 P
δ
. Si k tiene factorización prima k = 2δ ∏ qi i ,
k
i


2α −1 P




 2δ ∏i qδi
i

2α −1 P
=

k

α −1 P


 2
2α

Por definición de P, los qi aparecen en P pero con una potencia igual o mayor, es decir, para
2α −1 P
cada i hay un j tal que qi = p j y δi ≤ β j . Luego, como δ ≤ α − 1, entonces
es entero.
δ
2δ ∏ i q i i
Pero, por otra parte, el caso 2α−1 P/2α = P/2 = m + 1/2 con m entero, por ser P impar. Resumiendo,

2

α −1

PA

= 2

α −1



1 1
1
P 1 + + + ... +
2 3
n

= 2α −1 P +



2α −1 P
2α −1 P
2α −1 P 2α −1 P
+
+ ... +
+
...
2
3
2α
n

= Q + P/2 = Q0 + 1/2,

con Q, Q0 enteros.

Pero si A es entero, 2α−1 PA es entero, mientras que Q0 + 1/2 no (⇒⇐).

212

SOLUCIÓN DE LOS EJERCICIOS

2.47.a La verificación es directa:
Tn2−1 − 2Tn−1

= (22

n −1

2n −1 ·2

= 2

+ 1 ) 2 − 2 ( 22
2n −1

+2·2

n −1

+ 1)

+ 1 − 2 · 22

n −1

−2

2n

= 2 −1

2.47.b La fórmula anterior es una fórmula recursiva:
n

22 − 1 = Tn − 2 = Tn2−1 − 2Tn−1 = Tn−1 ( Tn−1 − 2), i.e.
Tn − 2 = Tn−1 ( Tn−1 − 2). Luego,
Tn − 2

= Tn−1 ( Tn−1 − 2)
= Tn−1 ( Tn−2 ( Tn−2 − 2))
= Tn−1 Tn−2 Tn−3 ( Tn−3 − 2)
..
.
= Tn−1 Tn−2 Tn−3 · sT0 ( T0 − 2)
= Tn−1 Tn−2 Tn−3 · sT0 , pues T0 − 2 = 3 − 2 = 1

2.47.c Tm = Tm−1 · sTn · sT0 + 2. Si mcd ( Tn , Tm ) = d entonces d| Tm =⇒ d|( Tm−1 · sTn · sT0 + 2)
y como d| Tn , d|2. Así que d = 1 o d = 2. Pero por definición, Tm y Tn son impares.

Introducción a la Teoría de Números.. Walter Mora F.
Derechos Reservados © Revista digital Matemática, Educación e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)


